<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>曼荼羅迷宮記 — 六印巡礼（金剛界）</title>
  
  <style>
    :root{
      --bg:#0b0f16; --panel:#0f1624; --panel2:#0c1220; --text:#e6edf3; --muted:#9aa8b7;
      --accent:#7dd3fc; --good:#22c55e; --warn:#f59e0b; --bad:#ef4444; --line:#1f2a3a;
      --shadow: 0 10px 30px rgba(0,0,0,.35);
      --glow: 0 0 0 1px rgba(125,211,252,.10), 0 18px 50px rgba(0,0,0,.35);
      --glass: rgba(9,14,22,.55);
      --glass2: rgba(15,22,36,.72);
      --shine: linear-gradient(135deg, rgba(125,211,252,.22), rgba(34,197,94,.10), rgba(251,191,36,.12));
    }
    *{box-sizing:border-box}
    body{
      margin:0;
      font-size:13px;
      line-height:1.25;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Hiragino Kaku Gothic ProN", "Yu Gothic", "Noto Sans JP", "Meiryo", sans-serif;
      background: radial-gradient(1200px 800px at 10% -10%, #1b2b55 0%, rgba(27,43,85,0) 60%),
                  radial-gradient(1000px 600px at 110% 10%, #143b30 0%, rgba(20,59,48,0) 60%),
                  repeating-linear-gradient(90deg, rgba(255,255,255,.03) 0 1px, rgba(255,255,255,0) 1px 12px),
                  repeating-linear-gradient(0deg, rgba(255,255,255,.02) 0 1px, rgba(255,255,255,0) 1px 14px),
                  var(--bg);
      color:var(--text);
    }
    header{
      position:sticky; top:0; z-index:10;
      background: rgba(11,15,22,.68);
      backdrop-filter: blur(10px);
      border-bottom:1px solid var(--line);
    }
    .wrap{max-width:1180px; margin:0 auto; padding:8px 10px 10px;}
    .topbar{display:flex; gap:8px; align-items:center; justify-content:space-between;}
    .brand{display:flex; flex-direction:column; line-height:1.15;}
    .brand b{font-size:14px; letter-spacing:.4px}
    .brand span{font-size:12px; color:var(--muted)}
    
    .locBadge{
      display:inline-flex; align-items:center; gap:8px;
      padding:6px 10px; border-radius:999px;
      border:1px solid #27364f;
      background: rgba(11,26,45,.45);
      color:var(--muted);
      font-weight:950; font-size:12px;
      white-space:nowrap;
    }
    .locBadge b{
      color:var(--text);
      display:inline-block;
      min-width:0;
      text-align:left;
      font-variant-numeric: tabular-nums;
    }
    @media  (max-width: 520px){
      .locBadge b{min-width:0; text-align:left;}
    }

    .tabs{
      display:flex; gap:6px; flex-wrap:wrap;
      background: rgba(7,10,16,.35);
      border:1px solid var(--line);
      padding:6px;
      border-radius:14px;
    }
    .tabBtn{
      padding:6px 10px;
      border-radius:14px;
      border:1px solid #223049;
      background: rgba(11,26,45,.35);
      color: var(--muted);
      font-weight:950;
      cursor:pointer;
      box-shadow:none;
    }
    .tabBtn.active{
      border-color:#2a4b6a;
      color:var(--text);
      background: rgba(20,50,80,.35);
    }
    .tag .safe{color:#86efac}
    /* Monster affix (付帯特性) tooltip */
    .modTag{
      text-decoration: underline dotted;
      text-underline-offset: 2px;
      cursor: help;
    }
    .controls{display:flex; gap:8px; flex-wrap:wrap; align-items:center; justify-content:flex-end;}
    button, select{
      background: linear-gradient(180deg, #141e2f, #0f1726);
      border:1px solid #223049;
      color:var(--text);
      padding:8px 10px;
      border-radius:14px;
      cursor:pointer;
      box-shadow: 0 6px 18px rgba(0,0,0,.25);
      font-weight:800;
      font-size:12px;
    }
    button{transition: transform .08s ease, border-color .15s ease, box-shadow .15s ease, background .15s ease}
    button:disabled{opacity:.45; cursor:not-allowed; filter:saturate(.6);}

    button:hover{border-color:#2f4366; box-shadow: var(--glow)}
    button:active{transform: translateY(1px)}
    button.small{padding:8px 10px; border-radius:10px; font-weight:900}
    button.lockBtn{padding:2px 6px; border-radius:999px; font-weight:950; font-size:11px; line-height:1; background:rgba(255,255,255,.02); box-shadow:none;}
    button.lockBtn.locked{border-color:#6b3b44; background:rgba(239,68,68,.08);}
    button.ghost{background:transparent; box-shadow:none}
    button.bad{border-color:#4a1f27}
    button.accent{border-color:#2a4b6a}
    select{padding:7px 10px}
    /* Select / option readability: improve dropdown contrast across OS/browsers */
    select{ color-scheme: dark; }
    select option, select optgroup{
      background-color:#0f1726;
      color: var(--text);
    }
    select:focus-visible{
      outline: 2px solid rgba(125,211,252,.35);
      outline-offset: 2px;
    }
    .grid{display:grid; grid-template-columns: 1.05fr .95fr; gap:10px; margin-top:10px;}
    @media (max-width: 980px){ .grid{grid-template-columns:1fr;} .controls{justify-content:flex-start} }

    .card{
      background: linear-gradient(180deg, rgba(15,22,36,.95), rgba(12,18,32,.92));
      border:1px solid var(--line);
      border-radius:14px;
      box-shadow: var(--shadow); position:relative;
      overflow:hidden;
    }
    .card h2{
      margin:0; padding:12px 14px;
      font-size:13px; letter-spacing:.3px;
      border-bottom:1px solid var(--line);
      display:flex; align-items:center; justify-content:space-between;
    }
    .card h2 span{color:var(--muted); font-weight:800; font-size:12px; min-width:0; max-width:100%; overflow:hidden; text-overflow:ellipsis; white-space:nowrap;}
    #runInfo{max-width: 60%; min-width:22ch; text-align:right; overflow:hidden; text-overflow:ellipsis; white-space:nowrap; font-variant-numeric: tabular-nums;}
    @media (max-width: 520px){ #runInfo{max-width:100%; min-width:0; text-align:left; white-space:normal;} }
    @media (max-width: 520px){ .card h2 span{white-space:normal; overflow:visible; text-overflow:clip;} }
    .card h2{gap:10px; flex-wrap:wrap;}
    .card .body{padding:10px 12px;}
    .row{display:flex; gap:10px; flex-wrap:wrap}
    .col{flex:1 1 260px}
    .split{display:grid; grid-template-columns: 1fr 1fr; gap:10px;}
    @media (max-width: 520px){ .split{grid-template-columns:1fr} }

    .statgrid{display:grid; grid-template-columns: repeat(2, minmax(0, 1fr)); gap:8px;}

    .statgrid.stack{grid-template-columns: 1fr;}
    .lvCompact .k{font-size:10px}
    .lvCompact .v{font-size:12px}
    .lvCompact .sub{font-size:10px}

    @media (max-width: 420px){ .statgrid{grid-template-columns:1fr} }
    .stat{
      background: rgba(9,14,22,.55);
      border:1px solid var(--line);
      border-radius:14px;
      padding:10px 10px;
    }
    .stat .k{font-size:11px; color:var(--muted)}
    .stat .v{font-size:clamp(12px, 2.7vw, 14px); font-weight:950; margin-top:2px; font-variant-numeric: tabular-nums;}
    .atkDefGrid{display:grid; grid-template-columns: 1fr 1fr; gap:8px; margin-top:6px;}
    @media (max-width: 520px){ .atkDefGrid{grid-template-columns:1fr;} }
    .bigStat{background: rgba(7,10,16,.25); border:1px solid rgba(31,42,58,.55); border-radius:14px; padding:10px;}
    .bigStat .k2{font-size:11px; color:var(--muted)}
    .bigStat .v2{margin-top:2px; font-weight:1000; font-size:clamp(14px, 3.5vw, 18px); font-variant-numeric: tabular-nums;}

    .stat, .enemybox, .slot{min-width:0;}
    .bar{height:10px; border-radius:999px; border:1px solid var(--line); background: rgba(0,0,0,.25); overflow:hidden;}
    .fill{height:100%; width:50%;}
    /* Large numbers can wrap without crushing the layout */
    .sub{display:flex; flex-wrap:wrap; align-items:flex-start; justify-content:space-between; gap:6px 10px; margin-top:6px; font-size:11px; color:var(--muted); font-variant-numeric: tabular-nums;}
    .sub span{min-width:0; flex:1 1 240px; white-space:normal; overflow-wrap:anywhere; word-break:break-word;}
    @media (max-width: 520px){ .sub span{flex-basis:100%;} }

    /* Enemy stats line: keep it on a single line (no accidental 2-line wrap) */
    .sub.oneLine{flex-wrap:nowrap; align-items:center;}
    .sub.oneLine span{
      flex:0 1 auto;
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
      overflow-wrap:normal;
      word-break:normal;
      flex-basis:auto !important;
    }
    .sub.oneLine span:first-child{flex:0 0 auto;}
    .sub.oneLine span:last-child{flex:1 1 auto; text-align:right;}

    .enemybox{
      background: rgba(9,14,22,.55);
      border:1px solid var(--line);
      border-radius:14px;
      padding:12px;
    }
    .enemyname{font-weight:950; font-size:14px}

    /* v33: 魔情報の配置（左: 界相+名前 / 右: 安全・天魔等） */
    .enemyTitle{display:flex; align-items:center; justify-content:space-between; gap:10px; flex-wrap:wrap;}
    .enemyLeft{display:flex; align-items:center; gap:10px; min-width:0; flex:1 1 auto;}
    .enemyText{min-width:0;}
    .enemyBiome{margin-bottom:2px;}
    .tag.mini{font-size:10px; padding:2px 7px;}
    .enemyFlags{display:flex; gap:6px; align-items:center; justify-content:flex-end; margin-left:auto;}

    /* v33: 功徳相/法具座を縦方向に詰める */
    .stat.tight{padding:8px 10px;}
    .stat.tight .atkDefGrid{margin-top:4px; gap:6px;}
    .stat.tight .bigStat{padding:8px; border-radius:14px;}
    .stat.tight .sub{margin-top:4px;}
    .equipSlots{gap:6px;}
    .equipSlots .slot{padding:6px;}
    .slot .v{margin-top:2px;}
    .tag{
      display:inline-flex; align-items:center; gap:6px;
      padding:3px 8px; border-radius:999px;
      background: rgba(12,26,42,.65);
      border:1px solid #223049;
      color:var(--muted);
      font-size:11px; font-weight:900;
    }
    .tag b{color:var(--text)}
    /* UI stability: keep adjacent tags from shifting when numbers grow */
    #roomText, #floorText{
      display:inline-block;
      min-width:7ch;
      text-align:right;
      font-variant-numeric: tabular-nums;
    }

    .tag .elite{color:#fbbf24}
    .tag .boss{color:#fb7185}

    .log{
      height:280px; overflow:auto;
      overflow-anchor: none;
      overscroll-behavior: contain;
      scrollbar-gutter: stable;
      background: rgba(7,10,16,.55);
      border:1px solid var(--line);
      border-radius:16px;
      padding:10px;
      font-size:12px;
      line-height:1.35;
    }
    .log .t{color:var(--muted); font-size:10px; margin-right:6px}
    .log .good{color:#86efac}
    .log .bad{color:#fda4af}
    .log .rare{color:#c4b5fd}
    .log .warn{color:#fbbf24}
    .log .gold{color:#fbbf24}

    .log .k{font-weight:900; letter-spacing:.02em}
    .log .indent{display:inline-block; margin-left:12px}
    .log .sep{display:block; margin:4px 0; color:rgba(148,163,184,.55)}

    /* --- Log readability upgrade --- */
    .log{ font-variant-numeric: tabular-nums; }
    .log .entry{
      display:flex;
      gap:8px;
      align-items:flex-start;
      transition: transform .46s cubic-bezier(.15,.85,.2,1), opacity .46s ease, background .30s ease, box-shadow .30s ease;
      padding:8px 10px;
      border-radius:14px;
      margin:3px 0;
      background: rgba(255,255,255,.02);
      border:1px solid rgba(148,163,184,.10);
    }
    .log .entry:nth-child(2n){ background: rgba(255,255,255,.03); }
    .log .entry.new{
      opacity:0;
      transform: translateY(18px);
      box-shadow: 0 10px 22px rgba(0,0,0,.25);
    }
    .log .time{
      flex:0 0 auto;
      color: rgba(148,163,184,.85);
      font-size:10px;
      line-height:1.4;
      min-width:44px;
      text-align:right;
      margin-top:1px;
    }
    .log .badge{
      flex:0 0 auto;
      display:inline-flex;
      align-items:center;
      gap:6px;
      padding:2px 8px;
      border-radius:999px;
      font-size:10px;
      font-weight:800;
      letter-spacing:.04em;
      line-height:1.6;
      border:1px solid rgba(148,163,184,.18);
      background: rgba(15,22,36,.65);
      color: rgba(226,232,240,.92);
      white-space:nowrap;
      user-select:none;
    }
    .log .badge .ico{ font-size:11px; opacity:.95; }
    .log .msg{
      flex:1 1 auto;
      min-width:0;
      word-break:break-word;
    }

    /* left accent by kind */
    .log .kind-combat{ border-left:3px solid rgba(125,211,252,.55); }
    .log .kind-sell{ border-left:3px solid rgba(251,191,36,.65); }
    .log .kind-chest{ border-left:3px solid rgba(196,181,253,.65); }
    .log .kind-empower{ border-left:3px solid rgba(34,197,94,.55); }
    .log .kind-mantra{ border-left:3px solid rgba(147,197,253,.60); }
    .log .kind-purify{ border-left:3px solid rgba(248,113,113,.60); }
    .log .kind-realm{ border-left:3px solid rgba(167,243,208,.55); }
    .log .kind-seal{ border-left:3px solid rgba(216,180,254,.65); }
    .log .kind-reward{ border-left:3px solid rgba(250,204,21,.45); }
    .log .kind-system{ border-left:3px solid rgba(148,163,184,.35); }

    /* severity tint */
    .log .sev-good{ box-shadow: inset 0 0 0 999px rgba(34,197,94,.03); }
    .log .sev-warn{ box-shadow: inset 0 0 0 999px rgba(245,158,11,.03); }
    .log .sev-bad{  box-shadow: inset 0 0 0 999px rgba(239,68,68,.03); }
    .log .sev-rare{ box-shadow: inset 0 0 0 999px rgba(196,181,253,.03); }

    /* compress inline spans inside msg */
    .log .msg .k{ font-weight:900; }
    .log .msg .indent{ margin-left:10px; }
    .hr{height:1px; background:var(--line); margin:8px 0;}

    .invTop{
  display:grid;
  grid-template-columns: 1fr;
  gap:8px;
  align-items:center;
}
@media (min-width: 860px){
  .invTop{grid-template-columns: auto 1fr; align-items:start;}
}
.invTabsWrap{min-width:0}
.invTools{
  min-width:0;
  display:flex;
  gap:8px;
  flex-wrap:wrap;
  align-items:center;
  justify-content:flex-end;
}
.searchWrap{
  position:relative;
  flex:1 1 280px;
  max-width:520px;
  min-width:220px;
}
.searchWrap input{
  width:100%;
  flex:1 1 auto;
  padding-left:30px;
  padding-right:34px;
}
.searchIcon{
  position:absolute;
  left:10px;
  top:50%;
  transform: translateY(-50%);
  color: var(--muted);
  font-weight:950;
    font-size:12px;
  line-height:1;
opacity:.9;
  pointer-events:none;
  user-select:none;
}
.iconBtn{
  position:absolute;
  right:8px;
  top:50%;
  transform: translateY(-50%);
  padding:4px 8px;
  border-radius:999px;
  font-weight:950;
  font-size:11px;
  line-height:1;
  background: rgba(255,255,255,.02);
  box-shadow:none;
  opacity:.0;
  pointer-events:none;
}
.searchWrap input:not(:placeholder-shown) ~ .iconBtn{
  opacity:1;
  pointer-events:auto;
}
.invFilters{
  margin-top:6px;
  padding:6px;
  border-radius:12px;
  border:1px solid rgba(31,42,58,.85);
  background: rgba(7,10,16,.35);
  display:flex;
  gap:6px;
  align-items:center;
  flex-wrap:nowrap;
  overflow-x:auto;
  overflow-y:hidden;
  white-space:nowrap;
  scrollbar-width:thin;
  -webkit-overflow-scrolling:touch;
}
.invFilters .filterGroup{display:flex; gap:6px; align-items:center}
.invFilters .fLabel{color:var(--muted); font-size:11px; font-weight:900}
.invFilters select{
  padding:5px 9px;
  border-radius:999px;
  font-size:11.5px;
}
.invFilters input[type="number"]{
  width:64px;
  background: rgba(9,14,22,.55);
  border:1px solid var(--line);
  color:var(--text);
  padding:5px 9px;
  border-radius:999px;
  outline:none;
  font-weight:900;
  font-variant-numeric: tabular-nums;
}
.checkPill{
  display:inline-flex;
  align-items:center;
  gap:6px;
  padding:5px 9px;
  border-radius:999px;
  border:1px solid #27364f;
  background: rgba(11,26,45,.45);
  color:var(--muted);
  font-weight:900;
  font-size:11.5px;
  user-select:none;
}
.checkPill span{white-space:nowrap}
.checkPill input{accent-color: var(--accent); transform: translateY(1px);}

    input[type="text"]{
      background: rgba(9,14,22,.55);
      border:1px solid var(--line);
      color:var(--text);
      padding:8px 10px;
      border-radius:14px;
      outline:none;
      flex:1 1 180px;
    }

    /* Search box: reserve space for icon + clear button (avoid overlap) */
    .searchWrap input[type="text"]{
      padding-left:36px;
      padding-right:40px;
    }
    .list{margin-top:8px; display:flex; flex-direction:column; gap:6px; max-height:560px; overflow:auto; padding-right:2px;}

    /* Scrollbars */
    .log::-webkit-scrollbar, .list::-webkit-scrollbar{width:10px; height:10px}
    .log::-webkit-scrollbar-thumb, .list::-webkit-scrollbar-thumb{background: rgba(148,163,184,.25); border-radius:999px; border:2px solid rgba(7,10,16,.35)}
    .log::-webkit-scrollbar-track, .list::-webkit-scrollbar-track{background: rgba(7,10,16,.15); border-radius:999px}

    /* Inventory items */
    .item{
  position:relative;
  background: linear-gradient(180deg, rgba(9,14,22,.62), rgba(9,14,22,.46));
  border:1px solid var(--line);
  border-radius:16px;
  padding:10px 10px 10px 22px;
  display:grid;
  grid-template-columns: 1fr auto;
  gap:10px;
  align-items:center;
  justify-content:space-between;
  transition: transform .12s ease, box-shadow .15s ease, border-color .15s ease, background .15s ease;
}
    .item::before{content:""; position:absolute; left:10px; top:8px; bottom:8px; width:4px; border-radius:999px; opacity:.92; background: rgba(203,213,225,.55)}
    .item:hover{transform: translateY(-1px); border-color:#2a4b6a; box-shadow: var(--glow)}
    .item.selected{border-color:#2a4b6a; box-shadow: 0 0 0 1px rgba(125,211,252,.22), var(--shadow), 0 0 24px rgba(125,211,252,.08)}
    .item.rar-common::before{background: linear-gradient(180deg, rgba(203,213,225,.65), rgba(148,163,184,.35))}
    .item.rar-uncommon::before{background: linear-gradient(180deg, rgba(134,239,172,.75), rgba(34,197,94,.30))}
    .item.rar-rare::before{background: linear-gradient(180deg, rgba(147,197,253,.75), rgba(125,211,252,.30))}
    .item.rar-epic::before{background: linear-gradient(180deg, rgba(196,181,253,.80), rgba(167,139,250,.30))}
    .item.rar-legendary::before{background: linear-gradient(180deg, rgba(251,191,36,.85), rgba(245,158,11,.35))}
    .item.rar-unique::before{background: linear-gradient(180deg, rgba(251,113,133,.85), rgba(239,68,68,.35))}

    .item .left{min-width:0; display:flex; gap:10px; align-items:flex-start}
    .itText{min-width:0; flex:1}

    /* Inventory stat pills (horizontal, balanced) */
    .istat{margin-top:4px; display:grid; grid-template-columns: repeat(auto-fit, minmax(92px, 1fr)); gap:4px;}
    .istat .sp{
      display:block;
      font-size:10.5px;
      line-height:1.2;
      padding:2px 8px;
      border-radius:999px;
      border:1px solid #27364f;
      background: rgba(11,26,45,.45);
      color: var(--muted);
      font-weight:900;
      font-variant-numeric: tabular-nums;
      white-space:nowrap; overflow:hidden; text-overflow:ellipsis;
      text-align:center;
    }

    .istat .sp.capDead{
      opacity:.38;
      filter:saturate(.65);
    }
    .istat .sp .maxTag{
      display:inline-block;
      margin-left:6px;
      padding:1px 6px;
      border-radius:999px;
      border:1px solid rgba(245,158,11,.45);
      background: rgba(245,158,11,.12);
      color: var(--warn);
      font-size:10px;
      font-weight:1000;
      letter-spacing:.02em;
      vertical-align:baseline;
    }

    /* Pixel sprites (no external assets) */
    .enemyTitle{display:flex; align-items:center; justify-content:space-between; gap:10px; flex-wrap:wrap;}
    /* Pixel art readability: keep CSS sizes as integer multiples of the 16x16 canvas */
    .pxSprite{width:32px; height:32px; image-rendering: auto; border:1px solid var(--line); border-radius:14px; background: rgba(0,0,0,.18); box-shadow: inset 0 0 0 1px rgba(255,255,255,.03)}
    .pxHero{width:32px; height:32px; image-rendering:auto}
    .pxStage{image-rendering:auto}
    .pxEnemy{width:32px; height:32px}
    .pxMini{width:32px; height:32px; border-radius:12px}
    .itemIcon{width:32px; height:32px; border-radius:12px}
    .vIcon{display:flex; align-items:center; gap:10px; min-width:0}
    .vIcon span{min-width:0; overflow:hidden; text-overflow:ellipsis; white-space:nowrap}
    .slot .v.vIcon{white-space:nowrap; overflow:hidden; text-overflow:ellipsis}
    .pxSprite.rar-common{border-color: rgba(148,163,184,.35)}
    .pxSprite.rar-uncommon{border-color: rgba(34,197,94,.35)}
    .pxSprite.rar-rare{border-color: rgba(125,211,252,.35)}
    .pxSprite.rar-epic{border-color: rgba(167,139,250,.38)}
    .pxSprite.rar-legendary{border-color: rgba(245,158,11,.45)}
    .pxSprite.rar-unique{border-color: rgba(239,68,68,.45)}
    .iname{
  font-weight:950;
  font-size:13px;
  display:grid;
  grid-template-columns: auto 1fr auto auto;
  gap:6px 8px;
  align-items:center;
  min-width:0;
}
.inameName{
  min-width:0;
  white-space:nowrap;
  overflow:hidden;
  text-overflow:ellipsis;
}
@media (max-width: 640px){
  .iname{grid-template-columns:auto 1fr; }
  .iname .pill{justify-self:start;}
}
    .idesc{color:var(--muted); font-size:11px; margin-top:4px; white-space:pre-line;}
    .item .actions{
  display:flex;
  flex-direction:column;
  gap:6px;
  align-items:stretch;
  justify-content:flex-start;
  min-width:92px;
}
.item .actions button{width:100%; justify-content:center;}
@media (max-width: 560px){
  .item{grid-template-columns:1fr;}
  .item .actions{flex-direction:row; justify-content:flex-end; min-width:0;}
  .item .actions button{width:auto;}
}
    /* Rarity label: smaller, pill style */
    .rar{font-weight:950; font-size:10px; line-height:1; display:inline-flex; align-items:center; padding:2px 8px; border-radius:999px; border:1px solid #27364f; background: rgba(11,26,45,.55);}
    .rar.common{color:#cbd5e1}
    .rar.uncommon{color:#86efac}
    .rar.rare{color:#93c5fd}
    .rar.epic{color:#c4b5fd}
    .rar.legendary{color:#fbbf24; text-shadow: 0 0 14px rgba(251,191,36,.18)}
    .rar.unique{color:#fb7185; text-shadow: 0 0 14px rgba(251,113,133,.18)}

    .pill{
      font-size:10px; font-weight:950;
      padding:2px 8px; border-radius:999px;
      border:1px solid #27364f;
      background: rgba(11,26,45,.6);
      color: var(--muted);
      font-variant-numeric: tabular-nums;
    }
    .equipSlots{display:flex; flex-direction:column; gap:5px;}
    .equipSlots .slot{padding:6px;}
    .equipSlots .vIcon{align-items:flex-start;}
    .equipSlots .vIcon span{flex:1; min-width:0; white-space:normal; overflow:visible; text-overflow:clip; overflow-wrap:anywhere;}
    .equipSlots .slot .v{white-space:normal; overflow:visible; text-overflow:clip; line-height:1.25;}
.slotHead{display:flex; align-items:center; justify-content:space-between; gap:8px; flex-wrap:wrap;}
    .slotHead .k{margin:0;}
    .slotHead .pill{white-space:nowrap;}

    .slot{
      background: rgba(9,14,22,.55);
      border:1px solid var(--line);
      border-radius:14px;
      padding:6px;
    }
    .slot .k{font-size:11px; color:var(--muted)}
    .slot .v{margin-top:2px; font-weight:950; font-size:12px; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;}
    .footerNote{color:var(--muted); font-size:11px; margin-top:10px; line-height:1.4;}
    .warnBox{
      background: rgba(24,16,6,.45);
      border:1px solid rgba(245,158,11,.25);
      border-radius:14px;
      padding:10px;
      color: var(--muted);
      font-size:11px;
      line-height:1.35;
    }
  
    .goodTxt{color:#86efac}
    .badTxt{color:#fda4af}
    .mutedTxt{color:var(--muted)}.cmpBox{white-space:pre-line; color:var(--muted); font-size:11px; line-height:1.35}
    .cmpTitleLine{display:flex; gap:8px; flex-wrap:wrap; align-items:center; margin-top:6px}
    .miniHr{height:1px; background:var(--line); margin:8px 0;}
    .modalOverlay{
      position:fixed; inset:0; background: rgba(0,0,0,.55);
      display:none; align-items:center; justify-content:center;
      padding:16px; z-index:100;
    }
    .modal{
      width:min(880px, 96vw);
      background: linear-gradient(180deg, rgba(15,22,36,.98), rgba(12,18,32,.96));
      border:1px solid var(--line);
      border-radius:16px;
      box-shadow: var(--shadow); position:relative;
      overflow:hidden;
    }
    .modal h3{
      margin:0; padding:12px 14px;
      font-size:13px; letter-spacing:.3px;
      border-bottom:1px solid var(--line);
      display:flex; justify-content:space-between; align-items:center;
    }
    .modal .content{padding:14px; color:var(--muted); font-size:12px; line-height:1.45}
    .kbd{display:inline-flex; align-items:center; padding:2px 8px; border-radius:10px; border:1px solid #223049; background: rgba(11,26,45,.5); color:var(--text); font-weight:950; font-size:11px}

  
    /* Scrollbars */
    *{scrollbar-color:#2a3a55 rgba(0,0,0,0); scrollbar-width:thin}
    *::-webkit-scrollbar{width:10px; height:10px}
    *::-webkit-scrollbar-thumb{background: linear-gradient(180deg, rgba(125,211,252,.25), rgba(251,191,36,.18)); border:1px solid rgba(42,75,106,.55); border-radius:999px}
    *::-webkit-scrollbar-track{background: rgba(0,0,0,0)}

    /* Bars */
    #expBar{background: linear-gradient(90deg, rgba(125,211,252,.85), rgba(167,139,250,.85))}
    #hpBar{background: linear-gradient(90deg, rgba(34,197,94,.85), rgba(125,211,252,.85))}
    #enemyHpBar{background: linear-gradient(90deg, rgba(251,191,36,.85), rgba(251,113,133,.75))}
    .fill{transition: width .18s ease-out}


    /* v13: battle stage (dot sprites + animation) */
    /* v24: battle viewport height ~1/2 (numbers widening etc. shouldn't shift layout) */
    .battleViewport{position:relative; width:100%; aspect-ratio: 32 / 8; border-radius:16px; overflow:hidden;
      border:1px solid rgba(31,42,58,.95);
      background: linear-gradient(135deg, rgba(125,211,252,.10), rgba(34,197,94,.06), rgba(245,158,11,.08));
      box-shadow: 0 10px 28px rgba(0,0,0,.35);
    }
    .battleViewport .battleStage{position:absolute; inset:0; margin:0; border:none; border-radius:0; padding:10px 12px;}
    @media (max-width: 520px){ .battleViewport .battleStage{padding:8px 10px;} }

    /* v64: 調伏演出を廃し、記のみを表示（戦闘アニメーション無し） */
    .battleViewport.logOnly{ aspect-ratio:auto; height: clamp(230px, 26vh, 360px); }
    .battleViewport.logOnly .battleLog{
      position:absolute;
      left:10px; right:10px; top:10px; bottom:10px;
      height:auto !important;
      max-height:none !important;
      z-index:1;
      background: rgba(7,10,16,.62);
    }
    .battleViewport.logOnly #battleStage{ display:none !important; }

    /* Death UI remains on top of the log */

    /* Death UI: show revive button on top of battle animation */
    .deathOverlay{
      position:absolute; inset:0;
      z-index:30;
      display:none;
      align-items:center;
      justify-content:center;
      padding:14px;
      background: rgba(0,0,0,.55);
      backdrop-filter: blur(2px);
    }
    .deathPanel{
      width:min(420px, 92%);
      background: linear-gradient(180deg, rgba(15,22,36,.98), rgba(12,18,32,.94));
      border:1px solid rgba(42,75,106,.70);
      border-radius:18px;
      box-shadow: var(--shadow);
      padding:14px 14px 12px;
      text-align:center;
    }
    .deathTitle{
      font-weight:950;
      letter-spacing:.5px;
      font-size:14px;
      margin-bottom:8px;
    }
    .deathPanel #deathNote{
      display:block;
      margin:0 0 10px;
    }
    .deathPanel button{
      padding:10px 16px;
      border-radius:14px;
      font-weight:950;
      font-size:13px;
    }
    .deathHint{
      margin-top:10px;
      color:var(--muted);
      font-size:11px;
      line-height:1.35;
    }


    /* v27: keep stage sprites crisp (integer scaling) + make enemy ~2x hero */
    :root{ --stageSize:64px; }
    @media (max-width: 520px){ :root{ --stageSize:48px; } }
    .pxStage{width:var(--stageSize); height:var(--stageSize); border-radius:16px; box-shadow: 0 8px 18px rgba(0,0,0,.35)}
    .battleStage .actor.enemy .pxStage{width:calc(var(--stageSize) * 2); height:calc(var(--stageSize) * 2); border-radius:18px}
    /* 魔印は題にも表示（調伏映像は上部に移動） */
    .enemyTitle .pxEnemy{display:block}

    .battleStage{position:relative; display:flex; justify-content:space-between; align-items:flex-end; gap:14px;
      padding:10px 12px; margin-top:10px;
      border:1px solid rgba(31,42,58,.95);
      border-radius:16px;
      background: linear-gradient(135deg, rgba(125,211,252,.10), rgba(34,197,94,.06), rgba(245,158,11,.08));
      overflow:hidden;
    }
    .battleStage:before{content:""; position:absolute; inset:-2px;
      background:
        radial-gradient(200px 140px at 20% 30%, rgba(125,211,252,.22), transparent 60%),
        radial-gradient(220px 160px at 80% 60%, rgba(167,139,250,.20), transparent 62%),
        radial-gradient(260px 200px at 50% 110%, rgba(34,197,94,.12), transparent 60%);
      opacity:.7; pointer-events:none;
    }
    .battleStage .actor{position:relative; z-index:1; display:flex; align-items:flex-end}
    .battleStage .actor.dead{filter: grayscale(.85) brightness(.72); opacity:.8}

    .battleStage.running .actor.hero{animation: heroIdle 1.35s ease-in-out infinite}
    .battleStage.running .actor.enemy{animation: enemyIdle 1.55s ease-in-out infinite}

    .battleStage .actor.atk{animation: atkLunge .22s ease-out 1}
    .battleStage .actor.hit{animation: hitShake .22s ease-out 1; filter: brightness(1.25) saturate(1.25)}

    @keyframes heroIdle{0%,100%{transform:translateY(0)}50%{transform:translateY(-2px)}}
    @keyframes enemyIdle{0%,100%{transform:translateY(0)}50%{transform:translateY(-1px)}}
    @keyframes atkLunge{0%{transform:translate(0,0) scale(1)}55%{transform:translate(10px,-2px) scale(1.03)}100%{transform:translate(0,0) scale(1)}}
    @keyframes hitShake{0%{transform:translate(0,0)}25%{transform:translate(-2px,0)}55%{transform:translate(2px,0)}100%{transform:translate(0,0)}}

    .fxLayer{position:absolute; inset:0; z-index:2; pointer-events:none}
    /* v14: pixel FX (slash / spark / crit) */
    canvas.fxSprite{position:absolute; width:56px; height:56px; image-rendering: pixelated;
      border:none; border-radius:0; background: transparent; box-shadow:none;
      transform: translate(-50%,-50%);
      filter: drop-shadow(0 10px 14px rgba(0,0,0,.35));
      opacity:0;
      will-change: transform, opacity;
    }
    canvas.fxSlash{mix-blend-mode:screen; animation: fxSlash .24s ease-out forwards}
    canvas.fxClaw{mix-blend-mode:screen; animation: fxClaw .24s ease-out forwards}
    canvas.fxSpark{mix-blend-mode:screen; animation: fxSpark .22s ease-out forwards}
    canvas.fxCrit{mix-blend-mode:screen; animation: fxCrit .34s ease-out forwards}

    @keyframes fxSlash{
      0%{opacity:0; transform:translate(-50%,-50%) scale(.70) rotate(-22deg)}
      35%{opacity:1}
      100%{opacity:0; transform:translate(-50%,-50%) scale(1.18) rotate(12deg)}
    }
    @keyframes fxClaw{
      0%{opacity:0; transform:translate(-50%,-50%) scale(.72) rotate(18deg)}
      35%{opacity:1}
      100%{opacity:0; transform:translate(-50%,-50%) scale(1.16) rotate(-10deg)}
    }
    @keyframes fxSpark{
      0%{opacity:0; transform:translate(-50%,-50%) scale(.45) rotate(0deg)}
      25%{opacity:1; transform:translate(-50%,-50%) scale(1.08) rotate(0deg)}
      100%{opacity:0; transform:translate(-50%,-50%) scale(1.35) rotate(0deg)}
    }
    @keyframes fxCrit{
      0%{opacity:0; transform:translate(-50%,-50%) scale(.55) rotate(0deg)}
      20%{opacity:1; transform:translate(-50%,-50%) scale(1.05) rotate(6deg)}
      100%{opacity:0; transform:translate(-50%,-50%) scale(1.75) rotate(22deg)}
    }
    .floatDmg{position:absolute; font-weight:950; font-size:13px;
      transform: translate(-50%,-50%);
      text-shadow: 0 2px 0 rgba(0,0,0,.45), 0 0 12px rgba(0,0,0,.35);
      animation: floatUp .65s ease-out forwards;
      white-space:nowrap;
    }
    .floatDmg.crit{font-size:15px; filter: drop-shadow(0 0 10px rgba(245,158,11,.35))}
    

    @keyframes floatUp{0%{opacity:0; transform:translate(-50%,-30%)}15%{opacity:1}100%{opacity:0; transform:translate(-50%,-120%)}}

    /* v30: bombastic battle FX (camera / fullscreen canvas / flash) */
    .battleViewport .battleStage{
      --camX: 0px; --camY: 0px; --camZ: 1; --dash: 120px;
      transform: translate3d(var(--camX), var(--camY), 0) scale(var(--camZ));
      transform-origin: 50% 70%;
      will-change: transform;
    }
    .battleViewport .battleStage{display:block; margin:0;}
    .battleViewport .battleStage .actor{position:absolute; bottom:10px; z-index:2; display:flex; align-items:flex-end}
    .battleViewport .battleStage .actor.hero{left:28%;}
    .battleViewport .battleStage .actor.enemy{right:24%;}
    @media (max-width: 520px){
      .battleViewport .battleStage .actor.hero{left:24%;}
      .battleViewport .battleStage .actor.enemy{right:20%;}
    }

    .battleFxFull{position:absolute; inset:0; width:100%; height:100%; z-index:3; pointer-events:none}
    .battleFlash{position:absolute; inset:-10%; z-index:5; pointer-events:none; opacity:0;
      background:
        radial-gradient(280px 160px at 50% 60%, hsla(var(--flashHue,190), 100%, 70%, .70), rgba(255,255,255,0) 65%),
        radial-gradient(520px 260px at 50% 60%, hsla(calc(var(--flashHue,190) + 40), 100%, 70%, .22), rgba(255,255,255,0) 70%);
      mix-blend-mode: screen;
    }
    .battleFlash.on{animation: battleFlash .20s ease-out forwards}
    @keyframes battleFlash{0%{opacity:0}18%{opacity:1}100%{opacity:0}}

    .fxLayer{z-index:4}
    .battleStage.hitstop .actor{animation-play-state:paused !important}
    .battleStage.noAnim .actor{animation:none !important; transition:none !important;}
    .battleStage.noAnim .battleFxFull{display:none !important;}
    .battleStage.noAnim .battleFlash{display:none !important;}
    .battleStage.noAnim canvas.fxSprite{display:none !important;}

    /* stronger dash / hit */
    .battleStage .actor.hero.atk{animation: heroDash .30s cubic-bezier(.12,.88,.18,1) 1}
    .battleStage .actor.enemy.atk{animation: enemyDash .30s cubic-bezier(.12,.88,.18,1) 1}
    @keyframes heroDash{0%{transform:translate3d(0,0,0) scale(1)}35%{transform:translate3d(var(--dash),-7px,0) scale(1.07)}100%{transform:translate3d(0,0,0) scale(1)}}
    @keyframes enemyDash{0%{transform:translate3d(0,0,0) scale(1)}35%{transform:translate3d(calc(var(--dash) * -1),-5px,0) scale(1.04)}100%{transform:translate3d(0,0,0) scale(1)}}

    .battleStage .actor.hit{animation: hitShake2 .28s ease-out 1; filter: brightness(1.15) saturate(1.15)}
    @keyframes hitShake2{
      0%{transform:translate3d(0,0,0)}
      18%{transform:translate3d(-6px,0,0) rotate(-1deg)}
      42%{transform:translate3d(7px,-2px,0) rotate(1deg)}
      70%{transform:translate3d(-4px,1px,0) rotate(-.5deg)}
      100%{transform:translate3d(0,0,0)}
    }

    /* make small FX sprites & numbers read stronger */
    canvas.fxSprite{width:84px; height:84px; filter: drop-shadow(0 10px 14px rgba(0,0,0,.38));}
    canvas.fxCrit{animation: fxCrit .42s ease-out forwards}
    .floatDmg{font-size:14px}
    .floatDmg.crit{font-size:18px}

    /* v13: 余白を少し詰める */

    .row{gap:8px}
    .enemybox{padding:10px}

    /* v26: 頭書の操作群を簡略化 */
    header .wrap{padding:8px 10px 10px;}
    header .brand b{font-size:15px; letter-spacing:.6px}
    header .controls{gap:6px}
    header .controls button,
    header .controls select{
      padding:8px 10px;
      border-radius:10px;
      font-size:11px;
      box-shadow:none;
    }
    header .controls button.small{padding:5px 7px}
    header .controls .tag{font-size:10px; padding:2px 6px}
    header .locBadge{padding:4px 8px; font-size:11px}

    /* v33: 頭書は階層/部屋を表示せず、位/経験/金だけを簡略表示 */
    header .topbar{align-items:flex-start}
    header .locPanel{display:flex; flex-direction:column; align-items:flex-end; gap:4px; min-width:160px}
    header .locBadge{padding:4px 8px; font-size:10px}
    header .locBadge b{min-width:unset; text-align:right; font-variant-numeric: tabular-nums}
    header .locBadge b.statLine{display:flex; gap:10px; flex-wrap:nowrap; justify-content:flex-end; align-items:center}
    header .locBadge b.statLine span{white-space:nowrap; display:inline-block; text-align:right; overflow:hidden; text-overflow:ellipsis; max-width: 22ch}
    header #lvExp{min-width:6ch}
    header #expText{min-width:16ch}
    header #goldText{min-width:10ch}
    @media (max-width: 520px){ header #expText{min-width:14ch} header #goldText{min-width:9ch} }
    header .bar.headerBar{height:6px; width:160px; max-width:40vw}
    @media (max-width: 520px){ header .locPanel{min-width:unset} header .bar.headerBar{width:140px} }

    /* v35: 行者枠に功徳相を内包 */
    .heroCombat{margin-top:8px}
    .atkDefGrid.compact{gap:8px; margin-top:2px}
    .atkDefGrid.compact .k2{font-size:10px}
    .atkDefGrid.compact .v2{font-size:15px; line-height:1.05}
    .sub.combatSub{margin-top:4px; font-size:11px; opacity:.95}
    @media (max-width: 520px){
      .atkDefGrid.compact .v2{font-size:14px}
      .sub.combatSub{font-size:10px}
    }

    /* v26: 行者枠内の位/行を小さく */
    .sub.subTiny{font-size:10px; margin-top:2px}
    .bar.barSlim{height:8px}



    /* v40: 画面全体を縦方向に少し圧縮（余白を削って巻取量を減らす） */
    header .wrap{padding:6px 10px 6px;}
    .wrap{padding:6px 10px 8px;}
    .grid{gap:8px; margin-top:8px;}
    .row{gap:8px;}
    .card h2{padding:10px 12px;}
    .card .body{padding:8px 10px;}

    button, select{padding:6px 9px; border-radius:11px;}
    button.small{padding:5px 8px;}
    input[type="text"]{padding:6px 9px;}

    .stat{padding:8px 10px;}
    .enemybox{padding:10px;}
    .bigStat{padding:8px;}
    .heroCombat{margin-top:6px;}

    .hr{margin:6px 0;}

    .log{height:205px; padding:8px;}
    .list{max-height:520px;}

    .battleViewport .battleStage{padding:8px 10px;}
    @media (max-width: 520px){ .battleViewport .battleStage{padding:7px 8px;} }
    .battleStage{padding:8px 10px; margin-top:8px;}

    body{line-height:1.20;}
    /* v60: 行者情報配置（名前+位/Exp同列 / 気は標右に数値 / 残り1行） */
    .heroHeader{display:flex; align-items:center; gap:10px;}
    .heroHeadText{min-width:0; flex:1 1 auto;}

    .heroNameRow{display:flex; align-items:center; gap:10px; min-width:0;}
    .heroName{font-weight:1000; font-size:14px; letter-spacing:.2px; white-space:nowrap; overflow:hidden; text-overflow:ellipsis; min-width:0;}
    .heroNameSide{display:flex; align-items:center; gap:10px; flex:0 0 auto; font-size:11px; color:var(--text); opacity:.82; font-variant-numeric: tabular-nums; white-space:nowrap;}
    .heroNameSide span{white-space:nowrap;}

    .heroExpBar{margin-top:5px;}

    .heroHpBlock{margin-top:8px;}
    .heroHpBlock .hpRow{display:flex; justify-content:space-between; align-items:center; font-variant-numeric: tabular-nums;}
    .heroHpBlock .hpLabel{font-weight:950; font-size:12px; color:var(--muted); letter-spacing:.2px;}
    .heroHpBlock .hpVal{font-weight:1000; font-size:12px; color:var(--text);}

    .heroMetaOneLine{
      margin-top:8px;
      display:flex;
      gap:8px;
      row-gap:6px;
      flex-wrap:wrap;
      align-items:center;
      overflow:visible;
      padding-bottom:0;
      font-size:10.5px;
      color:var(--text); opacity:.88;
      white-space:normal;
      font-variant-numeric: tabular-nums;
    }
    .heroMetaOneLine span{
      flex:0 0 auto;
      white-space:nowrap;
      padding:2px 6px;
      border:1px solid var(--line);
      border-radius:999px;
      background: linear-gradient(180deg, rgba(125,211,252,.06), rgba(0,0,0,0));
    }
    .heroMetaOneLine #luckText{flex:0 0 auto; white-space:nowrap; overflow:hidden; text-overflow:ellipsis; line-height:1.1;}
    .heroMetaOneLine b{color:inherit; font-weight:1000;}

    /* v61: 重要な数値を太字（字大はそのまま） */
    #lvExp, #expText, #hpText, #goldText,
    #karmaText, #satoriText,
    #critText, #dpsText, #spdText, #luckText,
    #enemyHpText, #enemyStatsText,
    #upgText, #upgCostText, #gupgText, #gupgCostText,
    #invCount{font-weight:1000;}

    .heroMetaOneLine::-webkit-scrollbar{height:6px;}
    .heroMetaOneLine::-webkit-scrollbar-thumb{background:rgba(154,168,183,.25); border-radius:999px;}
    .heroMetaOneLine::-webkit-scrollbar-track{background:rgba(0,0,0,.15); border-radius:999px;}
    @media (max-width: 520px){ .heroMetaOneLine{font-size:9.8px; gap:8px;} }

    /* v41: 法具座をさらに縦圧縮 */
    .equipSlots{gap:4px;}
    .equipSlots .slot{padding:4px;}
    .equipSlots .slotHead{gap:6px;}
    .equipSlots .slot .v{margin-top:1px; line-height:1.15;}

    /* v46: 六印の欠片付与最大8 / 自動加持の縁60過大評価抑制 */
    .equipSlots .eqPerf{
      margin-top:2px;
      font-size:10px;
      line-height:1.15;
      color:var(--muted);
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
      font-variant-numeric: tabular-nums;
    }
    @media (max-width: 520px){ .equipSlots .eqPerf{font-size:9.5px;} }



/* ---- 密教拡張：曼荼羅 / 真言 / 業・悟り ---- */
body:before{
  content:"";
  position:fixed; inset:-25vmax;
  background:
    radial-gradient(circle at 20% 10%, rgba(245,158,11,.10), rgba(0,0,0,0) 45%),
    radial-gradient(circle at 80% 35%, rgba(167,139,250,.10), rgba(0,0,0,0) 55%),
    radial-gradient(circle at 40% 90%, rgba(125,211,252,.09), rgba(0,0,0,0) 50%),
    repeating-conic-gradient(from 0deg, rgba(255,255,255,.03) 0 7deg, rgba(0,0,0,0) 7deg 14deg);
  filter: blur(0.5px);
  opacity: .55;
  pointer-events:none;
  z-index:-1;
  animation: mandalaSpin 140s linear infinite;
}
@keyframes mandalaSpin{ from{transform:rotate(0deg)} to{transform:rotate(360deg)} }

.battleViewport:before{
  content:"";
  position:absolute; inset:-30%;
  background:
    radial-gradient(circle at 50% 55%, rgba(255,255,255,.06), rgba(0,0,0,0) 45%),
    repeating-conic-gradient(from 0deg, rgba(245,158,11,.07) 0 8deg, rgba(0,0,0,0) 8deg 16deg);
  opacity:.55;
  transform-origin:center;
  pointer-events:none;
  animation: mandalaSpin 70s linear infinite;
}
.battleStage{ position:relative; }

.mantraPulse{
  position:absolute; left:50%; top:50%; transform:translate(-50%,-50%);
  width:min(520px, 120%); aspect-ratio:1/1;
  border-radius:999px;
  border:1px solid rgba(245,158,11,.45);
  box-shadow: 0 0 0 0 rgba(245,158,11,.30), 0 0 60px rgba(167,139,250,.15);
  opacity:0;
  animation: mantraPulse 1.05s ease-out forwards;
  pointer-events:none;
}
@keyframes mantraPulse{
  0%{opacity:0; transform:translate(-50%,-50%) scale(.72)}
  15%{opacity:.85}
  100%{opacity:0; transform:translate(-50%,-50%) scale(1.12)}
}
.seedGlyph{
  position:absolute; left:50%; top:44%; transform:translate(-50%,-50%);
  font-weight:950;
  letter-spacing:.08em;
  text-shadow: 0 10px 30px rgba(0,0,0,.55);
  opacity:0;
  animation: seedGlyph 1.05s ease-out forwards;
  pointer-events:none;
  user-select:none;
}
@keyframes seedGlyph{
  0%{opacity:0; transform:translate(-50%,-50%) scale(.92)}
  18%{opacity:.95}
  100%{opacity:0; transform:translate(-50%,-50%) scale(1.06)}
}

.pathGrid{display:grid; grid-template-columns:repeat(4, minmax(0,1fr)); gap:8px;}
@media (max-width: 520px){ .pathGrid{grid-template-columns:repeat(2, minmax(0,1fr));} }

#karmaText, #satoriText{font-variant-numeric: tabular-nums;}
#karmaText{color: rgba(251,113,133,.95);}
#satoriText{color: rgba(245,158,11,.95);}

#btnChant.ready{ box-shadow: 0 0 0 1px rgba(245,158,11,.25), 0 0 18px rgba(245,158,11,.18); }
#btnChant.cooldown{ opacity:.65; }

.codexGrid{display:grid; grid-template-columns:repeat(2, minmax(0,1fr)); gap:10px; margin-top:10px;}
@media (max-width: 720px){ .codexGrid{grid-template-columns:1fr;} }
.codexCard{background: rgba(9,14,22,.45); border:1px solid var(--line); border-radius:14px; padding:10px;}
.codexCard .k{font-size:11px; color:var(--muted)}
.codexCard .v{margin-top:4px; font-weight:950; font-size:12px; color:var(--text)}
.codexCard .p{margin-top:6px; font-size:11px; color:var(--muted); white-space:pre-line; line-height:1.45}

/* --- 曼荼羅帳：文庫UI（読みやすさ） --- */
.codexCtrlRow{display:flex; gap:8px; flex-wrap:wrap; align-items:center; margin-top:8px;}
.codexCtrlRow input[type="search"]{
  flex:1; min-width:160px;
  padding:8px 10px;
  border-radius:12px;
  border:1px solid var(--line);
  background: rgba(255,255,255,.03);
  color: var(--text);
  outline: none;
}
.codexCtrlRow select{
  padding:8px 10px;
  border-radius:12px;
  border:1px solid var(--line);
  background: rgba(255,255,255,.03);
  color: var(--text);
  outline: none;
}
.codexCtrlRow .count{margin-left:auto; font-size:11px; color:var(--muted)}
@media (max-width: 720px){
  .codexCtrlRow .count{margin-left:0}
}
.libList{
  margin-top:10px;
  border:1px solid var(--line);
  border-radius:14px;
  overflow:auto;
  max-height:54vh;
  background: rgba(9,14,22,.35);
}
.libDay{
  padding:8px 10px;
  font-size:11px;
  color: var(--muted);
  background: rgba(255,255,255,.02);
  border-top:1px solid rgba(255,255,255,.06);
}
.libItem{border-top:1px solid rgba(255,255,255,.06);}
.libItem:first-child{border-top:0}
.libHead{
  width:100%;
  text-align:left;
  background: transparent;
  border:0;
  padding:10px 10px;
  display:grid;
  grid-template-columns:auto 1fr auto;
  gap:10px;
  align-items:center;
  cursor:pointer;
}
.libHead:hover{background: rgba(125,211,252,.06);}
.libTitle{
  font-weight:950;
  font-size:12px;
  white-space:nowrap;
  overflow:hidden;
  text-overflow:ellipsis;
}
.libMeta{
  font-size:11px;
  color: var(--muted);
  white-space:nowrap;
}
@media (max-width: 720px){
  .libHead{grid-template-columns:auto 1fr; grid-template-rows:auto auto; gap:6px}
  .libMeta{grid-column:2; grid-row:2; justify-self:start}
}
.libBody{
  padding:0 10px 12px 10px;
  color: var(--muted);
  font-size:12px;
  line-height:1.55;
}
.libBody .libFoot{margin-top:8px; opacity:.95}
.libActions{display:flex; justify-content:flex-end; margin-top:8px;}



/* --- 密教演出：曼荼羅（CSS） --- */
.battleStage::before{
  content:"";
  position:absolute;
  inset:-90px;
  border-radius:999px;
  background:
    radial-gradient(circle at 50% 50%, rgba(245,158,11,.10) 0%, rgba(245,158,11,0) 42%),
    radial-gradient(circle at 50% 50%, rgba(167,139,250,.10) 0%, rgba(167,139,250,0) 58%),
    repeating-conic-gradient(from 0deg,
      rgba(167,139,250,.22) 0 10deg,
      rgba(56,189,248,.12) 10deg 20deg,
      rgba(245,158,11,.16) 20deg 30deg,
      rgba(167,139,250,.18) 30deg 40deg
    );
  mask: radial-gradient(circle at 50% 50%, rgba(0,0,0,.0) 0 22%, rgba(0,0,0,1) 30%, rgba(0,0,0,1) 68%, rgba(0,0,0,.0) 78%);
  opacity:.16;
  pointer-events:none;
  z-index:0;
  animation: mandalaSpin 120s linear infinite;
}
.battleStage .actor,
.battleStage #battleFx,
.battleStage #battleFxFull,
.battleStage #battleFlash,
.battleStage canvas{ position:relative; z-index:1; }

html[data-realm="hell"] .battleStage::before{ opacity:.17; filter:saturate(1.15) hue-rotate(-10deg); }
html[data-realm="hungry"] .battleStage::before{ opacity:.16; filter:saturate(1.05) hue-rotate(8deg); }
html[data-realm="animal"] .battleStage::before{ opacity:.15; filter:saturate(0.95) hue-rotate(20deg); }
html[data-realm="asura"] .battleStage::before{ opacity:.18; filter:saturate(1.25) hue-rotate(-18deg); }
html[data-realm="human"] .battleStage::before{ opacity:.14; filter:saturate(0.90) hue-rotate(0deg); }
html[data-realm="deva"] .battleStage::before{ opacity:.16; filter:saturate(1.05) hue-rotate(30deg); }



  /* --- Realm ambience (particles + tint) --- */
  :root{ --realmHue: 210; --realmHue2: 180; }
  body:after{
    content:"";
    position:fixed; inset:-18vh -18vw;
    background:
      radial-gradient(900px 620px at 18% 12%, hsla(var(--realmHue), 70%, 45%, 0.14) 0%, transparent 62%),
      radial-gradient(980px 680px at 82% 28%, hsla(var(--realmHue2), 70%, 40%, 0.10) 0%, transparent 66%);
    mix-blend-mode: screen;
    pointer-events:none;
    z-index:-1;
  }
  #auraCanvas{
    position:fixed; inset:0;
    width:100vw; height:100vh;
    pointer-events:none;
    z-index:0;
    opacity:0.82;
  }
  header, main, .modal{ position:relative; z-index:1; }

  /* 二曼荼羅の“決定づけ”演出：背景文様差分 */
  html[data-mandala="kongo"] .battleStage::after{
    content:"";
    position:absolute; inset:-10px;
    background:
      repeating-conic-gradient(from 10deg, rgba(255,255,255,0.10) 0 7deg, rgba(0,0,0,0) 7deg 15deg),
      radial-gradient(600px 420px at 50% 40%, rgba(255,255,255,0.10), transparent 60%);
    opacity:0.10;
    mix-blend-mode: overlay;
    pointer-events:none;
  }
  html[data-mandala="taizo"] .battleStage::after{
    content:"";
    position:absolute; inset:-10px;
    background:
      repeating-radial-gradient(circle at 50% 50%, rgba(255,255,255,0.09) 0 2px, rgba(0,0,0,0) 2px 10px),
      radial-gradient(620px 440px at 50% 45%, rgba(255,255,255,0.08), transparent 65%);
    opacity:0.11;
    mix-blend-mode: overlay;
    pointer-events:none;
  }


    /* 法具庫下：行持・印契（永続）を整列 */
    .invBottomLabel{
      color:var(--muted);
      font-size:11px;
      letter-spacing:.12em;
      text-transform:none;
      margin-top:2px;
      opacity:.95;
    }
    /* split を法具庫用に最適化（中間幅で窮屈にならない） */
    .invSubGrid{ grid-template-columns: 1fr; }
    @media (min-width: 920px){ .invSubGrid{ grid-template-columns: 1fr 1fr; } }
    .invSubGrid .stat{ margin-top:0 !important; }
    .invSubGrid .warnBox{ margin-top:8px; }

    /* 法具庫下：横長の枠を縦積み */
    .invWideStack{
      display:flex;
      flex-direction:column;
      gap:10px;
    }
    .invWideStack .stat{ margin-top:0 !important; }
    
    /* FINAL OVERRIDE: keep search text clear of icons even under compact padding rules */
    .searchWrap input[type="text"]{
      padding-left: 36px;
      padding-right: 40px;
    }
</style>
</head>
<body>
  <canvas id="auraCanvas" aria-hidden="true"></canvas>
<header>
  <div class="wrap">
    <div class="topbar">
      <div class="brand">
        <b>曼荼羅迷宮記 — 六印巡礼</b>
      </div>
      <div class="controls">
        <button id="btnExplore" class="accent">▶ 巡礼開始</button>
        <button id="btnPause" class="ghost">⏸ 休行</button>
        <label class="tag">迅行
          <select id="speedSel">
            <option value="1" selected>1倍</option>
            <option value="2">2倍</option>
            <option value="4">4倍</option>
            <option value="8">8倍</option>
<option value="64" disabled>MAX（六印 0/6）</option>
</select>
        </label>
        <label class="tag">自動
          <select id="autoSel">
            <option value="0">止</option>
            <option value="1" selected>顕</option>
          </select>
        </label>
        <button id="btnChant" class="accent">🕉 真言</button>
        <button id="btnCodex" class="ghost">🪷 曼荼羅帳</button>
<button id="btnSave" class="ghost">💾 記録</button>
        <button id="btnReset" class="ghost">🗑 輪廻</button>
      </div>
    </div>
  </div>
</header>

<main class="wrap">
  <div class="grid">

    <section class="card">
      <h2>修行 <span id="runInfo">—</span></h2>
      <div class="body">
        <div class="battleViewport logOnly" aria-label="調伏記">
<div class="log battleLog" id="log" aria-label="調伏記"></div>
                <div class="battleStage wide" id="battleStage" aria-label="調伏の点絵表示" hidden>
                  <div class="actor hero" id="heroActor">
                    <canvas id="heroStageSprite" class="pxSprite pxStage" width="64" height="64" aria-label="行者(調伏)"></canvas>
                  </div>
                  <div class="actor enemy" id="enemyActor">
                    <canvas id="enemyStageSprite" class="pxSprite pxStage" width="64" height="64" aria-label="魔(調伏)"></canvas>
                  </div>
                  
                  <canvas id="battleFxFull" class="battleFxFull" width="1" height="1" aria-hidden="true"></canvas>
                  <div id="battleFlash" class="battleFlash" aria-hidden="true"></div>
                  <div class="fxLayer" id="battleFx" aria-hidden="true"></div>
                </div>
          <div class="deathOverlay" id="deathOverlay" style="display:none;" aria-label="調伏不能式次第">
            <div class="deathPanel">
              <div class="deathTitle">調伏不能</div>
              <div class="footerNote" id="deathNote" style="display:none;"></div>
              <button id="btnRevive" class="bad">💀 復活</button>
</div>
          </div>
        </div>

        <div class="row">
          <div class="col">
            <div class="statgrid stack">

<div class="stat">
                <div class="k">行者の情報</div>
                <div class="hr"></div>

                <div class="heroHeader">
                  <canvas id="heroSprite" class="pxSprite pxHero" width="64" height="64" aria-label="行者"></canvas>
                  <div class="heroHeadText">
                    <div class="heroNameRow">
                      <div class="heroName" id="heroName">—</div>
                      <div class="heroNameSide">
                        <span id="lvExp">—</span>
                        <span id="expText">—</span>
                      </div>
                    </div>
                    <div class="bar barSlim heroExpBar"><div class="fill" id="expBar"></div></div>
                  </div>
                </div>

                <div class="heroHpBlock">
                  <div class="hpRow"><span class="hpLabel">命</span><span class="hpVal" id="hpText">—</span></div>
                  <div class="bar"><div class="fill" id="hpBar"></div></div>
                </div>

                <div class="heroMetaOneLine" aria-label="行者功徳相詳細">
                  <span id="goldText">—</span>
                  <span>断 <b id="atkVal">—</b></span>
                  <span>戒 <b id="defVal">—</b></span>
                  <span id="critText">—</span>
                  <span id="dpsText">—</span>
                  <span id="spdText">—</span>
                  <span id="luckText">—</span>
                  <span id="karmaText">—</span>
                  <span id="satoriText">—</span>
                </div>
              </div>
<div class="enemybox">
                <div class="enemyTitle">
                  <div class="enemyLeft">
                    <canvas id="enemySprite" class="pxSprite pxEnemy" width="64" height="64" aria-label="魔"></canvas>
                    <div class="enemyText">
                      <div class="enemyBiome"><span class="tag mini">六道 <b id="biomeText">—</b></span></div>
                      <div class="enemyname" id="enemyName">—</div>
                    </div>
                  </div>
                  <div class="enemyFlags">
                    <span class="tag" id="safeTag" style="display:none;"><b class="safe">安全</b> <span id="safeText">—</span></span>
                    <span class="tag" id="eliteTag" style="display:none;"><b class="elite">魔軍</b></span>
                    <span class="tag" id="bossTag" style="display:none;"><b class="boss">天魔</b></span>
                  </div>
                </div>
                <div style="margin-top:10px;">
                  <div class="k" style="color:var(--muted); font-size:11px;">魔命</div>
                  <div class="bar"><div class="fill" id="enemyHpBar"></div></div>
                  <div class="sub oneLine"><span id="enemyHpText">—</span><span id="enemyStatsText">—</span></div>
                </div>
              </div>

<div class="stat tight">
                    <div class="k">法具座</div>
                    <div class="equipSlots">
                      <div class="slot">
                        <div class="slotHead">
                          <div class="k">武器</div>
                          <button class="lockBtn" id="lockWeapon" title="自動加持を封印">🔓</button>
                          <span class="rar common" id="eqWeaponRar">—</span>
                          <span class="pill" id="eqWeapon位">—</span>
                        </div>
                        <div class="v vIcon"><canvas id="eqWeaponIcon" class="pxSprite pxMini" width="64" height="64" aria-label="武器"></canvas><span id="eqWeapon">—</span></div>
                        <div class="eqPerf" id="eqWeaponPerf">—</div>
                      </div>
                      <div class="slot">
                        <div class="slotHead">
                          <div class="k">防具</div>
                          <button class="lockBtn" id="lockArmor" title="自動加持を封印">🔓</button>
                          <span class="rar common" id="eqArmorRar">—</span>
                          <span class="pill" id="eqArmor位">—</span>
                        </div>
                        <div class="v vIcon"><canvas id="eqArmorIcon" class="pxSprite pxMini" width="64" height="64" aria-label="防具"></canvas><span id="eqArmor">—</span></div>
                        <div class="eqPerf" id="eqArmorPerf">—</div>
                      </div>
                      <div class="slot">
                        <div class="slotHead">
                          <div class="k">瓔珞</div>
                          <button class="lockBtn" id="lockAcc" title="自動加持を封印">🔓</button>
                          <span class="rar common" id="eqAccRar">—</span>
                          <span class="pill" id="eqAcc位">—</span>
                        </div>
                        <div class="v vIcon"><canvas id="eqAccIcon" class="pxSprite pxMini" width="64" height="64" aria-label="瓔珞"></canvas><span id="eqAcc">—</span></div>
                        <div class="eqPerf" id="eqAccPerf">—</div>
                      </div>
                    </div>
                  </div>
</div>



<div class="hr"></div>


          </div>
        </div>

      </div>
    </section>

    <section class="card">
      <h2>法具庫 <span id="invCount">—</span></h2>
      <div class="body">
        
        <div class="invTop">
          <div class="invTabsWrap">
            <div class="tabs" id="tabs">
              <button class="tabBtn active" data-tab="all">すべて</button>
              <button class="tabBtn" data-tab="weapon">武器</button>
              <button class="tabBtn" data-tab="armor">防具</button>
              <button class="tabBtn" data-tab="accessory">瓔珞</button>
            </div>
          </div>

          <div class="invTools">
            <div class="searchWrap" role="search">
              <span class="searchIcon" aria-hidden="true">🔍</span>
              <input id="search" type="text" placeholder="検索（例：法具名 / 凡品 / 防具 / 体力 / 降魔）" />
              <button id="btnClearSearch" class="iconBtn" type="button" title="検索を消す">×</button>
            </div>

            <select id="sortSel" title="並び替え">
              <option value="rar">宝格</option>
              <option value="ilv" selected>法具位</option>
              <option value="slot">座</option>
              <option value="power">強さ</option>
            </select>
<button id="btnSellAll" class="small bad">🧹 全布施</button>
          </div>
        </div>

        <div class="invFilters" aria-label="布施フィルタ">
          <label class="checkPill">
            <input type="checkbox" id="autoSellOn"> <span>自動布施</span>
          </label>

          <div class="filterGroup">
            <span class="fLabel">宝格上限</span>
            <select id="autoSellRarMax" title="指定宝格以下（凡品〜）を即布施">
              <option value="none">なし</option>
              <option value="common" selected>凡品のみ</option>
              <option value="uncommon">善品まで</option>
              <option value="rare">妙品まで</option>
              <option value="epic">秘宝まで</option>
              <option value="legendary">聖宝まで</option>
              <option value="unique">六印の欠片まで</option>
            </select>
          </div>

          <label class="checkPill" title="加持中より弱い加持を即布施（加持が空の座は売らない）">
            <input type="checkbox" id="autoSellUseEq"> <span>加持比</span>
          </label>

          <div class="filterGroup pct" title="加持比の閾値（%）">
            <span class="fLabel">&lt;</span>
            <input id="autoSellEqPct" type="number" min="1" max="100" step="1" value="90" />
            <span class="fLabel">%</span>
          </div>

          <label class="checkPill" title="作動中、六印の欠片は自動布施しません（最大宝格に六印の欠片を選んだ場合を除く）">
            <input type="checkbox" id="autoSellProtectUnique" checked> <span>六印の欠片保護</span>
          </label>
        </div>
<div class="list" id="invList"></div>
        <div class="hr"></div>
        <div class="invBottomLabel">行持・伽藍（功徳）</div>
        <div class="invWideStack" style="margin-top:8px;">
<div class="stat">
                  <div class="k">行持強化（功徳）</div>
                  <div class="sub" style="margin-top:6px; display:flex; gap:8px; align-items:center; flex-wrap:wrap;">
                    <span style="color:var(--muted); font-size:11px;">一括購入</span>
                    <select id="upgBulkSel">
                      <option value="1" selected>×1</option>
                      <option value="10">×10</option>
                      <option value="100">×100</option>
                      <option value="1000">×1000</option>
                      <option value="10000">×10000</option>
                    </select>
                  </div>
                  <div style="display:flex; gap:8px; flex-wrap:wrap; margin-top:8px;">
                    <button class="small" data-upg="str">精進 +1</button>
                    <button class="small" data-upg="vit">忍辱 +1</button>
                    <button class="small" data-upg="def">持戒 +1</button>
                    <button class="small" data-upg="luck">縁 +1</button>
                  </div>
                  <div class="sub" style="margin-top:8px;">
                    <span id="upgText">—</span>
                    <span id="upgCostText">—</span>
                  </div>
                </div>





        </div>
        <div class="hr"></div>
        <div class="stat" style="margin-top:10px;">
          <div class="k">記（上部）</div>
<div class="sub" style="margin-top:8px;">
            <span id="offlineNote">—</span>
            <button id="btnOpenChest" class="small" style="display:none;">🎁 未接続宝函を開く</button>
          </div>
        </div>

      </div>
    </section>

  </div>



<div class="modalOverlay" id="eventOverlay" role="dialog" aria-modal="true" aria-label="密教儀礼">
  <div class="modal">
    <h3><span id="eventTitle">—</span><button id="btnEventClose" class="ghost">×</button></h3>
    <div class="content">
      <div id="eventBody" style="white-space:pre-line;">—</div>
      <div class="miniHr"></div>
      <div id="eventChoices" style="display:flex; gap:8px; flex-wrap:wrap;"></div>
      <div class="footerNote" id="eventFoot">—</div>
    </div>
  </div>
</div>


<div class="modalOverlay" id="codexOverlay" role="dialog" aria-modal="true" aria-label="曼荼羅帳">
  <div class="modal">
    <h3><span>🪷 曼荼羅帳</span><button id="btnCodexClose" class="ghost">×</button></h3>
    <div class="content">
      <div id="codexBody">—</div>
    </div>
  </div>
</div>

</main>

<script>
(() => {
  "use strict";

  let S = null;

  // --------------------
  // Utils
  // --------------------
  const clamp = (v, a, b) => (Number.isFinite(v) ? Math.max(a, Math.min(b, v)) : a);
  const num = (v, fallback=0) => {
    const n = Number(v);
    return Number.isFinite(n) ? n : fallback;
  };
  const int0 = (v, fallback=0) => {
    const n = Math.floor(num(v, fallback));
    return Number.isFinite(n) ? n : fallback;
  };
  const safeDiv = (a,b,fallback=0) => {
    a = num(a, 0);
    b = num(b, 0);
    if (!Number.isFinite(a) || !Number.isFinite(b) || b===0) return fallback;
    const r = a/b;
    return Number.isFinite(r) ? r : fallback;
  };
  const rand = (a, b) => Math.random() * (b - a) + a;
  const randi = (a, b) => Math.floor(rand(a, b + 1));
  const choice = (arr) => arr[randi(0, arr.length - 1)];
  const now = () => Date.now();
  // Device hint: iOS Safari is much slower, so we auto-throttle some effects.
  const IS_IOS = (() => {
    try{
      const ua = navigator.userAgent || "";
      const isAppleTouch = (navigator.platform === "MacIntel" && navigator.maxTouchPoints > 1);
      return /iP(hone|ad|od)/.test(ua) || isAppleTouch;
    }catch(_){ return false; }
  })();


// --------------------
// Simulation speed + Log pace sync
//   - UI shows: 1× / 2× / ... / MAX
//   - "pace" is a normalized multiplier used by BOTH:
//       * simulation advance rate
//       * log pump rate (cards per second)
//   - This keeps logs and game progression in sync at every speed.
// --------------------
const SPEED_MAX_LABEL = 64;     // MAX label value (lighter than old 256)
const SPEED_ALLOWED = [1, 2, 4, 8, SPEED_MAX_LABEL];

const SPEED_SIM_BASE = 0.05;   // base internal sim speed at pace=1 (1×)
const SPEED_PACE_MAX  = 240;     // cap (prevents overload at high speeds)
// NOTE: user requested faster MAX; raised from 30->240

function speedPace(label){
  const sp = Number.isFinite(label) ? Number(label) : (S && S.run ? Number(S.run.speed) : 1);
  const s = (Number.isFinite(sp) && sp > 0) ? sp : 1;

  // Sync logs and simulation. MAX is capped so it won't overload the game.
  if (s >= SPEED_MAX_LABEL) return SPEED_PACE_MAX; // MAX (capped)
  return Math.min(s, SPEED_PACE_MAX);
}


function effectiveSimSpeed(label){
  const pace = speedPace(label);
  return clamp(pace * SPEED_SIM_BASE, 0.01, SPEED_PACE_MAX * SPEED_SIM_BASE);
}
  function effectiveSimSpeedScaled(label){
  const base = effectiveSimSpeed(label);
  try{
    if (IS_IOS && typeof S !== "undefined" && S && S.run){
      const k = Number(S.run._iosSpeedScale);
      if (Number.isFinite(k) && k > 0) return base * k;
    }
  }catch(_){}
  return base;
}

const pct = (x) => `${Math.round(x * 100)}%`;
  const safeUUID = () => {
    try { return crypto.randomUUID(); }
    catch { return "id-" + Math.random().toString(16).slice(2) + "-" + Date.now().toString(16); }
  };

  // Compact number formatting (keeps UI readable even when values explode)
  function fmt(n){
    if (!Number.isFinite(n)) return "∞";
    const sign = n < 0 ? "-" : "";
    const a = Math.abs(n);
    const UNITS = [
      { v: 1e21, s: "Z" },
      { v: 1e18, s: "E" },
      { v: 1e15, s: "Qa" },
      { v: 1e12, s: "T" },
      { v: 1e9,  s: "B" },
      { v: 1e6,  s: "M" },
      { v: 1e3,  s: "K" },
    ];
    for (const u of UNITS){
      if (a >= u.v){
        const x = a / u.v;
        const d = x >= 100 ? 0 : x >= 10 ? 1 : 2;
        return sign + x.toFixed(d) + u.s;
      }
    }
    return sign + Math.round(a).toLocaleString("ja-JP");
  }

  // --------------------
  // Content (Biomes / Mods / Items)
  // --------------------

const BIOMES = [
  { key:"hell",      name:"苦諦界（地獄道）", enemy:["瞋恚","慢","輪廻","業果・異熟","苦苦","煩熱","煩悩","業火"], boss:["業障","瞋恚随眠","因果の法","幻化"], mult:{hp:1.08, atk:1.10, def:1.02}, loot:{gold:1.12, xp:1.10} },
  { key:"hungry",    name:"集諦界（餓鬼道）", enemy:["渇愛","欲愛","貪欲","染愛","不浄貪","貪痴","欲貪蓋","執取"], boss:["欲取","見取","我語取","戒禁取"], mult:{hp:1.00, atk:1.06, def:0.98}, loot:{gold:1.22, xp:1.02} },
  { key:"animal",    name:"無明界（畜生道）", enemy:["無明","痴","妄想","邪見","散乱","愚痴","有身見","無明縁識"], boss:["根本無明","随眠","因果顛倒","幻化"], mult:{hp:1.04, atk:1.02, def:1.00}, loot:{gold:1.05, xp:1.05} },
  { key:"asura",     name:"瞋慢界（修羅道）", enemy:["闘諍","瞋恚","害","怨恨","憍","忿","増上慢","嫉"], boss:["闘諍随眠","瞋火","剛強我慢","幻化"], mult:{hp:1.06, atk:1.12, def:1.03}, loot:{gold:1.08, xp:1.14} },
  { key:"human",     name:"分別界（人間道）", enemy:["我執","執取","分別","貪欲","五蘊","死畏","疑","顛倒"], boss:["浄顛倒","常顛倒","我顛倒","楽顛倒"], mult:{hp:1.00, atk:1.00, def:1.00}, loot:{gold:1.00, xp:1.00} },
  { key:"deva",      name:"有頂界（天道）",   enemy:["放逸","憍","掉挙","無色界愛","有愛","天人五衰","有頂","無常"], boss:["有頂慢","色界愛","業果","幻化"], mult:{hp:1.10, atk:1.06, def:1.06}, loot:{gold:1.10, xp:1.24} },
];

const MON_MODS = [
  // 既存
  { key:"armored",     name:"装甲",   w:18, mult:{hp:1.05, atk:1.00, def:1.25} },
  { key:"frenzied",    name:"狂乱",   w:16, mult:{hp:1.00, atk:1.18, def:0.95} },
  { key:"titanic",     name:"巨躯",   w:12, mult:{hp:1.35, atk:1.00, def:1.00} },
  { key:"hexed",       name:"呪詛",   w:10, mult:{hp:1.00, atk:1.08, def:1.10} },
  { key:"volatile",    name:"暴走",   w:10, mult:{hp:0.85, atk:1.30, def:0.90} },
  { key:"vampiric",    name:"吸血",   w: 8, mult:{hp:1.08, atk:1.05, def:1.00}, enemyLs:0.03 },
  { key:"swift",       name:"俊敏",   w:10, mult:{hp:0.95, atk:1.10, def:0.95}, swift:0.12 },
  { key:"unyielding",  name:"不屈",   w: 8, mult:{hp:1.20, atk:0.98, def:1.18} },
  { key:"spiteful",    name:"怨嗟",   w: 6, mult:{hp:1.00, atk:1.06, def:1.02}, enemySpite:0.04 },
  { key:"mystic",      name:"神秘",   w: 6, mult:{hp:1.00, atk:1.00, def:1.00}, mysticLoot:0.15 },

  // 五毒（煩悩）付帯：密教らしさを“決定づける”障覆演出の根
  { key:"greed",       name:"貪（とん）", w:11, mult:{hp:1.10, atk:1.06, def:1.00}, goldMul:1.28, karmaKill:-2 },
  { key:"anger",       name:"瞋（しん）", w:11, mult:{hp:1.00, atk:1.18, def:0.98}, xpMul:1.10, karmaKill:-2, swift:0.06 },
  { key:"ignorance",   name:"痴（ち）",   w:10, mult:{hp:1.15, atk:1.00, def:1.10}, karmaKill:-1, mysticLoot:0.05 },
  { key:"pride",       name:"慢（まん）", w: 8, mult:{hp:1.22, atk:1.06, def:1.12}, karmaKill:-2 },
  { key:"envy",        name:"嫉（しつ）", w: 8, mult:{hp:1.00, atk:1.10, def:1.02}, goldMul:0.92, xpMul:1.06, karmaKill:-1 },
];


  // --------------------
  // Monster Mod (付帯特性) tooltips
  // --------------------
  const MOD_BY_NAME = (() => {
    const m = {};
    try{ (MON_MODS||[]).forEach(x => { if (x && x.name) m[x.name] = x; }); }catch(_){}
    return m;
  })();

  function modExplain(name){
    const n = String(name ?? "");
    const m = MOD_BY_NAME[n];
    if (!m) return n;

    const lines = [];
    const mult = [];
    const mm = m.mult || {};
    const hp = Number(mm.hp ?? 1);
    const atk = Number(mm.atk ?? 1);
    const def = Number(mm.def ?? 1);
    if (hp !== 1) mult.push(`HP×${hp}`);
    if (atk !== 1) mult.push(`降魔×${atk}`);
    if (def !== 1) mult.push(`持戒×${def}`);
    if (mult.length) lines.push(mult.join(" / "));

    // Special behaviors (must match game logic)
    if (m.key === "vampiric"){
      lines.push(`吸血: 受苦の${Math.round((Number(m.enemyLs ?? 0.03))*100)}%を回復`);
    }
    if (m.key === "swift"){
      lines.push(`迅行: 行動間隔-${Math.round((Number(m.swift ?? 0.12))*100)}%（手数↑）`);
    }
    if (m.key === "spiteful"){
      lines.push(`怨嗟: 20%で追撃（受苦×${Math.round((Number(m.enemySpite ?? 0.04))*100)}%）`);
    }
    if (m.key === "mystic"){
      lines.push(`神秘: 授与の希少度補正 +${Number(m.mysticLoot ?? 0.15)}`);
    }

    // Five poisons (五毒)
    if (m.key === "greed"){
      lines.push(`貪: 功徳×${Number(m.goldMul ?? 1.28)} / 加持+1(高確率) / 撃破功徳+12%`);
      lines.push(`業: 撃破時 ${Number(m.karmaKill ?? 0)}（負荷が増える）`);
    }
    if (m.key === "anger"){
      lines.push(`瞋: 行×${Number(m.xpMul ?? 1.10)} / 叩かれるほど降魔↑（怒り蓄積）`);
      lines.push(`副作用: 受苦で業が傾きやすい`);
      lines.push(`業: 撃破時 ${Number(m.karmaKill ?? 0)}`);
    }
    if (m.key === "ignorance"){
      lines.push(`痴: 慧眼（会心）を無効化（慧眼封印）`);
      lines.push(`神秘: 授与の希少度補正 +${Number(m.mysticLoot ?? 0.05)}`);
      lines.push(`業: 撃破時 ${Number(m.karmaKill ?? 0)}`);
    }
    if (m.key === "pride"){
      lines.push(`慢: 返業（与ダメ10% / 天魔14%）※致死しない（命1で止まる）`);
      lines.push(`苦減: DRは半分だけ効く`);
      lines.push(`業: 撃破時 ${Number(m.karmaKill ?? 0)}`);
    }
    if (m.key === "envy"){
      lines.push(`嫉: 被弾で功徳を吸う（確率）`);
      lines.push(`行×${Number(m.xpMul ?? 1.06)} / 功徳×${Number(m.goldMul ?? 0.92)}`);
      lines.push(`業: 撃破時 ${Number(m.karmaKill ?? 0)}`);
    }

    const body = lines.filter(Boolean).join("\n");
    return body ? `${m.name}\n${body}` : m.name;
  }

  function escAttr(s){
    return String(s ?? "")
      .replace(/&/g, "&amp;")
      .replace(/</g, "&lt;")
      .replace(/>/g, "&gt;")
      .replace(/"/g, "&quot;");
  }
  function modSpan(name){
    const n = String(name ?? "");
    const tip = escAttr(modExplain(n));
    return `<span class="modTag" title="${tip}">${n}</span>`;
  }
  function modsHtml(mods){
    return (mods || []).map(modSpan).join("、");
  }
  function modsTitle(mods){
    if (!mods || !mods.length) return "";
    return "特性:\n" + mods.map(n => modExplain(n)).join("\n\n");
  }


function biomeForFloor(floor){
  // 六道は深度で巡回しつつ、業で“寄り”が生じる
  const base = Math.floor((floor-1)/14) % BIOMES.length;
  const karma = clampKarma(num((S && S.hero && S.hero.karma) || 0, 0));
  const k = clamp(karma / 108, -1, 1); // -1..1
  const shift = Math.round(k * 2); // 悪業→地獄寄り / 善業→天道寄り
  const idx = clamp(base + shift, 0, BIOMES.length-1);
  return BIOMES[idx];
}


function karmaPullTag(k){
  const karma = clampKarma(num(k, 0));
  const kN = clamp(karma / 108, -1, 1);
  const shift = Math.round(kN * 2); // -2..2
  if (shift >= 2) return "〈天偏〉";
  if (shift === 1) return "〈天寄〉";
  if (shift === -1) return "〈獄寄〉";
  if (shift <= -2) return "〈獄偏〉";
  return "";
}


  const pickWeighted = (items, weightKey="w") => {
    const sum = items.reduce((s,it)=>s + it[weightKey], 0);
    let r = Math.random()*sum;
    for (const it of items){
      r -= it[weightKey];
      if (r <= 0) return it;
    }
    return items[items.length-1];
  };

  const RAR = [
    { key:"common",    name:"凡品",    w: 70, mult:1.00, aff:0, sell: 1.0 },
    { key:"uncommon",  name:"善品",  w: 20, mult:1.08, aff:1, sell: 1.5 },
    { key:"rare",      name:"妙品",      w:  8, mult:1.20, aff:2, sell: 2.3 },
    { key:"epic",      name:"秘宝",      w:  1.6, mult:1.38, aff:3, sell: 3.7 },
    { key:"legendary", name:"聖宝", w:  0.35, mult:1.70, aff:4, sell: 6.5 },
    { key:"unique",    name:"六印の欠片",    w:  0.05, mult:2.05, aff:5, sell: 12.0 },
  ];
  const SLOT_ORDER = ["weapon","armor","accessory"];
  const RAR_RANK = { common:0, uncommon:1, rare:2, epic:3, legendary:4, unique:5 };

  const SLOT_NAME = { weapon:"武器", armor:"防具", accessory:"瓔珞" };

  const UPG_LABEL = { str:"精進", vit:"忍辱", def:"持戒", luck:"縁" };
  const GUILD_LABEL = { forge:"金剛炉", bounty:"勧進所", library:"蔵経閣", shrine:"道場" };
const GUILD_CAP = { forge:120, bounty:100, library:100, shrine:60 }; // これ以上は効果が頭打ち
function guildCap(which){ return (GUILD_CAP && Number.isFinite(GUILD_CAP[which])) ? GUILD_CAP[which] : Infinity; }


// --------------------
// 密教拡張：業・悟り・真言
// --------------------
const REALM_ORDER = ["hell","hungry","animal","asura","human","deva"]; // 六道の並び
const REALM_LABEL = { hell:"地獄道", hungry:"餓鬼道", animal:"畜生道", asura:"修羅道", human:"人間道", deva:"天道" };

// --------------------
// ストーリー：曼荼羅帳（六道章）
// --------------------
const STORY = {
  hell: {
    chapNo: 1,
    chap: "第一章 苦諦界（地獄道）",
    tagline: "怒りが世界を焼く。",
    prologue: "門は熱を言葉に変え、あなたの舌を焼く。\nここでは『痛み』が経となり、『怒り』が筆となる。\n苦を避けず、苦の形を写して進め。",
    whisper: "焼け跡に残るのは、怒りではなく因果。",
    seal: "焦熱印",
    epilogue: "焼け跡に残るのは、怒りではなく因果。",
    glyph: "火",
  },
  hungry: {
    chapNo: 2,
    chap: "第二章 集諦界（餓鬼道）",
    tagline: "欠乏は器ではなく穴だ。",
    prologue: "欠乏は器ではなく、穴だ。\n満たしても満ちない穴に、名を付ける。\n渇愛を見て、布施を学べ。",
    whisper: "穴を塞がず、穴を照らした。",
    seal: "渇愛印",
    epilogue: "穴を塞がず、穴を照らした。",
    glyph: "渇",
  },
  animal: {
    chapNo: 3,
    chap: "第三章 無明界（畜生道）",
    tagline: "霧の中では、理がほどける。",
    prologue: "霧の奥で、理は輪郭を失う。\n無明は敵ではなく、前提だ。\n問いを一つ残して進め。",
    whisper: "霧は消えない。ただ、歩幅が変わる。",
    seal: "霧明印",
    epilogue: "霧は消えない。ただ、歩幅が変わる。",
    glyph: "霧",
  },
  asura: {
    chapNo: 4,
    chap: "第四章 瞋慢界（修羅道）",
    tagline: "勝敗は鏡で、刃は内にある。",
    prologue: "勝ち負けは剣ではなく、鏡だ。\n鏡に映るのは他者ではなく、己の慢。\n怒りを熱に、誓いを刃に。",
    whisper: "刃は外ではなく内へ向いた。",
    seal: "争鏡印",
    epilogue: "刃は外ではなく内へ向いた。",
    glyph: "争",
  },
  human: {
    chapNo: 5,
    chap: "第五章 分別界（人間道）",
    tagline: "選ぶことは、切り分けること。",
    prologue: "分別は橋にも檻にもなる。\nあなたは『選ぶ』ことで世界を切り分ける。\n選んだ後に、捨てられるか。",
    whisper: "答えは結論ではなく、手放しだった。",
    seal: "分別印",
    epilogue: "答えは結論ではなく、手放しだった。",
    glyph: "択",
  },
  deva: {
    chapNo: 6,
    chap: "第六章 有頂界（天道）",
    tagline: "満ちた瞬間、終わりが始まる。",
    prologue: "光は永遠を偽装する。\n満ち足りた瞬間、終わりが始まる。\n無常を見よ。",
    whisper: "光は衰える。だからこそ、誓いは明るい。",
    seal: "五衰印",
    epilogue: "光は衰える。だからこそ、誓いは明るい。",
    glyph: "衰",
  },
};

function ensureStoryFields(){
  ensureMikkyoFields();
  const c = S.hero.codex;
  c.story = c.story || { intros:{}, seals:{}, fragments:{}, ending:"", last:"", lastRealm:"" };
  c.story.intros = c.story.intros || {};
  c.story.seals = c.story.seals || {};
  c.story.fragments = c.story.fragments || {};
  c.story.ending = String(c.story.ending || "");
  c.story.last = String(c.story.last || "");
  c.story.lastRealm = String(c.story.lastRealm || "");
}

function ensureLibrary(){
  ensureMikkyoFields();
  const c = S.hero.codex;
  c.library = c.library || { docs:{}, order:[] };
  c.library.docs = c.library.docs || {};
  c.library.order = Array.isArray(c.library.order) ? c.library.order : [];
}


function migrateLibraryNoiseOnce(){
  try{
    ensureLibrary();
    const lib = S.hero.codex.library;
    if (!lib || lib._noiseMigrated) return;
    lib._noiseMigrated = 1;

    const docs = lib.docs || {};
    const order = Array.isArray(lib.order) ? lib.order : [];
    const out = [];
    const seen = Object.create(null);

    for (const k of order){
      const d = docs[k];
      if (!d) continue;

      const body = String(d.body||"").trim();
      const norm = body.replace(/\s+/g, " ").trim();

      // Drop empty / placeholder noise.
      if (!norm || norm === "記録"){
        try{ delete docs[k]; }catch(_){}
        continue;
      }

      let title = String(d.title||"").trim();
      let kind  = String(d.kind||"").trim();

      // Upgrade old "記録" entries into meaningful titles/kinds, and de-dup them.
      if (title === "記録" && kind === "記録"){
        if (seen[norm]){
          try{ delete docs[k]; }catch(_){}
          continue;
        }
        seen[norm] = 1;

        let kind2 = "出来事";
        let title2 = norm;

        const m = norm.match(/^([^：:]{1,10})[：:]\s*(.+)$/);
        if (m){
          kind2 = (m[1] || "").trim() || kind2;
          title2 = (m[2] || "").trim() || kind2;
        }
        if (/昇位/.test(norm)) kind2 = "進行";
        else if (/^層\s*\d+/.test(norm)) kind2 = "進行";
        else if (/調伏に至らず/.test(norm)) kind2 = "死亡";
        else if (/^救済復活/.test(norm) || /^復活/.test(norm)) kind2 = "復活";
        else if (/^未接続報酬/.test(norm)) kind2 = "報酬";
        else if (/^宝函/.test(norm)) kind2 = "宝函";
        else if (/^自動布施/.test(norm)) kind2 = "自動布施";
        else if (/^(例外|描画例外|起動)/.test(norm)) kind2 = "システム";

        if (title2.length > 46) title2 = title2.slice(0, 46) + "…";
        d.kind = kind2;
        d.title = title2;
        d._norm = norm;
      }

      out.push(k);
    }

    lib.order = out;
  }catch(_){}
}

// Strip HTML tags + decode basic entities (for archiving texts)
function stripHtmlToText(html){
  try{
    let s = String(html || "");
    s = s.replace(/<br\s*\/?>(?!\s*<)/gi, "\n");
    s = s.replace(/<br\s*\/?>(?=\s*<)/gi, "\n");
    s = s.replace(/<[^>]*>/g, "");
    s = s.replace(/&nbsp;/g, " ")
         .replace(/&amp;/g, "&")
         .replace(/&lt;/g, "<")
         .replace(/&gt;/g, ">")
         .replace(/&quot;/g, '"')
         .replace(/&#39;/g, "'");
    return s.replace(/\s+\n/g, "\n").replace(/\n\s+/g, "\n").trim();
  }catch(_){ return String(html||""); }
}

function recordDoc(key, title, body, foot, kind, realmKey){
  try{
    ensureLibrary();
    if (!key) key = "doc-" + safeUUID();
    const lib = S.hero.codex.library;
    const docs = lib.docs;
    const ts = now();

    const e = docs[key] || {};
    e.key = key;
    e.title = String(title ?? e.title ?? "—");
    e.body  = String(body  ?? e.body  ?? "");
    e.foot  = String(foot  ?? e.foot  ?? "");
    e.kind  = String(kind  ?? e.kind  ?? "");
    e.realmKey = String(realmKey ?? e.realmKey ?? "");
    e.ts = ts;
    docs[key] = e;

    lib.order = Array.isArray(lib.order) ? lib.order : [];
    lib.order = lib.order.filter(k => k !== key);
    lib.order.unshift(key);

    const CAP = 420;
    if (lib.order.length > CAP){
      const drop = lib.order.splice(CAP);
      for (const dk of drop){
        try{ delete docs[dk]; }catch(_){}
      }
    }
  }catch(_){}
}

function recordVerse(realmKey, text){
  const t = String(text || "").trim();
  if (!t) return;
  const lab = REALM_LABEL[realmKey] || realmKey || "—";
  const key = "verse:" + now() + ":" + Math.random().toString(16).slice(2,6);
  recordDoc(key, "偈（" + lab + "）", t, "", "偈", realmKey);
}

function recordEventToLibrary(ev){
  try{
    if (!ev) return;
    const rawKey = String(ev.key || "").trim();
    const key = rawKey ? ("event:" + rawKey) : ("event:" + safeUUID());
    const title = String(ev.title || (rawKey ? rawKey : "儀礼"));
    const body  = String(ev.body || "");
    const foot  = String(ev.foot || "");
    const kind  = String(ev.kind || "儀礼");
    const realmKey = String(ev.realmKey || "");
    recordDoc(key, title, body, foot, kind, realmKey);
  }catch(_){}
}

function recordStoryToLibrary(realmKey, st){
  try{
    if (!realmKey || !st) return;
    recordDoc("story:prologue:" + realmKey, st.chap || (REALM_LABEL[realmKey]||realmKey), st.prologue || "", "（界門の序）", "章", realmKey);
  }catch(_){}
}
function recordSealToLibrary(realmKey, st){
  try{
    if (!realmKey || !st) return;
    const body = ("印: " + (st.seal||"")).trim() + (st.epilogue ? ("\n\n" + st.epilogue) : "");
    if (body.trim()) recordDoc("story:seal:" + realmKey, (st.chap || (REALM_LABEL[realmKey]||realmKey)) + " — 印", body.trim(), "", "章", realmKey);
  }catch(_){}
}

function setLastVerse(realmKey, text){
  ensureStoryFields();
  const t = String(text || "");
  S.hero.codex.story.last = t;
  S.hero.codex.story.lastRealm = String(realmKey || "");
  try{ if (t) recordVerse(realmKey, t); }catch(_){ }
}

function maybeRealmPrologue(realmKey, realmName){
  try{
    ensureStoryFields();
    if (!realmKey) return false;
    if (S.hero.codex.story.intros && S.hero.codex.story.intros[realmKey]) return false;
    const st = STORY[realmKey];
    if (!st) return false;

    // 序は「表示した時点」で曼荼羅帳に刻む（自動巡礼でも後で読める）
    const intros = S.hero.codex.story.intros || (S.hero.codex.story.intros = {});
    intros[realmKey] = 1;

    try{ recordStoryToLibrary(realmKey, st); }catch(_){ }

    const ev = {
      key: "realm_intro_" + realmKey,
      kind: "章",
      realmKey: realmKey,
      forceModal: true,
      title: st.chap,
      body: st.prologue,
      foot: "曼荼羅帳に記される。",
      choices: [
        { label:"合掌して進む", accent:true, apply: ()=>{
          ensureStoryFields();
          S.hero.codex.story.intros[realmKey] = 1;
          const line = st.whisper || st.tagline || "";
          if (line) { setLastVerse(realmKey, line); try{ log(`<span class="muted">${escapeHtml(line)}</span>`); }catch(_){ } }
          S.hero.satori += 2;
          addKarma(1);
        } }
      ]
    };
    openEvent(ev);
    return true;
  }catch(_){}
  return false;
}

function storyBossSeal(realmKey){
  try{
    ensureStoryFields();
    if (!realmKey) return;
    const st = STORY[realmKey];
    if (!st) return;
    const seals = S.hero.codex.story.seals || (S.hero.codex.story.seals = {});
    if (seals[realmKey]) return;

    seals[realmKey] = 1;
    try{ recordSealToLibrary(realmKey, st); }catch(_){ }

    const gain = 8;
    S.hero.satori += gain;
    addKarma(4);

    log(`<span class="rare">印</span>: ${escapeHtml(st.seal)}（悟り +${fmt(gain)} / 業 +4）`);
    if (st.epilogue) log(`<span class="muted">${escapeHtml(st.epilogue)}</span>`);
    try{ spawnMantraFx(st.glyph || "ॐ"); }catch(_){}

    setLastVerse(realmKey, st.epilogue || st.seal || "");
    dirtyLog = true;
  }catch(_){}
}

// --- 六印の欠片（ユニーク＝欠片）/ 結願（エンディング分岐） ---
function hasAllSixFragments(){
  ensureStoryFields();
  const fr = (S.hero.codex.story && S.hero.codex.story.fragments) ? S.hero.codex.story.fragments : {};
  return REALM_ORDER.every(k => (fr[k]||0) > 0);
}
function fragmentCount(){
  ensureStoryFields();
  const fr = (S.hero.codex.story && S.hero.codex.story.fragments) ? S.hero.codex.story.fragments : {};
  let n = 0;
  for (const k of REALM_ORDER) if ((fr[k]||0) > 0) n++;
  return n;
}
function applySealToUnique(it, realmKey){
  try{
    ensureStoryFields();
    realmKey = realmKey || biomeForFloor(S.run.floor).key;
    const st = STORY[realmKey] || {};
    const seal = st.seal || "六印";
    const glyph = st.glyph || "印";
    const rlabel = REALM_LABEL[realmKey] || realmKey;

    it.sealRealm = realmKey;
    it.sealName  = seal;
    it.sealGlyph = glyph;

    // 表記：一文字（欠片の漢字）を先頭に据える
    const baseName = String(it.name || "法具");
    it.name = `【${glyph}】${seal}の欠片・${baseName}`;

    const lore = `六印の欠片：${seal}（${rlabel}）\n曼荼羅帳に刻まれた印が、法具として結晶したもの。\n六つ揃えば「結願」の門が開く。`;
    const old = String(it.desc || "").trim();
    it.desc = (lore + (old ? `\n—\n${old}` : "")).trim();
  }catch(_){}
}
function grantSealFragment(realmKey){
  try{
    ensureStoryFields();
    realmKey = realmKey || biomeForFloor(S.run.floor).key;
    const st = STORY[realmKey] || {};
    const seal = st.seal || (REALM_LABEL[realmKey]||realmKey);
    const glyph = st.glyph || "印";

    const story = S.hero.codex.story;
    story.fragments = story.fragments || {};
    const before = Math.floor(num(story.fragments[realmKey], 0));
    story.fragments[realmKey] = before + 1;

    if (before === 0){
      // 初回獲得：記録として残し、結願に近づく
      const gain = 10;
      S.hero.satori += gain;
      addKarma(3);
      log(`<span class="rare">六印</span>: 【${escapeHtml(glyph)}】${escapeHtml(seal)}の欠片（悟り +${fmt(gain)} / 業 +3）`);
      if (st.whisper) { setLastVerse(realmKey, st.whisper); try{ log(`<span class="muted">${escapeHtml(st.whisper)}</span>`); }catch(_){ } }
      try{ spawnMantraFx(glyph); }catch(_){}

      // Unlock MAX speed when all six fragments are collected.
      try{
        if (hasAllSixFragments() && !story._maxSpeedUnlocked){
          story._maxSpeedUnlocked = 1;
          log('<span class="rare">迅行</span>: MAXが解放された！');
          dirtyLog = true;
          dirtyHUD = true;
        }
      }catch(_){}
      try{ syncSpeedSelUnlock(); }catch(_){}

      maybeUnlockEnding();
    } else {
      // 重複は功徳へ還元（記録は増えるが、章進行は初回だけ）
      const g = Math.round(260 + Math.random()*340);
      S.hero.gold += g;
      log(`<span class="muted">六印</span>: 重複の欠片 → <span class="gold">功徳 +${fmt(g)}</span>`);
    }
  }catch(_){}
}
function openEndingChoice(){
  ensureStoryFields();
  if (!hasAllSixFragments()) return false;
  const story = S.hero.codex.story;
  const ending = String(story.ending||"");
  if (ending === "kongo" || ending === "taizo") return false;

  const ev = {
    key:"ketsugan",
    title:"結願 — 六印還元",
    body:"六つの欠片が揃い、印は再び輪となった。\nここから先、あなたはどの曼荼羅に結ぶか。\n結願は以後の巡礼に、永続の加持として残る。",
    foot:"（保留した場合、曼荼羅帳からいつでも結べる）",
    choices:[
      { label:"🔱 金剛界に結ぶ（調伏の結願）", accent:true, apply:()=>{
        story.ending = "kongo";
        setLastVerse("deva", "刃は断つためではなく、迷いを縫い留めるために光った。");
        S.hero.satori += 30; addKarma(8);
        log('<span class="rare">結願</span>: 金剛界（調伏）');
      }},
      { label:"🌸 胎蔵界に結ぶ（慈悲の結願）", apply:()=>{
        story.ending = "taizo";
        setLastVerse("human", "守りは囲うためではなく、開くために静かに広がった。");
        S.hero.satori += 30; addKarma(8);
        log('<span class="rare">結願</span>: 胎蔵界（慈悲）');
      }},
      { label:"保留（まだ歩く）", apply:()=>{
        story.ending = "pending";
        log('<span class="muted">結願</span>: 保留（曼荼羅帳から選択可）');
      }},
    ]
  };
  openEvent(ev);
  return true;
}
function maybeUnlockEnding(){
  try{
    ensureStoryFields();
    const story = S.hero.codex.story;
    const ending = String(story.ending||"");
    if (ending === "kongo" || ending === "taizo") return false;
    if (!hasAllSixFragments()) return false;
    return openEndingChoice();
  }catch(_){}
  return false;
}



const PATH_KEYS = []; // 八正道（印契修行）は削除


function clampKarma(x){
  x = Math.floor(num(x, 0));
  return clamp(x, -108, 108);
}
function addKarma(delta){
  if (!S || !S.hero) return;
  const before = clampKarma(S.hero.karma || 0);
  const after = clampKarma(before + Math.floor(num(delta, 0)));
  S.hero.karma = after;
  return { before, after };
}

function ensureMikkyoFields(){
  // 業・悟り・真言のみ維持（回向/八正道は削除）
  S.hero.karma = clampKarma(num(S.hero.karma, 0));
  S.hero.satori = Math.max(0, Math.floor(num(S.hero.satori, 0)));

  // 旧セーブ互換: S.hero.path / codex.dedicates が残っていても無視する

  S.hero.codex = S.hero.codex || { realms:{}, events:{}, bosses:0, elites:0, uniques:0, mantras:0, purifies:0, kills:0, maxFloor:1 };
  S.hero.codex.realms = S.hero.codex.realms || {};
  S.hero.codex.events = S.hero.codex.events || {};
  S.hero.codex.bosses = Math.max(0, Math.floor(num(S.hero.codex.bosses, 0)));
  S.hero.codex.elites = Math.max(0, Math.floor(num(S.hero.codex.elites, 0)));
  S.hero.codex.uniques = Math.max(0, Math.floor(num(S.hero.codex.uniques, 0)));
  S.hero.codex.mantras = Math.max(0, Math.floor(num(S.hero.codex.mantras, 0)));
  S.hero.codex.purifies = Math.max(0, Math.floor(num(S.hero.codex.purifies, 0)));
  S.hero.codex.kills = Math.max(0, Math.floor(num(S.hero.codex.kills, 0)));
  S.hero.codex.maxFloor = Math.max(1, Math.floor(num(S.hero.codex.maxFloor, 1)));
  // 曼荼羅帳（ストーリー）
  S.hero.codex.story = S.hero.codex.story || { intros:{}, seals:{}, last:"", lastRealm:"" };
  S.hero.codex.story.intros = S.hero.codex.story.intros || {};
  S.hero.codex.story.seals = S.hero.codex.story.seals || {};
  S.hero.codex.story.last = String(S.hero.codex.story.last || "");
  S.hero.codex.story.lastRealm = String(S.hero.codex.story.lastRealm || "");

  // 曼荼羅帳（文庫）: 物語/儀礼/重要な文の保存
  S.hero.codex.library = S.hero.codex.library || { docs:{}, order:[] };
  S.hero.codex.library.docs = S.hero.codex.library.docs || {};
  S.hero.codex.library.order = Array.isArray(S.hero.codex.library.order) ? S.hero.codex.library.order : [];


  S.run.mantraUntil = num(S.run.mantraUntil, 0);
  S.run.mantraCdUntil = num(S.run.mantraCdUntil, 0);
  S.run._eventLock = num(S.run._eventLock, 0);
  S.run._resumeAfterEvent = (Number(S.run._resumeAfterEvent) === 1) ? 1 : 0;
}



  const WEAPONS = [
    { base:"般若剣",      stat:{ atk: 8, crit:0.02, spd:0.00 }},
    { base:"大般若剣",    stat:{ atk:12, crit:0.01, spd:-0.05 }},
    { base:"縁起蓮華剣", stat:{ atk: 8, crit:0.05, spd: 0.03 }},
    { base:"断惑斧",      stat:{ atk:10, crit:0.00, spd:-0.03 }},
    { base:"中道槍",      stat:{ atk: 9, crit:0.01, spd:-0.01 }},
    { base:"空性薙刀", stat:{ atk:11, crit:0.01, spd:-0.03 }},
    { base:"断輪廻鎌",      stat:{ atk:10, crit:0.02, spd:-0.02, execute:0.02 }},
    { base:"因縁珠鎚", stat:{ atk:10, crit:0.01, spd:-0.01, shred:0.02 }},
    { base:"無我短剣",    stat:{ atk: 7, crit:0.04, spd: 0.06 }},
    { base:"慈悲蓮弓",      stat:{ atk: 8, crit:0.02, spd: 0.03 }},
    { base:"破邪弩", stat:{ atk: 9, crit:0.03, spd: 0.00 }},
    { base:"行脚錫杖",      stat:{ atk: 7, crit:0.01, spd: 0.02 }},
    { base:"三密加持錫杖",  stat:{ atk: 7, crit:0.03, spd: 0.02 }},
    { base:"阿頼耶陀羅尼巻",  stat:{ atk: 6, crit:0.03, spd: 0.04 }},
    { base:"業断槌", stat:{ atk:11, crit:0.00, spd:-0.06 }},
    { base:"五蘊棍",  stat:{ atk: 9, crit:0.01, spd:-0.04, lifesteal:0.01 }},
    { base:"種子連珠砲",  stat:{ atk: 7, crit:0.02, spd: 0.07 }},
    { base:"不動智剣",      stat:{ atk: 9, crit:0.03, spd: 0.02 }},
  ];
  const ARMORS = [
    { base:"五蘊法衣", stat:{ hp: 24, def: 3, spd: 0.02 }},
    { base:"縁起鎖衣",  stat:{ hp: 34, def: 4, spd: 0.00 }},
    { base:"金剛縁起鎖衣", stat:{ hp: 42, def: 6, spd: 0.01 }},
    { base:"中道板衣", stat:{ hp: 48, def: 7, spd:-0.03 }},
    { base:"金剛中道板衣",   stat:{ hp: 58, def: 9, spd:-0.04 }},
    { base:"無常鱗衣", stat:{ hp: 40, def: 5, spd:-0.01 }},
    { base:"仏性龍鱗法衣", stat:{ hp: 55, def: 8, crit:0.01 }},
    { base:"菩薩袈裟",       stat:{ hp: 22, def: 2, crit:0.01 }},
    { base:"禅定法衣",         stat:{ hp: 26, def: 2, crit:0.03 }},
    { base:"空観隠密衣",       stat:{ hp: 28, def: 3, spd: 0.05, crit:0.01 }},
    { base:"慈悲外套",       stat:{ hp: 30, def: 3, crit:0.02 }},
    { base:"空性結界外套",  stat:{ hp: 36, def: 4, dr:0.01, spd: 0.02 }},
  ];
  const ACCS = [
    { base:"三学戒環",       stat:{ crit:0.02 }},
    { base:"縁起護符",  stat:{ hp: 14, def:1 }},
    { base:"正念符",     stat:{ atk: 3, spd:0.02 }},
    { base:"空性霊符",  stat:{ luck:2 }},
    { base:"因縁念珠腕輪", stat:{ def:2, spd:0.02 }},
    { base:"回向佩符",  stat:{ hp: 10, crit:0.01, luck:1 }},
    { base:"無我耳輪",  stat:{ crit:0.02, spd:0.02 }},
    { base:"菩薩護腕輪",       stat:{ def:3, hp: 6 }},
    { base:"ムドラー印章",       stat:{ luck:3, goldBonus:0.02 }},
    { base:"如来蔵宝珠",       stat:{ atk:2, crit:0.01, dmgMult:0.01 }},
    { base:"発願珠",     stat:{ hp: 12, regen:0.002 }},
    { base:"有時輪",     stat:{ spd:0.04, xpBonus:0.02 }},
  ];
  const AFFIX = [
    { key:"atk",  name:"降魔+",      apply:(v,ilv)=>({ atk: v + 2 + Math.floor(ilv/7) }),     w:18 },
    { key:"def",  name:"持戒+",      apply:(v,ilv)=>({ def: v + 2 + Math.floor(ilv/9) }),     w:15 },
    { key:"hp",   name:"命+",       apply:(v,ilv)=>({ hp: v + 12 + Math.floor(ilv*1.9) }),   w:16 },
    { key:"crit", name:"破魔+",     apply:(v,ilv)=>({ crit: v + 0.010 + ilv*0.0007 }),       w:10 },
    { key:"spd",  name:"迅行+",      apply:(v,ilv)=>({ spd: v + 0.010 + ilv*0.0006 }),        w:10 },
    { key:"luck", name:"縁+",     apply:(v,ilv)=>({ luck: v + 1 + Math.floor(ilv/12) }),   w:9  },
    { key:"lifesteal", name:"還命",  apply:(v,ilv)=>({ lifesteal: Math.max(v, 0.010 + ilv*0.00035) }), w:7 },
    { key:"thorns",    name:"返業",  apply:(v,ilv)=>({ thorns: Math.max(v, 0.015 + ilv*0.00040) }),    w:5 },
    { key:"regen",     name:"息災",  apply:(v,ilv)=>({ regen: Math.max(v, 0.003 + ilv*0.00005) }),      w:7 },
    { key:"goldBonus", name:"功徳+",apply:(v,ilv)=>({ goldBonus: (v||0) + 0.03 + ilv*0.0002 }),         w:7 },
    { key:"xpBonus",   name:"行+", apply:(v,ilv)=>({ xpBonus: (v||0) + 0.03 + ilv*0.0002 }),           w:7 },
    { key:"dmgMult",   name:"威光+",apply:(v,ilv)=>({ dmgMult: (v||0) + 0.02 + ilv*0.00015 }),        w:5 },
    { key:"dr",        name:"苦減+",apply:(v,ilv)=>({ dr: (v||0) + 0.01 + ilv*0.00010 }),             w:5 },
    { key:"execute",   name:"断業",  apply:(v,ilv)=>({ execute: Math.max(v||0, 0.02 + ilv*0.00010) }),   w:3 },
    { key:"shred",     name:"破障",  apply:(v,ilv)=>({ shred: Math.max(v||0, 0.03 + ilv*0.00012) }),     w:4 },
  ];

  // 30 Unique items (same as v3)
  const UNIQUES = [
    { name:"瞋火転智の牙", slot:"weapon", fixed:{ atk: 28, crit:0.06, spd:0.04, lifesteal:0.05, dmgMult:0.05 }, desc:"血の薔薇が刻む一撃。還命+威光。" },
    { name:"九重戒壇城", slot:"armor", fixed:{ hp: 140, def: 18, thorns:0.10, dr:0.05 }, desc:"返業と苦減。耐久の核。" },
    { name:"縁起の署名", slot:"accessory", fixed:{ crit:0.08, spd:0.05, luck:6, xpBonus:0.08 }, desc:"縁と成長。" },
    { name:"無明の金床", slot:"weapon", fixed:{ atk: 34, spd:-0.02, shred:0.10, dmgMult:0.04 }, desc:"破障で硬い魔を崩す。" },
    { name:"月輪禅衣", slot:"armor", fixed:{ hp: 110, def: 10, regen:0.010, xpBonus:0.06 }, desc:"息災と経験。" },
    { name:"功徳の誓願", slot:"accessory", fixed:{ goldBonus:0.15, luck:5, def:4 }, desc:"財徳瓔珞。" },
    { name:"正精進の針", slot:"weapon", fixed:{ atk: 24, crit:0.10, spd:0.08, execute:0.06 }, desc:"高速断業。" },
    { name:"照見の護り", slot:"armor", fixed:{ hp: 120, def: 14, dr:0.06, thorns:0.06 }, desc:"苦減と返業。" },
    { name:"種子悉曇札", slot:"accessory", fixed:{ luck:8, dmgMult:0.03, xpBonus:0.05, goldBonus:0.05 }, desc:"全部盛り系（薄め）。" },
    { name:"無常の王冠", slot:"accessory", fixed:{ def:6, crit:0.04, lifesteal:0.03, dr:0.03 }, desc:"死地で強い。" },
    { name:"空裂き", slot:"weapon", fixed:{ atk: 30, spd:0.03, goldBonus:0.08, xpBonus:0.08 }, desc:"周回効率。" },
    { name:"阿頼耶の盟約", slot:"armor", fixed:{ hp: 130, def: 16, shred:0.05, dr:0.04 }, desc:"硬い魔ほど強い。" },
    { name:"刹那の霜刃", slot:"weapon", fixed:{ atk: 26, crit:0.05, spd:0.03, dr:0.02 }, desc:"冷気の刃。" },
    { name:"正念の握り", slot:"weapon", fixed:{ atk: 32, spd:-0.01, thorns:0.04, def:6 }, desc:"握りが硬い。" },
    { name:"因縁の糸", slot:"armor", fixed:{ hp: 100, def: 9, crit:0.04, regen:0.008 }, desc:"未来を見る布。" },
    { name:"五蘊の殻", slot:"armor", fixed:{ hp: 160, def: 12, dr:0.04 }, desc:"命特化。" },
    { name:"八正道の迅輪", slot:"accessory", fixed:{ crit:0.06, xpBonus:0.06, dmgMult:0.03 }, desc:"成長調伏力。" },
    { name:"功徳の印", slot:"accessory", fixed:{ goldBonus:0.18, luck:3 }, desc:"金策全振り。" },
    { name:"幻宝匣の微笑", slot:"accessory", fixed:{ luck:7, goldBonus:0.07, xpBonus:0.07 }, desc:"真偽不明。" },
    { name:"因果の心臓", slot:"accessory", fixed:{ def:5, spd:0.05, regen:0.006 }, desc:"回転数が上がる。" },
    { name:"念死の鎮魂歌", slot:"weapon", fixed:{ atk: 27, lifesteal:0.06, execute:0.03 }, desc:"暗いほど吸う。" },
    { name:"慈光の守り", slot:"armor", fixed:{ hp: 115, def: 13, dr:0.05 }, desc:"安定。" },
    { name:"苦諦の契約", slot:"accessory", fixed:{ thorns:0.10, def:4, hp:40 }, desc:"返業で削る。" },
    { name:"道輪（正道）", slot:"accessory", fixed:{ spd:0.08, crit:0.03, luck:3 }, desc:"迅行特化。" },
    { name:"業報の台帳", slot:"accessory", fixed:{ xpBonus:0.16, luck:4 }, desc:"経験書。" },
    { name:"布施の雨", slot:"weapon", fixed:{ atk: 22, goldBonus:0.20, spd:0.02 }, desc:"金が降る。" },
    { name:"灰燼の戒胸", slot:"armor", fixed:{ hp: 125, def: 15, thorns:0.05 }, desc:"熱い鎧。" },
    { name:"空性の硝子", slot:"weapon", fixed:{ atk: 25, crit:0.12, volatile:1 }, desc:"尖りすぎ（演出用）。" },
    { name:"戒護の結び", slot:"accessory", fixed:{ dr:0.07, def:6 }, desc:"苦減。" },
    { name:"業王の符", slot:"accessory", fixed:{ execute:0.08, crit:0.04 }, desc:"仕留める。" },
    { name:"禅定の外套", slot:"armor", fixed:{ hp: 105, def: 11, spd:0.03, dr:0.02 }, desc:"静かな外套。" },
    { name:"祖師の金剛槍", slot:"weapon", fixed:{ atk: 29, shred:0.08, spd:0.01 }, desc:"破障槍。" },
    { name:"破邪雷弩", slot:"weapon", fixed:{ atk: 27, crit:0.08, spd:0.05, dmgMult:0.03 }, desc:"雷の連射。" },
    { name:"仏性竜鱗鎧", slot:"armor", fixed:{ hp: 150, def: 17, dr:0.03, crit:0.02 }, desc:"鱗が弾く。" },
    { name:"無常の砂時計", slot:"accessory", fixed:{ spd:0.10, xpBonus:0.10, luck:2 }, desc:"時間が伸びる。" },
    { name:"断輪廻の深淵鎌", slot:"weapon", fixed:{ atk: 31, execute:0.08, lifesteal:0.04, crit:0.04 }, desc:"刈り取る。" },
    { name:"縁起風紋蓮華剣", slot:"weapon", fixed:{ atk: 23, crit:0.14, spd:0.10 }, desc:"刺突で舞う。" },
    { name:"王侯の三学戒環", slot:"accessory", fixed:{ crit:0.07, luck:8, goldBonus:0.05 }, desc:"縁と富。" },
    { name:"星喰いの如来蔵宝珠", slot:"accessory", fixed:{ dmgMult:0.06, atk: 4, crit:0.03 }, desc:"調伏力特化。" },
    { name:"金剛不壊板衣", slot:"armor", fixed:{ hp: 180, def: 20, regen:0.006, dr:0.04 }, desc:"倒れない。" },
    { name:"夢幻法衣", slot:"armor", fixed:{ hp: 95, def: 8, crit:0.08, spd:0.03 }, desc:"薄いが鋭い。" },
    { name:"有時の懐中時計", slot:"accessory", fixed:{ spd:0.09, def:3, regen:0.003 }, desc:"刻むほど速い。" },
    { name:"破邪雷弩", slot:"weapon", fixed:{ atk: 27, crit:0.08, spd:0.05, dmgMult:0.03 }, desc:"雷を溜めて放つ。" },
    { name:"仏性竜鱗鎧", slot:"armor", fixed:{ hp: 150, def: 17, dr:0.03, crit:0.02 }, desc:"硬さと鋭さ。" },
    { name:"無常の砂時計", slot:"accessory", fixed:{ spd:0.10, xpBonus:0.10, luck:3 }, desc:"時間を削って進む。" },
    { name:"断輪廻の深淵鎌", slot:"weapon", fixed:{ atk: 31, execute:0.08, lifesteal:0.04 }, desc:"刈り取るための刃。" },
    { name:"縁起風紋蓮華剣", slot:"weapon", fixed:{ atk: 23, crit:0.14, spd:0.10 }, desc:"風の刺突。" },
    { name:"王侯の三学戒環", slot:"accessory", fixed:{ crit:0.07, luck:8, goldBonus:0.05 }, desc:"富と閃き。" },
    { name:"星喰いの如来蔵宝珠", slot:"accessory", fixed:{ dmgMult:0.06, atk: 4, crit:0.03 }, desc:"吸い込むほど強い。" },
    { name:"金剛不壊板衣", slot:"armor", fixed:{ hp: 180, def: 20, dr:0.04, regen:0.006 }, desc:"倒れない鎧。" },
    { name:"夢幻法衣", slot:"armor", fixed:{ hp: 95, def: 8, crit:0.08, spd:0.03 }, desc:"影の術式。" },
    { name:"有時の懐中時計", slot:"accessory", fixed:{ spd:0.09, def: 3, xpBonus:0.05 }, desc:"針が速い。" },

  ];

  // --------------------
  // State
  // --------------------
  const KEY_V3 = "hackloot_single_v3_99999";
  const KEY_V4 = "hackloot_single_v4_fix_99999";
  const KEY_V5 = "hackloot_single_v5_ui_fix_99999";
  const KEY_V6 = "hackloot_single_v6_compare_ui_99999";
  const KEY_V7 = "hackloot_mikkyo_v1_jp_00001";
  const KEY_V8 = "hackloot_mikkyo_v2_dualmandala_00002";
  const MAX_LV = Number.POSITIVE_INFINITY;
  // Visual scaling reference for slash thickness (位1=糸 / 位99999=最大太さ)
  const LV_VIS_MAX = 99999;

  const STARTER_GEAR = {
    weapon: { id:"starter-weapon", slot:"weapon", ilv:1, rarity:"uncommon", name:"訓練用の般若剣", stats:{ atk: 18, crit:0.02, spd:0.08 }, desc:"序盤安定。", t: now() },
    armor:  { id:"starter-armor",  slot:"armor",  ilv:1, rarity:"uncommon", name:"厚綿禅衣",    stats:{ hp: 95, def: 10, dr:0.02 }, desc:"詰み防止。", t: now() },
    accessory:{ id:"starter-acc",  slot:"accessory", ilv:1, rarity:"common", name:"行旅の護符", stats:{ hp: 20, luck:2, xpBonus:0.04 }, desc:"成長補助。", t: now() },
  };

  const defaultState = () => ({
    t: now(),
    version: 8,
    hero:{
      name:"行者", nameSet:false,
      lv:1, exp:0,
      gold: 80,
      karma: 0,
      satori: 0,
      path:{},
      codex:{ realms:{}, events:{}, bosses:0, elites:0, uniques:0, mantras:0, purifies:0, kills:0, maxFloor:1 },
      mandala:"",
      mandalaSeal:{ kongo:0, taizo:0 },
      base:{ str:0, vit:0, def:0, luck:0 },
      guild:{ forge:0, bounty:0, library:0, shrine:0 },
      hp: 150,
      hpMax: 150,
      dead:false,
          lock:{ weapon:false, armor:false, accessory:false },
    },
    gear:{ weapon: STARTER_GEAR.weapon, armor: STARTER_GEAR.armor, accessory: STARTER_GEAR.accessory },
    inv:[],
    ui:{ tab:"all", preview:null, fx:1, sound:0, upgBulk:1, gupgBulk:1 },
    run:{
      active:false,
      floor:1,
      room:1,
      roomsPerFloor:30,
      enemy:null,
      enemyHp:0,
      enemyHpMax:0,
      isBoss:false,
      isElite:false,
      mods:[],
      lastTick: now(),
      speed:1,
      auto:true,
      offlineChest: null,
      _roomTime: 0,
      _lastEnemyHp: 0,
      history: [],
      entryShield: 0,
      entryShieldDR: 0.45,
      mantraUntil: 0,
      mantraCdUntil: 0,
      _eventLock: 0,
      _resumeAfterEvent: 0,
    },
    log:[]
  });

  function migrateToV8(obj){
    // Make old / partial saves safe to use in v2
    const d = defaultState();
    const o = (obj && typeof obj === 'object') ? obj : {};
    const out = { ...d, ...o };
    out.hero = { ...d.hero, ...(o.hero||{}) };
    out.hero.lock = { ...(d.hero.lock||{}), ...((o.hero||{}).lock||{}) };
    out.hero.guild = { ...(d.hero.guild||{}), ...((o.hero||{}).guild||{}) };
    out.hero.path = { ...(d.hero.path||{}), ...((o.hero||{}).path||{}) };
    out.hero.codex = { ...(d.hero.codex||{}), ...((o.hero||{}).codex||{}) };
    out.gear = { ...d.gear, ...(o.gear||{}) };
    out.ui = { ...d.ui, ...(o.ui||{}) };
    out.run = { ...d.run, ...(o.run||{}) };
    out.inv = Array.isArray(o.inv) ? o.inv : [];
    out.log = Array.isArray(o.log) ? o.log : [];
    out.version = 8;
    return out;
  }

  function tryLoadAny(){
    const s8 = load(KEY_V8);
    if (s8) return migrateToV8(s8);
    const s7 = load(KEY_V7);
    if (s7) return migrateToV8(s7);
    const s6 = load(KEY_V6);
    if (s6) return migrateToV8(s6);
    const s5 = load(KEY_V5);
    if (s5) return migrateToV8(s5);
    const s4 = load(KEY_V4);
    if (s4) return migrateToV8(s4);
    const s3 = load(KEY_V3);
    if (s3) return migrateToV8(s3);
    return null;
  }

  // --------------------
  // State init (fix: S was never declared/initialized, causing the game to not boot)
  // --------------------
  S = tryLoadAny() || defaultState();
  try{ ensureLogIds(); }catch(_){ }

  try{ ensureMikkyoFields(); }catch(_){}
  try{ migrateLibraryNoiseOnce(); }catch(_){}
  try{
    const tNow = now();
    const cdU = num(S.run && S.run.mantraCdUntil, 0);
    if (cdU > tNow){
      const left = (cdU - tNow) / 1000;
      if (left > 35){
        S.run.mantraCdUntil = tNow + 30*1000;
      }
    }
  }catch(_){}


  // v64: 調伏演出を廃し、記のみで進行を表示（ログのみで状況が分かるように）
  try{
    S.ui = S.ui || {};
    S.ui.fx = 0;      // 演出は常にOFF
    S.ui.sound = 0;
  }catch(_){ }




  // --------------------
  // Guild bonus + Stat calc (fix)
  // --------------------
  function guildBonus(){
    // 僧団伽藍（功徳・長期向け）は削除：常に無効値を返す
    return { dropIlv:0, lootMult:1, goldMult:1, xpMult:1, rarityBoost:0 };
  }

  function calcStats(){
    // Central stat calc used by combat/UI/loot.
    ensureMikkyoFields();
    const h = S.hero;
    const base = calcStatsPure(S.gear);

    const mantraOn = (S.run && num(S.run.mantraUntil, 0) > 0 && now() < num(S.run.mantraUntil, 0));

    let goldMult2 = base.goldMult;
    let xpMult2   = base.xpMult;
    let dmgFactor = base.dmgFactor;
    let dr        = base.dr;

    // 真言（短時間加持）
    if (mantraOn){
      dmgFactor *= 1.60;
      goldMult2 *= 1.80;
      xpMult2   *= 1.80;
      dr = clamp(dr + 0.40, 0, 0.75);
    }



    // 結願（六印）: 永続の加持
    try{
      ensureStoryFields();
      const ending = String((S.hero.codex && S.hero.codex.story && S.hero.codex.story.ending) || "");
      if (ending === "kongo"){
        // 調伏: 刃が冴え、功徳の巡りが良くなる
        dmgFactor *= 1.18;
        goldMult2 *= 1.08;
      } else if (ending === "taizo"){
        // 慈悲: 守りが厚く、修行の積み上げが早くなる
        dr = clamp(dr + 0.08, 0, 0.75);
        xpMult2 *= 1.10;
      }
    }catch(_){}
    const hpMax = Math.max(1, Math.round(base.hpMax));
    h.hpMax = hpMax;
    h.hp = clamp(num(h.hp, hpMax), 0, hpMax);

    // 八正道（永続）/回向 は削除済み
    return { ...base, hpMax, goldMult: goldMult2, xpMult: xpMult2, dmgFactor, dr, rarityExtra:0, mantraOn };
  }

  function calcStatsPure(gearObj){
    const h = S.hero;
    const eq = gearObj;
    const gB = guildBonus();
    const lv = h.lv;

    const baseAtk = 12 + lv*1.9 + Math.pow(lv, 1.08)*0.05;
    const baseDef =  6 + lv*0.95 + Math.pow(lv, 1.05)*0.02;
    const baseHp  = 110 + lv*16  + Math.pow(lv, 1.10)*0.25;

    const up = h.base;
    let atk = baseAtk + up.str*1.4;
    let def = baseDef + up.def*1.2;
    let hpMax = baseHp + up.vit*16;

    let crit = 0.06;
    let spd = 1.18;
    let luck = up.luck;

    let lifesteal = 0, thorns = 0, regen = 0, goldBonus = 0, xpBonus = 0, dmgMult = 0, dr = 0, execute = 0, shred = 0;

    for (const slot of SLOT_ORDER){
      const it = eq[slot];
      if (!it) continue;
      const st = it.stats || {};
      atk += st.atk || 0;
      def += st.def || 0;
      hpMax += st.hp || 0;
      crit += st.crit || 0;
      spd += st.spd || 0;
      luck += st.luck || 0;

      lifesteal = Math.max(lifesteal, st.lifesteal || 0);
      thorns = Math.max(thorns, st.thorns || 0);
      regen = Math.max(regen, st.regen || 0);
      goldBonus += st.goldBonus || 0;
      xpBonus += st.xpBonus || 0;
      dmgMult += st.dmgMult || 0;
      dr += st.dr || 0;
      execute = Math.max(execute || 0, st.execute || 0);
      shred = Math.max(shred || 0, st.shred || 0);
    }

    crit = clamp(crit, 0, 0.65);
    spd = clamp(spd, 0.55, 2.75);
    dr = clamp(dr, 0, 0.60);

    const luckFactor = 1 + (Math.min(luck, 60) * 0.015);
    const goldMult = (1 + goldBonus) * gB.goldMult;
    const xpMult = (1 + xpBonus) * gB.xpMult;

    return { atk, def, hpMax, crit, spd, luck, luckFactor, lifesteal, thorns, regen, goldMult, xpMult, dmgFactor:1+(dmgMult||0), dr, execute:execute||0, shred:shred||0, gB };
  }

  function expectedDps(st){
    // 期待値基（会心1.6倍）
    const expHit = st.atk * st.dmgFactor * (1 + st.crit * 0.6);
    return expHit * st.spd;
  }

  function fmtSigned(n){
    const s = n >= 0 ? "+" : "−";
    return s + fmt(Math.abs(n));
  }
  function fmtSignedPct(p){
    const s = p >= 0 ? "+" : "−";
    return s + Math.abs(p).toFixed(1) + "%";
  }
  function fmtSignedPt(p){
    const s = p >= 0 ? "+" : "−";
    return s + Math.abs(p*100).toFixed(1) + "pt";
  }

  function compareDeltaForItem(it){
    const slot = it.slot;
    const cur = S.gear[slot];
    const a = calcStatsPure(S.gear);
    const gear2 = { ...S.gear, [slot]: it };
    const b = calcStatsPure(gear2);

    const dpsA = expectedDps(a);
    const dpsB = expectedDps(b);
    const dpsPct = dpsA > 0 ? ((dpsB/dpsA)-1)*100 : 0;

    const delta = {
      dpsPct,
      atk: b.atk - a.atk,
      def: b.def - a.def,
      hpMax: b.hpMax - a.hpMax,
      crit: b.crit - a.crit,
      spd: b.spd - a.spd,
      luck: b.luck - a.luck,
      dr: b.dr - a.dr,
      lifesteal: b.lifesteal - a.lifesteal,
      shred: b.shred - a.shred,
      execute: b.execute - a.execute,
      goldMult: b.goldMult - a.goldMult,
      xpMult: b.xpMult - a.xpMult,
      curItem: cur,
      a, b
    };
    return delta;
  }

  function summarizeDelta(delta, slot){
    const parts = [];
    // 調伏/秒 is the main indicator for weapons, 命/DEF for armor
    if (Number.isFinite(delta.dpsPct) && Math.abs(delta.dpsPct) >= 0.5) parts.push(`調伏力(調伏/秒) ${fmtSignedPct(delta.dpsPct)}`);
    if (Math.abs(delta.hpMax) >= 1) parts.push(`命 ${fmtSigned(delta.hpMax)}`);
    if (Math.abs(delta.def) >= 1) parts.push(`持戒 ${fmtSigned(delta.def)}`);
    if (Math.abs(delta.atk) >= 1) parts.push(`降魔 ${fmtSigned(delta.atk)}`);
    if (Math.abs(delta.crit) >= 0.002) parts.push(`慧眼 ${fmtSignedPt(delta.crit)}`);
    if (Math.abs(delta.spd) >= 0.01) parts.push(`迅行 ${fmtSignedPct(delta.spd*100)}`); // 迅行は加算（%功徳っぽく表示）
    if (Math.abs(delta.dr) >= 0.002) parts.push(`苦減 ${fmtSignedPt(delta.dr)}`);
    if (Math.abs(delta.lifesteal) >= 0.002) parts.push(`還命 ${fmtSignedPt(delta.lifesteal)}`);
    if (parts.length === 0) return "加持中とほぼ同等";
    return parts.slice(0, 6).join(" / ");
  }

  function deltaLines(delta){
    const lines = [];
    lines.push(`加持中より: 調伏力(調伏/秒) ${fmtSignedPct(delta.dpsPct)}`);
    lines.push(`降魔 ${fmtSigned(delta.atk)}   持戒 ${fmtSigned(delta.def)}   命 ${fmtSigned(delta.hpMax)}`);
    if (Math.abs(delta.crit) >= 0.0005 || Math.abs(delta.spd) >= 0.0005 || Math.abs(delta.luck) >= 0.1){
      lines.push(`慧眼 ${fmtSignedPt(delta.crit)}   迅行 ${fmtSignedPct(delta.spd*100)}   縁 ${fmtSigned(delta.luck)}`);
    }
    if (Math.abs(delta.dr) >= 0.0005 || Math.abs(delta.lifesteal) >= 0.0005 || Math.abs(delta.shred) >= 0.0005 || Math.abs(delta.execute) >= 0.0005){
      const extra = [];
      if (Math.abs(delta.dr) >= 0.0005) extra.push(`苦減 ${fmtSignedPt(delta.dr)}`);
      if (Math.abs(delta.lifesteal) >= 0.0005) extra.push(`還命 ${fmtSignedPt(delta.lifesteal)}`);
      if (Math.abs(delta.shred) >= 0.0005) extra.push(`破障 ${fmtSignedPt(delta.shred)}`);
      if (Math.abs(delta.execute) >= 0.0005) extra.push(`断業 ${fmtSignedPt(delta.execute)}`);
      lines.push(extra.join("   "));
    }
    return lines.join("\n");
  }

  function setPreview(id){
    S.ui = S.ui ?? { tab:"all", preview:null };
    S.ui.preview = id;
    save();
    dirtyInv = true;
    dirtyHUD = true;
    renderInventory();
    renderCompare();
  }

  function clearPreview(){
    if (!S.ui) S.ui = { tab:"all", preview:null };
    S.ui.preview = null;
    save();
    dirtyInv = true;
    dirtyHUD = true;
    renderInventory();
    renderCompare();
  }

  function renderCompare(){
    if (!els.cmpPanel) return;
    const id = (S.ui && S.ui.preview) ? S.ui.preview : null;
    if (!id){
      if (els.cmpHint) els.cmpHint.style.display = "";
      if (els.cmpBody) els.cmpBody.style.display = "none";
      return;
    }
    const it = S.inv.find(x => x.id === id) || null;
    if (!it){
      clearPreview();
      return;
    }
    const slot = it.slot;
    const cur = S.gear[slot];

    const delta = compareDeltaForItem(it);

    if (els.cmpHint) els.cmpHint.style.display = "none";
    if (els.cmpBody) els.cmpBody.style.display = "";

    if (els.cmpSlotPill) els.cmpSlotPill.textContent = SLOT_NAME[slot] + ` / 加持位 ${fmt(it.ilv)}`;
    if (els.cmpNewRar){ els.cmpNewRar.className = `rar ${it.rarity}`; els.cmpNewRar.textContent = rarLabel(it.rarity); }
    if (els.cmpNewName) els.cmpNewName.textContent = dispItemName(it);
    if (els.cmpNewPower) els.cmpNewPower.textContent = `強さ ${fmt(itemPower(it))}`;
    if (els.cmpNewStats) els.cmpNewStats.textContent = statLinesWithCaps(it) + (it.desc ? `\n${it.desc}` : "");

    if (cur){
      if (els.cmpCurRar){ els.cmpCurRar.className = `rar ${cur.rarity}`; els.cmpCurRar.textContent = rarLabel(cur.rarity); }
      if (els.cmpCurName) els.cmpCurName.textContent = dispItemName(cur);
      if (els.cmpCurPower) els.cmpCurPower.textContent = `強さ ${fmt(itemPower(cur))}`;
    } else {
      if (els.cmpCurRar){ els.cmpCurRar.className = "rar common"; els.cmpCurRar.textContent = "—"; }
      if (els.cmpCurName) els.cmpCurName.textContent = "未加持";
      if (els.cmpCurPower) els.cmpCurPower.textContent = "";
    }

    const txt = deltaLines(delta);
    if (els.cmpDelta) els.cmpDelta.textContent = txt;

    if (els.btnEquipSelected){
      els.btnEquipSelected.onclick = () => { equip(it.id); clearPreview(); };
    }
    if (els.btnClearSelected){
      els.btnClearSelected.onclick = () => { clearPreview(); };
    }
  }

  // --------------------
  // Enemy
  // --------------------
  function enemyFor(floor, room, hero位){
    const biome = biomeForFloor(floor);
    const roomsPerFloor = S.run.roomsPerFloor || 30;
    const isBoss = (room % 10 === 0) || (room === roomsPerFloor);
    const depth = (floor-1)*roomsPerFloor + room;
    const base = floor*2.3 + room*0.16 + Math.floor(depth*0.04);

    // 位追従（やりすぎると『戻っても魔が弱くならない』＝詰みやすい）
    // base（階層/部屋）を基準にしつつ、行者位が高すぎる場合だけ少しだけ引き上げる。
    const follow = Math.floor(hero位 * 0.75);
    const cap = Math.floor(base + 10);
    const synced = Math.min(follow, cap);
    let ilv = Math.max(1, Math.floor(Math.max(base, synced)));

    // 復活直後の救済：数部屋だけ魔位を下げる（再起動のための回復帯）
    const graceRooms = Math.max(0, Math.floor((S.run && S.run.reviveGraceRooms) || 0));
    if (graceRooms > 0){
      ilv = Math.max(1, ilv - 15);
    }
    let eliteChance = clamp(0.06 + depth*0.00025, 0.06, 0.45);
    // 復活直後は魔軍を抑えて立て直しやすくする
    if (graceRooms > 0) eliteChance *= 0.20;

    let isElite = !isBoss && (Math.random() < eliteChance);
    if (graceRooms > 0) isElite = false;
    const name = isBoss ? choice(biome.boss) : choice(biome.enemy);
    let modCount =
      isBoss ? (depth > 80 ? 2 : 1) :
      isElite ? (depth > 120 ? 2 : 1) :
      (depth > 140 && Math.random() < 0.22) ? 1 : 0;

    // 復活直後の救済：非天魔は付帯無しで再開（理不尽事故を減らす）
    if (graceRooms > 0 && !isBoss){
      modCount = 0;
    }

    const mods = [];
    const used = new Set();
    for (let i=0;i<modCount;i++){
      const m = pickWeighted(MON_MODS, "w");
      if (used.has(m.key)) { i--; continue; }
      used.add(m.key);
      mods.push(m);
    }

    const modMult = mods.reduce((acc, m) => ({
      hp: acc.hp*m.mult.hp,
      atk: acc.atk*m.mult.atk,
      def: acc.def*m.mult.def,
    }), { hp:1, atk:1, def:1 });
    let hp = Math.round((60 + ilv*7.8 + Math.pow(ilv, 1.06)*0.95) * (isBoss ? 2.35 : 1.0) * (isElite ? 1.45 : 1.0) * biome.mult.hp * modMult.hp);
    let atk = (7.5 + ilv*1.12 + Math.pow(ilv, 1.06)*0.055) * (isBoss ? 1.22 : 1.0) * (isElite ? 1.16 : 1.0) * biome.mult.atk * modMult.atk;
    let def = (3 + ilv*0.52 + Math.pow(ilv, 1.04)*0.018) * (isBoss ? 1.12 : 1.0) * (isElite ? 1.16 : 1.0) * biome.mult.def * modMult.def;

    // 復活直後の救済：数部屋だけ魔功徳相を軽くする（深層でも効果が出るように）
    if (graceRooms > 0 && !isBoss){
      hp = Math.max(1, Math.round(hp * 0.85));
      atk = atk * 0.85;
      def = def * 0.75;
    }

    // mod-derived extra properties
    const goldMul = mods.reduce((p,m)=> p * (m.goldMul || 1), 1.0);
    const xpMul   = mods.reduce((p,m)=> p * (m.xpMul || 1), 1.0);
    const karmaKill = mods.reduce((s,m)=> s + (m.karmaKill || 0), 0);

    return {
      name,
      biome: biome.name,
      realmKey: biome.key,
      ilv,
      isBoss,
      isElite,
      mods: mods.map(x => x.name),
      modKeys: mods.map(x => x.key),
      hp, atk, def,
      defMul: 1.0,
      enemyLs: mods.some(m=>m.key==="vampiric") ? 0.03 : 0.0,
      enemySpite: mods.some(m=>m.key==="spiteful") ? 0.04 : 0.0,
      mysticLoot: mods.some(m=>m.key==="mystic") ? 0.15 : 0.0,
      swift: mods.some(m=>m.key==="swift") ? 0.12 : 0.0,
      goldMul, xpMul, karmaKill,
    };
  }

  // --------------------
  // Loot
  // --------------------
  function rollRarity(luckFactor, rarityBoost){
    const boosted = RAR.map(r => {
      let w = r.w;
      if (r.key !== "common") w *= (0.92 + 0.18*luckFactor) * (1 + rarityBoost);
      if (r.key === "common") w *= (1.10 - 0.10*(luckFactor-1));
      return { ...r, w: Math.max(0.01, w) };
    });
    return pickWeighted(boosted, "w");
  }

  function scaleStats(statObj, ilv, mult){
    const s = {};
    for (const [k,v] of Object.entries(statObj)){
      if (k==="crit" || k==="spd" || k==="lifesteal" || k==="thorns" || k==="regen" || k==="goldBonus" || k==="xpBonus" || k==="dmgMult" || k==="dr" || k==="execute" || k==="shred"){
        const bump = (ilv * 0.0005) * (mult - 0.9);
        if (k==="execute" || k==="shred") s[k] = clamp(v + bump, 0, 0.35);
        else if (k==="dr") s[k] = clamp(v + bump*0.9, 0, 0.60);
        else s[k] = v + bump;
      } else if (k==="luck"){
        s[k] = Math.round((v + ilv/10) * mult);
      } else {
        s[k] = Math.round((v * mult) + (ilv * (k==="hp"? 2.5 : 1.05)) * mult);
      }
    }
    return s;
  }

  function rollUniqueAffCount(heroLuck, rarityBoost){
    // 六印の欠片付与数: 最大8。高付与は妙品。
    // 縁60超は「付与数」だけに効く（logで逓減、上限あり）。
    const luck = Math.max(0, Number(heroLuck || 0));
    const over = Math.max(0, luck - 60);
    const boost = clamp(1 + (Math.log1p(over) / 20) + (Number(rarityBoost || 0) * 0.08), 1, 1.65);

    // 基分布（%）: 1〜3が中心、6+は激妙品。8は超妙品。
    const base = [
      {c:1, w:59.95},
      {c:2, w:25.00},
      {c:3, w:10.00},
      {c:4, w: 3.50},
      {c:5, w: 1.00},
      {c:6, w: 0.35},
      {c:7, w: 0.12},
      {c:8, w: 0.08},
    ].map(o => ({ c:o.c, w: o.w * Math.pow(boost, o.c - 1) }));

    return pickWeighted(base, 'w').c;
  }

  function makeItem(ilv, luckFactor, heroLuck, rarityBoost){
    const slot = choice(SLOT_ORDER);
    const rar = rollRarity(luckFactor, rarityBoost);

    if (rar.key === "unique"){
      const pool = UNIQUES.filter(x => x.slot === slot);
      const u = choice(pool);

      // Unique: 固有固定値 + 妙品倍率（RAR.unique.mult）を適用して“ちゃんと強い”にする
      let merged = scaleStats(u.fixed, ilv, rar.mult);

      // Unique: 固有主題は固定しつつ、付与は最大8（高付与は激妙品）
      const used = new Set();
      const affCount = clamp(rollUniqueAffCount(heroLuck, rarityBoost), 1, 8);
      let lines = [];
      for (let i=0;i<affCount;i++){
        const a = pickWeighted(AFFIX, "w");
        if (used.has(a.key)) { i--; continue; }
        used.add(a.key);
        const before = merged[a.key] || 0;
        const add = a.apply(before, ilv);
        merged = { ...merged, ...add };
        lines.push(a.name);
      }

      const desc = u.desc + (lines.length ? ` / 付与: ${lines.join("、")}` : "");
      return { id: safeUUID(), slot, ilv, rarity:"unique", name:u.name, stats: merged, desc, t: now() };
    }

    const tmpl = slot === "weapon" ? choice(WEAPONS) : slot === "armor" ? choice(ARMORS) : choice(ACCS);
    const stats = scaleStats(tmpl.stat, ilv, rar.mult);

    const affCount = rar.aff;
    const used = new Set();
    let lines = [];
    let merged = { ...stats };
    for (let i=0;i<affCount;i++){
      const a = pickWeighted(AFFIX, "w");
      if (used.has(a.key)) { i--; continue; }
      used.add(a.key);
      const before = merged[a.key] || 0;
      const add = a.apply(before, ilv);
      merged = { ...merged, ...add };
      lines.push(a.name);
    }

    const prefix =
      rar.key==="legendary" ? choice(["神話の","破滅の","輝く","古代の","王の"]) :
      rar.key==="epic" ? choice(["魔導の","黒羽の","紫の","嵐の","聖なる"]) :
      rar.key==="rare" ? choice(["上質な","鋭い","縁起の","迅速な","不屈の"]) :
      rar.key==="uncommon" ? choice(["頑丈な","切れ味の良い","きらめく","軽量の"]) :
      "";

    const fullName = prefix ? `${prefix}${tmpl.base}` : tmpl.base;
    return { id: safeUUID(), slot, ilv, rarity: rar.key, name: fullName, stats: merged, desc: lines.length ? `付与: ${lines.join("、")}` : "", t: now() };
  }

  function rarScore(k){ return ({common:0,uncommon:1,rare:2,epic:3,legendary:4,unique:5}[k] ?? 0); }

  function itemPower(it){
    const st = it.stats || {};
    const atk = st.atk||0, def = st.def||0, hp = st.hp||0;
    const crit = st.crit||0, spd = st.spd||0, luck=st.luck||0;
    const ls = st.lifesteal||0, th = st.thorns||0;
    const regen = st.regen||0;
    const gb = st.goldBonus||0, xb=st.xpBonus||0;
    const dm = st.dmgMult||0, dr=st.dr||0;
    const ex = st.execute||0, sh=st.shred||0;
    return (atk*2.3 + def*1.7 + hp*0.40 + crit*160 + spd*95 + luck*7
            + ls*140 + th*110 + regen*240 + gb*140 + xb*140 + dm*180 + dr*220 + ex*180 + sh*160)
            + rarScore(it.rarity)*42 + (it.ilv||1)*2.4;
  }

  // --------------------
  // Progression
  // --------------------
  function expNeed(lv){
    const a = 50 + Math.pow(lv, 1.50) * 16;
    const b = Math.pow(lv, 1.80) * 0.14;
    return Math.round(a + b);
  }

  function damage(att, def){
    const k = 1.35;
    return Math.max(1, Math.round((att*att) / (att + k*def)));
  }

  function grantExp(amount){
    const h = S.hero;
    h.exp += amount;
    let guard = 0;
    while (true){
      const need = expNeed(h.lv);
      if (!Number.isFinite(need) || need <= 0) break;
      if (h.exp < need) break;
      h.exp -= need;
      h.lv += 1;
      logImportant(`<span class="good">昇位！</span> 位 ${fmt(h.lv)}`);
      // 位上昇加持は無し（難易度調整）
      guard += 1;
      if (guard > 2000){
        log(`<span class="warn">警策</span>: 位計算が長すぎるため中断しました。`);
        break;
      }
    }
    dirtyHUD = true;
  }

  // --------------------
  // Combat / Loop
  // --------------------
  function sanitizeRuntime(){
    const h = S.hero;
    const r = S.run;

    // hero numbers
    h.lv = clamp(int0(h.lv, 1), 1, MAX_LV);
    h.exp = Math.max(0, int0(h.exp, 0));
    h.gold = Math.max(0, int0(h.gold, 0));
    h.hpMax = Math.max(1, num(h.hpMax, 150));
    h.hp = clamp(num(h.hp, h.hpMax), 0, h.hpMax);

    h.lock = h.lock ?? { weapon:false, armor:false, accessory:false };
    for (const s of ['weapon','armor','accessory']) h.lock[s] = !!h.lock[s];

    // base / guild (old記録で文字列やNaNが混じっても復旧)
    h.base = h.base ?? { str:0, vit:0, def:0, luck:0 };
    h.base.str = Math.max(0, int0(h.base.str, 0));
    h.base.vit = Math.max(0, int0(h.base.vit, 0));
    h.base.def = Math.max(0, int0(h.base.def, 0));
    h.base.luck= Math.max(0, int0(h.base.luck,0));

    h.guild = h.guild ?? { forge:0, bounty:0, library:0, shrine:0 };
    h.guild.forge = Math.max(0, int0(h.guild.forge, 0));
    h.guild.bounty = Math.max(0, int0(h.guild.bounty,0));
    h.guild.library= Math.max(0, int0(h.guild.library,0));
    h.guild.shrine = Math.max(0, int0(h.guild.shrine,0));

    // run numbers
    r.floor = Math.max(1, int0(r.floor, 1));
    r.room  = Math.max(1, int0(r.room,  1));
    r.roomsPerFloor = Math.max(1, int0(r.roomsPerFloor, 30));
    
// speed preset: 1 / 2 / 4 / 8 / MAX
// （旧記録の 0.05 / 0.1 / 0.25 / 16 / 32 / 256 などは安全にスナップ）
const _spMax = SPEED_MAX_LABEL;
const _spRaw = num(r.speed, 1);

// Old saves: if speed < 1, treat it as the new 1× (readable baseline).
let _sp = _spRaw;
if (_sp < 0.5) _sp = 1;
// Old MAX (256) or any very large number => MAX label
if (_sp >= 200) _sp = _spMax;

// Snap to nearest allowed label
let best = SPEED_ALLOWED[0];
let bestD = Math.abs(_sp - best);
for (const cand of SPEED_ALLOWED){
  const d = Math.abs(_sp - cand);
  if (d < bestD){ best = cand; bestD = d; }
}

// Gate MAX until the Mandala ledger has all six fragments.
try{
  if (best === _spMax && !hasAllSixFragments()){
    best = Math.max(...SPEED_ALLOWED.filter(v => v < _spMax));
  }
}catch(_){
  if (best === _spMax) best = Math.max(...SPEED_ALLOWED.filter(v => v < _spMax));
}
r.speed = clamp(best, 1, _spMax);
    r.lastTick = num(r.lastTick, now());
    r._acc = num(r._acc, 0);
    r._heroCd = num(r._heroCd, 0);
    r._enemyCd = num(r._enemyCd, 0);
    r._roomTime = num(r._roomTime, 0);
    r.entryShield = Math.max(0, num(r.entryShield, 0));
    r.entryShieldDR = clamp(num(r.entryShieldDR, 0.45), 0.30, 0.95);
    r._cheatCd = Math.max(0, num(r._cheatCd, 0));
    r._invuln  = Math.max(0, num(r._invuln,  0));

    // enemy hp sanity（NaN/0で止まるのを防ぐ）
    if (r.enemy){
      const ehpMaxRaw = r.enemyHpMax;
      const ehpRaw = r.enemyHp;

      let ehpMax = num(ehpMaxRaw, 0);
      if (!Number.isFinite(ehpMax) || ehpMax <= 0){
        const base = num(r.enemy.hp, 1);
        ehpMax = base > 0 ? base : 1;
        r.enemyHpMax = ehpMax;
      }

      if (!Number.isFinite(Number(ehpRaw))){
        // 命がNaNになって固まる例：命を最大に戻して続行
        r.enemyHp = ehpMax;
        if (!r._enemyHpRecoverLogged){
          try{ log(`<span class="warn">復旧</span>: 魔命が壊れていたため復元しました`); } catch{}
          r._enemyHpRecoverLogged = true;
          dirtyLog = true;
        }
      } else {
        const ehp = num(ehpRaw, ehpMax);
        if (ehp <= 0 && ehpMax > 0){
          // 「魔が居るのに命0」で詰む例：魔を再生成
          r.enemy = null;
          r.enemyHp = 0;
          r.enemyHpMax = 0;
          r.isBoss = false;
          r.isElite = false;
          r.mods = [];
          r._roomTime = 0;
          if (!r._enemyZeroRecoverLogged){
            try{ log(`<span class="warn">復旧</span>: 調伏状態が壊れていたため、魔を再配置しました`); } catch{}
            r._enemyZeroRecoverLogged = true;
            dirtyLog = true;
          }
          dirtyHUD = true;
        } else {
          r.enemyHp = clamp(ehp, 0, ehpMax);
          r.enemyHpMax = ehpMax;
        }
      }
    } else {
      r.enemyHp = num(r.enemyHp, 0);
      r.enemyHpMax = num(r.enemyHpMax, 0);
    }
  }

  function ensureEnemy(){
    const r = S.run;
    if (!r.enemy){
      const e = enemyFor(r.floor, r.room, S.hero.lv);
      try{ if (e && e.realmKey) touchRealm(e.realmKey); }catch(_){ }
      r.enemy = e;
      r.enemyHp = e.hp;
      r.enemyHpMax = e.hp;

      if (r.reviveGraceRooms && r.reviveGraceRooms>0) r.reviveGraceRooms--;
      r.isBoss = e.isBoss;
      r.isElite = e.isElite;
      r.mods = e.mods || [];
      r._roomTime = 0;
      r._lastEnemyHp = r.enemyHp;

      // vBattleLog+: reset aggregated combat log when a new enemy appears (avoid stale enemy names)
      resetBattleAgg();

      const modText = r.mods.length ? ` <span class="warn">[${modsHtml(r.mods)}]</span>` : "";
      const eliteText = e.isElite ? ` <span class="gold">（重煩）</span>` : "";
      const bossText = e.isBoss ? ` <span class="rare">（根本）</span>` : "";
      const hpNow0 = fmt(Math.max(0, Math.round(S.hero.hp)));
      const hpMax0 = fmt(Math.round(S.hero.hpMax));
      log(`現前: <span class="${e.isBoss?'rare':''}">${dispEnemyName(e.name)}</span>${eliteText}${bossText}${modText} (戦利品位 ${fmt(e.ilv)} / 命 ${hpNow0}/${hpMax0})`);
      dirtyHUD = true;
    }
  }

  function startExplore(){
    if (S.hero.dead) return;
    S.run.active = true;
    S.run.lastTick = now();
    try{
      const b = biomeForFloor(S.run.floor);
      if (b && maybeRealmPrologue(b.key, b.name)) { save(); dirtyHUD = true; return; }
    }catch(_){ }
    ensureEnemy();
    save();
    dirtyHUD = true;
  }
  function pauseExplore(){ S.run.active = false; save(); dirtyHUD = true; }

  function nextRoom(force=false){
    if (S.hero.dead) return;
    const r = S.run;
    if (!force && r.enemy && r.enemyHp > 0) return;

    r.history = Array.isArray(r.history) ? r.history : [];
    r.history.push({ floor:r.floor, room:r.room });
    if (r.history.length > 60) r.history.shift();

    // 入室準備（短い安全時間のみ：加持は無し）
    r.entryShield = 1.2; // 秒

    r.room += 1;
    if (r.room > r.roomsPerFloor){
      r.floor += 1;
      r.room = 1;
      logImportant(`<span class="good">層 ${r.floor}</span> に到達。六道: ${biomeForFloor(r.floor).name}`);
    }
    r.enemy = null;
    r.enemyHp = 0;
    r.enemyHpMax = 0;

    // 界門（章）: 初入界の導入
    try{
      const b = biomeForFloor(r.floor);
      if (b && maybeRealmPrologue(b.key, b.name)) { save(); dirtyHUD = true; return; }
    }catch(_){ }

    // 密教儀礼（儀礼）
    if (maybeTriggerEvent()){ save(); dirtyHUD = true; return; }

    ensureEnemy();
    save();
    dirtyHUD = true;
  }

  function prevRoom(){
    if (S.hero.dead) return;
    const r = S.run;
    r.history = Array.isArray(r.history) ? r.history : [];
    if (!r.history.length){
      log(`<span class="warn">戻れません</span>: これ以上、前の間へは戻れません。`);
      dirtyLog = true;
      return;
    }
    const prev = r.history.pop();
    r.floor = Math.max(1, Math.floor(prev.floor || 1));
    r.room = Math.max(1, Math.floor(prev.room || 1));
    // 戻った直後の短い安全時間のみ：加持は無し
    r.entryShield = 0.9;

    r.enemy = null;
    r.enemyHp = 0;
    r.enemyHpMax = 0;

    // 界門（章）: 初入界の導入
    try{
      const b = biomeForFloor(r.floor);
      if (b && maybeRealmPrologue(b.key, b.name)) { save(); dirtyHUD = true; return; }
    }catch(_){ }

    // 密教儀礼（儀礼）
    if (maybeTriggerEvent()){ save(); dirtyHUD = true; return; }

    ensureEnemy();
    save();
    dirtyHUD = true;
  }


  function maybeAutoEquip(item){
    const slot = item.slot;
    const cur = S.gear[slot];
    if (S.hero && S.hero.lock && S.hero.lock[slot] && cur){ return; }
    if (!cur) return equip(item.id);

    // 自動加持の功徳点計算では、縁60超は過大評価しない（授与縁の上限に合わせる）。
    // ※縁60超の価値は『六印の欠片付与数』側で味わえるので、ここでは到達分だけ評価する。
    let curTotalLuck = (S.hero.base && S.hero.base.luck) ? S.hero.base.luck : 0;
    for (const s of SLOT_ORDER){
      const it = S.gear[s];
      if (it && it.stats && it.stats.luck) curTotalLuck += it.stats.luck;
    }
    const curLuck = (cur && cur.stats && cur.stats.luck) ? cur.stats.luck : 0;
    const candLuck = (item && item.stats && item.stats.luck) ? item.stats.luck : 0;

    const otherLuck = curTotalLuck - curLuck;
    const capSpace = Math.max(0, 60 - otherLuck);
    const curEffLuck = Math.min(curLuck, capSpace);
    const candEffLuck = Math.min(candLuck, capSpace);

    const curScore  = itemPower(cur)  - curLuck*7  + curEffLuck*7;
    const candScore = itemPower(item) - candLuck*7 + candEffLuck*7;

    if (candScore > curScore * 1.12){
      equip(item.id);
      log(`<span class="good">自動加持</span>: ${SLOT_NAME[slot]}を更新`);
    }
  }

  function shouldAutoSell(item){
    const ui = S.ui || {};
    if (!(Number(ui.autoSellOn) === 1)) return false;

    const maxR = (ui.autoSellRarMax != null) ? String(ui.autoSellRarMax) : "common";
    const protectUnique = !(Number(ui.autoSellProtectUnique) === 0);
    if (protectUnique && item.rarity === "unique" && maxR !== "unique") return false;

    const useEq = (Number(ui.autoSellUseEq) === 1);
    const eqPct = clamp(num(ui.autoSellEqPct, 90), 1, 100) / 100;

    let match = false;

    if (maxR && maxR !== "none"){
      const a = RAR_RANK[item.rarity] ?? 0;
      const b = RAR_RANK[maxR] ?? 0;
      if (a <= b) match = true;
    }

    if (useEq){
      const cur = S.gear[item.slot];
      if (cur){
        const curScore = itemPower(cur);
        const candScore = itemPower(item);
        if (candScore < curScore * eqPct) match = true;
      }
    }

    return match;
  }

  function dropLoot(ilv, st, e){
    const gB = st.gB;
    // reset aggregated auto-sell counters for this drop batch
    S.run._autoSoldN = 0;
    S.run._autoSoldG = 0;
    ensureMikkyoFields();
    const karma = clampKarma(S.hero.karma||0);
    const karmaPos = Math.max(0, karma), karmaNeg = Math.max(0, -karma);
    const satori = Math.max(0, Math.floor(S.hero.satori||0));
    let count = 0;
    const base = e.isBoss ? 1 : (Math.random() < 0.52 ? 1 : 0);
    count += base;
    if (e.isElite && Math.random() < 0.70) count += 1;
    if (Math.random() < clamp((st.luckFactor-1)*0.30, 0, 0.40)) count += 1;
    if (Math.random() < clamp(satori/150000, 0, 0.12)) count += 1;
    // 五毒「貪」: 追加授与（欲は報酬を呼ぶが、業も増える）
    if (e && e.modKeys && e.modKeys.includes("greed") && Math.random() < 0.78) count += 1;

    const extraRolls = Math.floor(gB.lootMult - 1);
    for (let i=0;i<extraRolls;i++) if (Math.random() < 0.52) count += 1;
    if (Math.random() < (gB.lootMult - 1 - extraRolls)) count += 1;

    const dropCap = (e.isBoss ? 5 : 3) + ((e && e.modKeys && e.modKeys.includes("greed")) ? 1 : 0);
    count = clamp(count, 0, dropCap);
    const itemIlv = ilv + gB.dropIlv + (e.isBoss ? 2 : 0) + (e.isElite ? 1 : 0);
    const karmBoost = (karmaPos/108)*0.05 - (karmaNeg/108)*0.03;
    const satBoost = Math.min(0.06, satori/60000);
    const rarityBoost = gB.rarityBoost + (e.mysticLoot || 0) + (st.rarityExtra || 0) + karmBoost + satBoost;

    for (let i=0;i<count;i++){
      const it = makeItem(itemIlv, st.luckFactor, st.luck, rarityBoost);
      if (it && it.rarity === "unique"){
        const rk = biomeForFloor(S.run.floor).key;
        applySealToUnique(it, rk);
        grantSealFragment(rk);
      }
      S.inv.push(it);
      const rarName = RAR.find(r=>r.key===it.rarity)?.name ?? it.rarity;
      const rarTag = (it.rarity === "unique") ? "★六印欠片" : rarName;
      log(`加持: <span class="rar ${it.rarity}">${rarTag}</span> ${SLOT_NAME[it.slot]}「${dispItemName(it)}」`);
      maybeAutoEquip(it);
      if (it.rarity === "unique"){ try{ ensureMikkyoFields(); S.hero.codex.uniques = (S.hero.codex.uniques||0) + 1; }catch(_){ } }

      // Auto-sell (instant) if enabled and the dropped item is still in inventory (i.e., not equipped)
      if (S.inv.findIndex(x=>x.id===it.id) >= 0 && shouldAutoSell(it)){
        const idx = S.inv.findIndex(x=>x.id===it.id);
        if (idx >= 0){
          const soldIt = S.inv[idx];
          const rar = RAR.find(r=>r.key===soldIt.rarity) ?? RAR[0];
          const base = 8 + (soldIt.ilv||1) * 2.7;
          const price = Math.round(base * rar.sell);
          S.hero.gold += price;
          S.inv.splice(idx, 1);
          // aggregate log to reduce spam
          S.run._autoSoldN = (S.run._autoSoldN||0) + 1;
          S.run._autoSoldG = (S.run._autoSoldG||0) + price;
        }
      }
    }

    if (S.run._autoSoldN){
      const n = S.run._autoSoldN || 0;
      const g = S.run._autoSoldG || 0;
      log(`<span class="warn">自動布施</span>: ${n}個 <span class="gold">(+${fmt(g)}功徳)</span>`);
      dirtyHUD = true;
    }

    if (S.inv.length > 900){
      autoTrimInventory();
    }
    dirtyInv = true;
  }

  function autoTrimInventory(){
    let target = 700;
    if (S.inv.length <= target) return;
    let sold = 0, got = 0;
    const low = S.inv.filter(it => it.rarity==="common" || it.rarity==="uncommon");
    low.sort((a,b)=> itemPower(a)-itemPower(b));
    const toSell = [];
    for (const it of low){
      if (S.inv.length - toSell.length <= target) break;
      toSell.push(it);
    }
    if (!toSell.length){
      const all = S.inv.slice().sort((a,b)=> itemPower(a)-itemPower(b));
      for (const it of all){
        if (S.inv.length - toSell.length <= target) break;
        toSell.push(it);
      }
    }
    const set = new Set(toSell.map(x=>x.id));
    const keep = [];
    for (const it of S.inv){
      if (set.has(it.id)){
        const rar = RAR.find(r=>r.key===it.rarity) ?? RAR[0];
        const base = 8 + (it.ilv||1) * 2.7;
        const price = Math.round(base * rar.sell);
        got += price; sold++;
      } else keep.push(it);
    }
    S.inv = keep;
    S.hero.gold += got;
    log(`<span class="warn">自動整理</span>: 法具庫肥大化のため${sold}個を布施 <span class="gold">(+${fmt(got)}功徳)</span>`);
    dirtyInv = true; dirtyHUD = true;
  }

  // --------------------
  // Battle detail log (vBattleLog+)
  // --------------------
  function heroDispName(){
    const n = (S.hero && typeof S.hero.name==="string" && S.hero.name.trim()) ? S.hero.name.trim() : "行者";
    return n;
  }
  function weaponDispName(){
    try{
      const w = S && S.gear && S.gear.weapon;
      return w ? dispItemName(w) : "素手";
    } catch(_){
      return "素手";
    }
  }
  function enemyAtkName(e){
    const rk = (e && e.realmKey) ? e.realmKey : "";
    const base = {
      hell:["瞋火撃","業爪","熱悩の息","業火の鎖"],
      hungry:["渇愛噬","渇牙","怨嚙み","渇愛の呪唾"],
      animal:["無明噛み","無明角","毒牙","猛躍"],
      asura:["闘諍斬","戦輪撃","鬼槌","羅刹の連撃"],
      human:["分別突き","呪矢","妄執呪詛","奪命の手"],
      deva:["有頂雷","風刃","天槍","光輪"],
    };
    const list = base[rk] || ["闇撃","呪撃","裂傷"];
    let name = choice(list);
    const mk = (e && e.modKeys) ? e.modKeys : [];
    if (mk.includes("anger")) name = "激昂" + name;
    else if (mk.includes("envy")) name = "奪功徳" + name;
    else if (mk.includes("greed")) name = "貪欲" + name;
    else if (mk.includes("pride")) name = "傲慢" + name;
    else if (mk.includes("ignorance")) name = "朦朧" + name;
    if (e && e.isBoss) name += "・奥義";
    return name;
  }
  function resetBattleAgg(){
    try{
      const r = S.run;
      r._battleAgg = null;
      r._battleAggEnemy = null;
      r._battleLogCd = 0;
    } catch(_){}
  }
  function battleAggEnsure(e){
    const r = S.run;
    if (!r._battleAgg || r._battleAggEnemy !== e){
      r._battleAggEnemy = e;
      r._battleAgg = {
        heroName: heroDispName(),
        weaponName: weaponDispName(),
        enemyName: e ? dispEnemyName(e.name) : "魔",
        heroHits:0, heroDmg:0, heroCrit:0, heroMax:0, heroHeal:0, heroSelfDmg:0, selfBefore:NaN, selfAfter:NaN,
        enemyHits:0, enemyDmg:0, enemyMax:0, shieldHits:0, spiteDmg:0,
        thornsDmg:0, enemyHeal:0, atkNames:[],
      };
      r._battleLogCd = Number.isFinite(r._battleLogCd) ? r._battleLogCd : 0;
    }
    // refresh labels (gear/name can change mid-fight)
    try{ r._battleAgg.heroName = heroDispName(); r._battleAgg.weaponName = weaponDispName(); if (e) r._battleAgg.enemyName = dispEnemyName(e.name); } catch(_){ }
    return r._battleAgg;
  }
  function pushUnique(arr, v, limit=3){
    if (!v) return;
    if (arr.indexOf(v) >= 0) return;
    if (arr.length < limit) arr.push(v);
  }
  function flushBattleAgg(force){
    const r = S.run;
    const agg = r._battleAgg;
    if (!agg) return;
    if (!force && (r._battleLogCd || 0) > 0) return;
    // heroSelfDmgだけ発生するケース（慢の返業など）もある
    if (!(agg.heroHits || agg.enemyHits || agg.heroSelfDmg)) return;
    // MAX speed / 迅行MAX: never build combat-detail log strings (heavy).
    if (isLogLite()){
      // Clear the accumulator quickly and skip rendering.
      r._battleAgg = null;
      r._battleAggEnemy = null;
      // Keep a small cooldown so callers won't keep trying to flush immediately.
      r._battleLogCd = 0.35;
      _logLiteBump();
      return;
    }


    const hpNow = fmt(Math.max(0, Math.round(S.hero.hp)));
    const hpMax = fmt(Math.round(S.hero.hpMax));
    const hasEnemyHP = (r.enemyHpMax > 0);
    const ehpNow = hasEnemyHP ? fmt(Math.max(0, Math.round(r.enemyHp))) : "";
    const ehpMax = hasEnemyHP ? fmt(Math.round(r.enemyHpMax)) : "";

    // vBattleLog+: show actual HP change for 返業 (clamped to min 1), and keep the raw 返業値 as note when they differ
    const selfLoss = (agg.heroSelfDmg && Number.isFinite(agg.selfBefore) && Number.isFinite(agg.selfAfter))
      ? Math.max(0, Math.round(agg.selfBefore - agg.selfAfter))
      : 0;
    const selfNote = (agg.heroSelfDmg && selfLoss && Math.abs(selfLoss - agg.heroSelfDmg) > 1)
      ? ` <span class="mutedTxt">(返業値${fmt(agg.heroSelfDmg)} / 下限適用)</span>`
      : "";

    // ---- lines（見やすいように分解）
    let heroLine = "";
    if (agg.heroHits){
      heroLine = `<span class="good">降魔</span> ${agg.heroName}「${agg.weaponName}」×${agg.heroHits} 合計${fmt(agg.heroDmg)} 苦`
        + (agg.heroCrit ? `（<span class="rare">破魔</span> ${agg.heroCrit}）` : "")
        + (agg.heroHeal ? ` / <span class="good">吸命</span>+${fmt(agg.heroHeal)}` : "")
        + `（最大一撃${fmt(agg.heroMax)}）`;
    }

    let selfLine = "";
    if (agg.heroSelfDmg){
      selfLine = `<span class="warn">返業</span> 命 ${fmt(agg.selfBefore)}→${fmt(agg.selfAfter)} (-${fmt(selfLoss)})${selfNote}`
        + (agg.heroMax ? ` <span class="mutedTxt">(最大一撃${fmt(agg.heroMax)})</span>` : "");
    }

    let enemyLine = "";
    if (agg.enemyHits){
      const atk = agg.atkNames.length ? agg.atkNames.join(" / ") : "降魔";
      enemyLine = `<span class="bad">魔撃</span> ${agg.enemyName}「${atk}」×${agg.enemyHits} 合計${fmt(agg.enemyDmg)} 苦`
        + (agg.spiteDmg ? ` / <span class="warn">追撃</span>+${fmt(agg.spiteDmg)}` : "")
        + (agg.thornsDmg ? ` / <span class="good">返苦</span>${fmt(agg.thornsDmg)}` : "")
        + (agg.enemyHeal ? ` / <span class="warn">回復</span>+${fmt(agg.enemyHeal)}` : "")
        + (agg.shieldHits ? ` <span class="good">結界</span>` : "")
        + `（最大一撃${fmt(agg.enemyMax)}）`;
    }

    const statusLine = hasEnemyHP
      ? `命 ${hpNow}/${hpMax} / 魔命 ${ehpNow}/${ehpMax}`
      : `命 ${hpNow}/${hpMax}`;

    let detailParts = [];
    try{
      if (agg.lastEnemy && Number.isFinite(agg.lastEnemy.hpBefore)){
        detailParts.push(`被弾 命 ${fmt(agg.lastEnemy.hpBefore)}→${fmt(agg.lastEnemy.hpAfter)} (-${fmt(agg.lastEnemy.dmg)})`);
      }
      if (hasEnemyHP && agg.lastHero && Number.isFinite(agg.lastHero.ehpBefore)){
        detailParts.push(`降魔 魔命 ${fmt(agg.lastHero.ehpBefore)}→${fmt(agg.lastHero.ehpAfter)} (-${fmt(agg.lastHero.dmg)})`);
      }
    }catch(_){ detailParts = []; }

    const lines = [];
    if (heroLine) lines.push(heroLine);
    if (selfLine) lines.push(selfLine);
    if (enemyLine) lines.push(enemyLine);

    // ドラクエ風：だれが→なにをした→結果（ダメージ/回復）を文章で出す
    const dq = [];

    if (agg.heroHits){
      const n = agg.heroName || "行者";
      const target = agg.enemyName || "敵";
      dq.push(`<span class="good">${n}</span>の攻撃！`);
      const tail = (agg.heroHits > 1)
        ? ` <span class="mutedTxt">(${agg.heroHits}回 / 最大${fmt(agg.heroMax)})</span>`
        : ` <span class="mutedTxt">(最大${fmt(agg.heroMax)})</span>`;
      dq.push(`<span class="indent">${target}に${fmt(agg.heroDmg)}のダメージ！</span>` + tail);
      if (agg.heroCrit){
        dq.push(`<span class="indent"><span class="rare">会心の一撃！</span> ×${fmt(agg.heroCrit)}</span>`);
      }
      if (agg.heroHeal){
        dq.push(`<span class="indent">${n}は${fmt(agg.heroHeal)}回復した。</span>`);
      }
    }

    if (agg.heroSelfDmg){
      const n = agg.heroName || "行者";
      dq.push(`<span class="warn">${n}は業の反動を受けた…</span>`);
      dq.push(`<span class="indent">${n}は${fmt(selfLoss)}のダメージを受けた。</span>${selfNote}`);
    }

    if (agg.enemyHits){
      const enemy = agg.enemyName || "敵";
      const hero  = agg.heroName || "行者";
      const atk = agg.atkNames.length ? agg.atkNames.join(" / ") : "攻撃";
      dq.push(`<span class="bad">${enemy}</span>の攻撃！ <span class="mutedTxt">「${atk}」</span>`);
      const tail = (agg.enemyHits > 1)
        ? ` <span class="mutedTxt">(${agg.enemyHits}回 / 最大${fmt(agg.enemyMax)})</span>`
        : ` <span class="mutedTxt">(最大${fmt(agg.enemyMax)})</span>`;
      dq.push(`<span class="indent">${hero}は${fmt(agg.enemyDmg)}のダメージを受けた！</span>` + tail);

      if (agg.shieldHits){
        dq.push(`<span class="indent"><span class="good">結界</span>がダメージを軽減した！</span>`);
      }
      if (agg.spiteDmg){
        dq.push(`<span class="indent"><span class="warn">追撃</span>で追加${fmt(agg.spiteDmg)}ダメージ！</span>`);
      }
      if (agg.thornsDmg){
        dq.push(`<span class="indent"><span class="good">反撃</span>！${enemy}に${fmt(agg.thornsDmg)}のダメージ！</span>`);
      }
      if (agg.enemyHeal){
        dq.push(`<span class="indent">${enemy}は${fmt(agg.enemyHeal)}回復した。</span>`);
      }
    }
    let msg = dq.join("<br>");
    log(msg);

    // reset counters but keep labels
    agg.heroHits=0; agg.heroDmg=0; agg.heroCrit=0; agg.heroMax=0; agg.heroHeal=0; agg.heroSelfDmg=0; agg.selfBefore=NaN; agg.selfAfter=NaN;
    agg.enemyHits=0; agg.enemyDmg=0; agg.enemyMax=0; agg.shieldHits=0; agg.spiteDmg=0;
    agg.thornsDmg=0; agg.enemyHeal=0; agg.atkNames.length=0;

    // reset last-hit details
    agg.lastHero = null;
    agg.lastEnemy = null;

    r._battleLogCd = 0.22; // seconds (real-time)
    dirtyLog = true;
  }

  function tick(dt){
    const r = S.run;
    if (!r.active) return;
    if (S.hero.dead) { r.active=false; dirtyHUD=true; return; }

    ensureEnemy();
    const e = r.enemy;
    const st = calcStatsFast();

    // Cache: is attack-speed (迅行) at cap? used for log-lite mode.
    r._spdIsMax = (Number(st.spd) >= (2.75 - 1e-6));


    // vBattleLog+: throttle combat detail logs by real time (dt is simulated)
    const spdNow = effectiveSimSpeedScaled(r.speed);
    const realDt = dt / Math.max(1e-6, spdNow);
    r._battleLogCd = Math.max(0, (Number.isFinite(r._battleLogCd) ? r._battleLogCd : 0) - realDt);
    battleAggEnsure(e);

    r._roomTime = Number.isFinite(r._roomTime) ? r._roomTime : 0;
    r._roomTime += dt;

    // cd 安定化
    r._heroCd = Number.isFinite(r._heroCd) ? r._heroCd : 0;
    r._enemyCd = Number.isFinite(r._enemyCd) ? r._enemyCd : 0;
    r.entryShield = Math.max(0, (r.entryShield || 0) - dt);

    // v9: 致死回避/無魔の時計更新
    r._cheatCd = Number.isFinite(r._cheatCd) ? r._cheatCd : 0;
    r._invuln  = Number.isFinite(r._invuln)  ? r._invuln  : 0;
    r._cheatCd = Math.max(0, r._cheatCd - dt);
    r._invuln  = Math.max(0, r._invuln  - dt);

    if (st.regen > 0){
      S.hero.hp = clamp(S.hero.hp + (st.regen * S.hero.hpMax * dt), 1, S.hero.hpMax);
    }

    r._heroCd = (r._heroCd ?? 0) - dt;
    r._enemyCd = (r._enemyCd ?? 0) - dt;

    // 降魔速度が極端に上がると、1tick内の輪転回数が爆増して閲覧器が固まるため上限を設ける
    const cappedSpd = clamp(st.spd, 0.2, 20);
    if (cappedSpd != st.spd && !r._spdCapLogged){
      logImportant(`<span class="warn">負荷対策</span>: 降魔の迅行が高すぎるため、処理上限（20回/秒）を適用しました`);
      r._spdCapLogged = true;
      dirtyLog = true;
    }
    const heroInterval = 1 / cappedSpd;
    const enemyBaseInterval = e.isBoss ? 1.00 : 1.25;
    const enemyInterval = clamp(enemyBaseInterval * (1 - e.swift), 0.50, 2.00);

    const MAX_ACTS_PER_TICK = isSpeedMax() ? 60 : 120;
    let heroActs = 0;
    while (r._heroCd <= 0 && r.enemyHp > 0 && !S.hero.dead){
      if (++heroActs > MAX_ACTS_PER_TICK){
        // 残りは次tickに回して固まりを防ぐ
        r._heroCd = heroInterval;
        if (!r._actsCapLogged){
          if (!isLogLite()) log(`<span class="warn">負荷対策</span>: 1更新内の降魔回数が多すぎるため、一部を次更新に回しました（迅行を下げると安定）`);
          r._actsCapLogged = true;
          dirtyLog = true;
        }
        break;
      }

      r._heroCd += heroInterval;

      e.defMul = Math.max(0.45, e.defMul * 0.995);
      // 五毒「貪」: 叩くほど守りを固める（授与は甘い）
      if (e && e.modKeys && e.modKeys.includes("greed") && Math.random() < 0.14){
        e.defMul = clamp(e.defMul + 0.012, 0.45, 1.25);
        if (Math.random() < 0.06) if (!isLogLite()) log(`<span class="warn">貪</span>: 持戒を固めた`);
      }

      const enemyDef = e.def * e.defMul;
      const shredMul = 1 - clamp(st.shred, 0, 0.35);
      const finalEnemyDef = enemyDef * shredMul;

      let isCrit = Math.random() < st.crit;
      const hasIgn = (e && e.modKeys && e.modKeys.includes("ignorance"));
      if (hasIgn && isCrit){ isCrit = false; if (Math.random()<0.10) if (!isLogLite()) log(`<span class="warn">痴</span>: 破魔が封印された`); }
      let att = st.atk * st.dmgFactor;
      if (isCrit) att *= 1.6;

      let dmg = damage(att, finalEnemyDef);

      if (st.execute > 0 && r.enemyHp / r.enemyHpMax < 0.25){
        dmg = Math.round(dmg * (1 + st.execute));
      }

      if (r._roomTime > 22){
        const trueDmg = Math.max(1, Math.round(r.enemyHpMax * 0.004));
        dmg += trueDmg;
      }

      const ehpBefore = Number.isFinite(r.enemyHp) ? r.enemyHp : 0;
      r.enemyHp = Math.max(0, r.enemyHp - dmg);
      const ehpAfter = Number.isFinite(r.enemyHp) ? r.enemyHp : 0;

      
          try { if (typeof BATTLE !== 'undefined' && BATTLE) { BATTLE.heroAttack(isCrit, dmg); BATTLE.enemyHit(dmg, isCrit); } } catch (_) {}
      const aggH = battleAggEnsure(e);
      try{ aggH.lastHero = { dmg, isCrit, ehpBefore, ehpAfter }; }catch(_){ }
      aggH.heroHits++;
      aggH.heroDmg += dmg;
      aggH.heroMax = Math.max(aggH.heroMax, dmg);
      if (isCrit) aggH.heroCrit++;

      let lsHeal = 0;
      if (st.lifesteal > 0){
        lsHeal = Math.max(1, Math.round(dmg * st.lifesteal));
        S.hero.hp = clamp(S.hero.hp + lsHeal, 1, S.hero.hpMax);
      }
      if (lsHeal) aggH.heroHeal += lsHeal;

      // 五毒「慢」: 返業（致死にはしない）
      if (e && e.modKeys && e.modKeys.includes("pride") && dmg > 0){
        const ref0 = Math.max(1, Math.round(dmg * (0.10 + (e.isBoss?0.04:0))));
        const ref = Math.max(1, Math.round(ref0 * (1 - st.dr*0.5)));
        const selfBefore = Math.max(0, Math.round(S.hero.hp));
        S.hero.hp = Math.max(1, S.hero.hp - ref);
        const selfAfter  = Math.max(0, Math.round(S.hero.hp));
        try{
          aggH.heroSelfDmg += ref;
          if (!Number.isFinite(aggH.selfBefore)) aggH.selfBefore = selfBefore;
          aggH.selfAfter = selfAfter;
        }catch(_){ }
        if (Math.random() < 0.08) if (!isLogLite()) log(`<span class="warn">慢</span>: 返業 ${fmt(ref)} 苦`);
      }

      if (r.enemyHp <= 0){
        const biome = biomeForFloor(r.floor);
        const goldBase = (11 + e.ilv*2.15 + Math.pow(e.ilv, 1.05)*0.33) * (e.isBoss?2.2:1.0) * (e.isElite?1.45:1.0) * biome.loot.gold;
        const xpBase   = (15 + e.ilv*2.4 + Math.pow(e.ilv, 1.06)*0.38) * (e.isBoss?2.35:1.0) * (e.isElite?1.45:1.0) * biome.loot.xp;

        let gold = Math.round(goldBase * st.goldMult * (e.goldMul||1));
        // 五毒「貪」: さらに少しだけ功徳が増える（代わりに業が増える）
        const bonusGoldFromGreed = (e && e.modKeys && e.modKeys.includes("greed")) ? Math.round(gold * 0.12) : 0;
        gold += bonusGoldFromGreed;
        const xp   = Math.round(xpBase * st.xpMult * (e.xpMul||1));

        S.hero.gold += gold;
        grantExp(xp);
        try{ onEnemyDefeated(e, gold, xp); }catch(_){ }

        flushBattleAgg(true);
        if (!isLogLite()){
          log(`<span class="good">撃破</span>: ${e.name}（最後の降魔: ${isCrit?'<span class="rare">破魔</span> ':''}${fmt(dmg)} 苦） <span class="gold">(+${fmt(gold)}功徳)</span> (+${fmt(xp)}経験)`);
        } else {
          _logLiteBump();
        }
        // 撃破時加持は無し（難易度調整）

        dropLoot(e.ilv, st, e);

        
        try { if (typeof BATTLE !== 'undefined' && BATTLE) { BATTLE.enemyDie(); } } catch (_) {}
r.enemy = null;
        r.enemyHp = 0;
        r.enemyHpMax = 0;

        if (r.auto) nextRoom();
        break;
      }
    }

    let enemyActs = 0;
    while (r._enemyCd <= 0 && r.enemyHp > 0 && !S.hero.dead){
      if (++enemyActs > 80){
        r._enemyCd = enemyInterval;
        if (!r._enemyActsCapLogged){
          if (!isLogLite()) log(`<span class="warn">負荷対策</span>: 1更新内の魔降魔回数が多すぎるため、一部を次更新に回しました`);
          r._enemyActsCapLogged = true;
          dirtyLog = true;
        }
        break;
      }

      r._enemyCd += enemyInterval;

      // 無魔中（致死回避後など）は魔の降魔を無効化
      if ((r._invuln || 0) > 0){
        if (Math.random() < 0.05){
          if (!isLogLite()) log(`<span class="good">無魔</span>: 降魔を無効化`);
        }
        continue;
      }

      // 五毒「瞋」: 叩くほど怒りが増し、降魔が尖る
      if (e && e.modKeys && e.modKeys.includes("anger")) {
        e._rage = clamp((e._rage||0) + 1, 0, 30);
        if (e._rage <= 30) e.atk *= 1.006;
      }

      let dmg = damage(e.atk, st.def);
      dmg = Math.round(dmg * (1 - st.dr));
      if ((r.entryShield || 0) > 0){
        dmg = Math.max(0, Math.round(dmg * (1 - (r.entryShieldDR ?? 0.45))));
      }

      const hpBefore = Number.isFinite(S.hero.hp) ? S.hero.hp : 0;
      const hpAfter = hpBefore - dmg;
      const bigHit = dmg >= (S.hero.hpMax * 0.18);

      // 致死回避は無効（難易度調整）

      S.hero.hp = Math.max(0, hpAfter);

      // 五毒「嫉」: 徳吸い（少しずつ奪う。討伐で一部回収）
      if (e && e.modKeys && e.modKeys.includes("envy") && dmg > 0 && Math.random() < 0.32){
        const curG = Math.max(0, Math.floor(S.hero.gold||0));
        const steal = Math.min(curG, Math.max(1, Math.round(curG*0.004 + e.ilv*0.35)));
        S.hero.gold = Math.max(0, curG - steal);
        e._stolenGold = (e._stolenGold||0) + steal;
        if (Math.random() < 0.20) if (!isLogLite()) log(`<span class="warn">嫉</span>: 功徳を吸われた (-${fmt(steal)})`);
      }
      // 五毒「瞋」: 受苦で心が荒れ、業が傾きやすい
      if (e && e.modKeys && e.modKeys.includes("anger") && dmg > 0){
        if (Math.random() < 0.10) addKarma(-1);
}

      
      try { if (typeof BATTLE !== 'undefined' && BATTLE) { BATTLE.enemyAttack(dmg); BATTLE.heroHit(dmg); } } catch (_) {}

      let thornsDmg = 0;
      if (st.thorns > 0){
        thornsDmg = Math.max(1, Math.round(dmg * st.thorns));
        r.enemyHp = Math.max(0, r.enemyHp - thornsDmg);
      }

      let enemyHeal = 0;
      if (e.enemyLs > 0){
        enemyHeal = Math.max(1, Math.round(dmg * e.enemyLs));
        r.enemyHp = clamp(r.enemyHp + enemyHeal, 0, r.enemyHpMax);
      }

      // 追撃（怨嗟）も致死回避の対象にする
      let extraDmg = 0;
      if (e.enemySpite > 0 && Math.random() < 0.20){
        extraDmg = Math.max(1, Math.round(dmg * e.enemySpite));
        const hp2 = S.hero.hp - extraDmg;
        // 致死回避は無効（難易度調整）
        S.hero.hp = Math.max(0, hp2);
      }

      // vBattleLog+: 詳細戦況（魔の攻撃名/受苦量を表示）
      const aggE = battleAggEnsure(e);
      const atkName = enemyAtkName(e);
      pushUnique(aggE.atkNames, atkName, 3);
      aggE.enemyHits++;
      const totalDmg = dmg + extraDmg;
      try{ aggE.lastEnemy = { enemy: dispEnemyName(e.name), atk: atkName, dmg: totalDmg, base: dmg, extra: extraDmg, hpBefore, hpAfter: (Number.isFinite(S.hero.hp)?S.hero.hp:0), shield: ((r.entryShield||0)>0), shieldDR: (r.entryShieldDR ?? 0.45) }; }catch(_){ }
      aggE.enemyDmg += totalDmg;
      aggE.enemyMax = Math.max(aggE.enemyMax, totalDmg);
      if ((r.entryShield || 0) > 0) aggE.shieldHits++;
      if (extraDmg) aggE.spiteDmg += extraDmg;
      if (thornsDmg) aggE.thornsDmg += thornsDmg;
      if (enemyHeal) aggE.enemyHeal += enemyHeal;

      // 瀕死/大害は即表示
      if (bigHit || S.hero.hp <= S.hero.hpMax*0.22){
        flushBattleAgg(true);
      }

      if (S.hero.hp <= 0){
        flushBattleAgg(true);
        S.hero.dead = true;
        
      try { if (typeof BATTLE !== 'undefined' && BATTLE) { BATTLE.heroDie(); } } catch (_) {}
S.run.active = false;
        S.run.enemy = null;
        S.run.enemyHp = 0;
        S.run.enemyHpMax = 0;
        logImportant(`<span class="bad">調伏に至らず</span>…（死因: ${dispEnemyName(e.name)}「${atkName}」 受苦:${fmt(totalDmg)} / 命:${fmt(hpBefore)}→0` + (((r.entryShield||0)>0)?` / 結界(-${Math.round((r.entryShieldDR ?? 0.45)*100)}%)`:'') + `）`);
        dirtyHUD = true;
        break;
      }
    }

    flushBattleAgg(false);

    dirtyHUD = true;
  }

  // --------------------
  // Inventory actions
  // --------------------
  function equip(itemId){
    const idx = S.inv.findIndex(x=>x.id===itemId);
    if (idx < 0) return;
    const it = S.inv[idx];
    const slot = it.slot;
    const cur = S.gear[slot];
    if (cur) S.inv.push(cur);
    S.gear[slot] = it;
    S.inv.splice(idx,1);
    markStatsDirty();
    log(`加持: ${SLOT_NAME[slot]}「${it.name}」`);
    calcStats();
    save();
    dirtyInv = true;
    dirtyHUD = true;
  }

  function sell(itemId){
    const idx = S.inv.findIndex(x=>x.id===itemId);
    if (idx < 0) return;
    const it = S.inv[idx];
    const rar = RAR.find(r=>r.key===it.rarity) ?? RAR[0];
    const base = 8 + (it.ilv||1) * 2.7;
    const price = Math.round(base * rar.sell);
    S.hero.gold += price;
    S.inv.splice(idx,1);
    log(`布施: ${dispItemName(it)} <span class="gold">(+${fmt(price)}功徳)</span>`);
    save();
    dirtyInv = true;
    dirtyHUD = true;
  }

  function sellWhere(fn){
    let sold = 0, got = 0;
    const keep = [];
    for (const it of S.inv){
      if (fn(it)){
        const rar = RAR.find(r=>r.key===it.rarity) ?? RAR[0];
        const base = 8 + (it.ilv||1) * 2.7;
        const price = Math.round(base * rar.sell);
        got += price; sold++;
      } else keep.push(it);
    }
    S.inv = keep;
    if (sold){
      S.hero.gold += got;
      log(`一括布施: ${sold}個 <span class="gold">(+${fmt(got)}功徳)</span>`);
      save();
      dirtyInv = true;
      dirtyHUD = true;
    }
  }

  // --------------------
  // Upgrades
  // --------------------
  function upgradeCost(){
    const u = S.hero.base;
    const total = u.str + u.vit + u.def + u.luck;
    return Math.round(42 + Math.pow(total+1, 1.28) * 21);
  }

  function clampBulk(n){
    n = Math.floor(Number(n)||1);
    if (n <= 1) return 1;
    if (n <= 10) return 10;
    if (n <= 100) return 100;
    if (n <= 1000) return 1000;
    return 10000;
  }

  function buyUpgradeN(key, count){
    const n = clampBulk(count);
    let bought = 0;
    let spent = 0;
    for (let i=0; i<n; i++){
      const cost = upgradeCost();
      if (S.hero.gold < cost) break;
      S.hero.gold -= cost;
      spent += cost;
      S.hero.base[key] += 1;
      bought++;
    }
    if (!bought){
      const cost = upgradeCost();
      log(`<span class="bad">不足</span>: 昇格に${fmt(cost)}徳が必要です`);
      return;
    }
    const note = (bought < n) ? ` (${bought}/${n})` : "";
    log(`<span class="good">拠点強化</span>: ${UPG_LABEL[key] || key} +${bought}${note} <span class="gold">(-${fmt(spent)}功徳)</span>`);
    calcStats();
    save();
    dirtyHUD = true;
    markStatsDirty();
  }

  function buyUpgrade(key){
    return buyUpgradeN(key, 1);
  }


  function guildCost(which){
    const g = S.hero.guild;
    const lv = g[which] || 0;
    const base = 230 + Math.pow(lv+1, 1.50) * 190;
    const slope = (which==="forge") ? 1.10 : (which==="library") ? 1.15 : 1.00;
    return Math.round(base * slope);
  }

  function buyGuildN(which, count){
    const n = clampBulk(count);
    const cap = guildCap(which);
    const cur0 = Math.max(0, Math.floor(num(S.hero.guild[which], 0)));

    if (cur0 >= cap){
      log(`<span class="warn">上限</span>: ${GUILD_LABEL[which] || which} は位${cap}で頭打ちです。`);
      dirtyLog = true;
      return;
    }

    const want = Math.min(n, cap - cur0);

    let bought = 0;
    let spent = 0;
    for (let i=0; i<want; i++){
      const cost = guildCost(which);
      if (S.hero.gold < cost) break;
      S.hero.gold -= cost;
      spent += cost;
      S.hero.guild[which] = (S.hero.guild[which]||0) + 1;
      bought++;
    }

    if (!bought){
      const cost = guildCost(which);
      log(`<span class="bad">不足</span>: 設備に${fmt(cost)}徳が必要です`);
      return;
    }

    const now位 = Math.floor(num(S.hero.guild[which], 0));
    const note = (bought < n) ? ` (${bought}/${n})` : "";
    const capNote = (now位 >= cap) ? " [MAX]" : "";
    log(`<span class="rare">設備強化</span>: ${GUILD_LABEL[which] || which} 位${now位} (+${bought})${note}${capNote} <span class="gold">(-${fmt(spent)}功徳)</span>`);
    save();
    dirtyHUD = true;
    markStatsDirty();
  }


  function buyGuild(which){
    return buyGuildN(which, 1);
  }


  // --------------------
  // Heal / Revive / Panic button
  // --------------------
  function healSmall(){
    if (S.hero.dead) return;
    const cost = 18 + Math.floor(S.run.floor*4);
    if (S.hero.gold < cost){
      log(`<span class="bad">不足</span>: 加持に${fmt(cost)}徳が必要です`);
      return;
    }
    S.hero.gold -= cost;
    const amt = Math.round(S.hero.hpMax * 0.40);
    S.hero.hp = clamp(S.hero.hp + amt, 1, S.hero.hpMax);
    log(`加持: +${fmt(amt)}命 <span class="gold">(-${fmt(cost)}功徳)</span>`);
    save();
    dirtyHUD = true;
  }

  function revive(){
    if (!S.hero.dead) return;
    const r = S.run;
    const cost = Math.round(60 + r.floor*22);

    // 復活直後に同じ地点/難易度へ戻すと「復活→即死→進行不能」になりやすい。
    // そのため、復活時は必ず少し撤退して魔を輪廻する（再戦輪転防止）。
    const retreatAfterRevive = (paid) => {
      const beforeFloor = r.floor, beforeRoom = r.room;
      const back = 10;
      r.floor = Math.max(1, r.floor - back);
      r.room = 1;
      // 魔を消して、新しい場所で再生成
      r.enemy = null;
      r.enemyHp = 0;
      r.enemyHpMax = 0;
      // 復活直後の事故防止（短時間の入室護盾）
      r.entryShield = Math.max(1.2, (r.entryShield || 0));

      r.reviveGraceRooms = Math.max(0, Math.floor(r.reviveGraceRooms||0));
      r.reviveGraceRooms = Math.max(r.reviveGraceRooms, 30);

      // 表示用
      const moved = (r.floor !== beforeFloor) || (r.room !== beforeRoom);
      if (moved){
        const why = paid ? '再戦輪転防止で10階層撤退' : '撤退';
        log(`<span class="warn">${why}</span>: ${beforeFloor}-${beforeRoom} → ${r.floor}-${r.room}`);
      }
    };

    if (S.hero.gold >= cost){
      S.hero.gold -= cost;
      logImportant(`<span class="good">復活</span>: <span class="gold">-${fmt(cost)}功徳</span>`);
      retreatAfterRevive(true);
    } else {
      const lost = S.hero.gold;
      S.hero.gold = 0;
      S.hero.exp = Math.floor(S.hero.exp * 0.65);
      const newFloor = Math.max(1, r.floor - 10);
      r.floor = newFloor;
      r.room = 1;
      r.enemy = null;
      r.enemyHp = 0;
      r.enemyHpMax = 0;
      logImportant(`<span class="warn">救済復活</span>: ${fmt(lost)}徳没収 / 階層 ${newFloor}へ（10階層）撤退 / 行減少`);
      r.entryShield = Math.max(1.2, (r.entryShield || 0));
      r.reviveGraceRooms = Math.max(0, Math.floor(r.reviveGraceRooms||0));
      r.reviveGraceRooms = Math.max(r.reviveGraceRooms, 30);
    }

    S.hero.hp = Math.max(1, Math.round(S.hero.hpMax * 0.80));
    S.hero.dead = false;
    r.active = false;
    ensureEnemy();
    save();
    dirtyHUD = true;
  }

  function nukeStuck(){
    if (S.hero.dead) return;
    const r = S.run;
    if (!r.enemy || r.enemyHp <= 0) return;
    const cut = Math.max(1, Math.round(r.enemyHpMax * 0.35));
    r.enemyHp = Math.max(0, r.enemyHp - cut);
    log(`<span class="warn">詰み解除</span>: 魔命を${fmt(cut)}削りました。`);
    dirtyHUD = true;
  }

  // --------------------
  // Offline
  // --------------------
  function applyOffline(){
    const prev = S.t ?? now();
    const elapsed = Math.max(0, now() - prev);
    const mins = Math.floor(elapsed / 60000);
    if (mins < 2) return;
    const capMins = Math.min(mins, 180);

    if (S.run.active && !S.hero.dead){
      const st = calcStats();
      const ilv = Math.floor(Math.max(S.run.floor*2.2 + S.run.room*0.18, S.hero.lv*0.55));
      const gold = Math.round(capMins * (14 + ilv*1.9) * 0.40 * st.goldMult);
      const exp  = Math.round(capMins * (18 + ilv*2.1) * 0.33 * st.xpMult);

      S.hero.gold += gold;
      grantExp(exp);

      const count = clamp(Math.floor(capMins/10) + (Math.random() < 0.35 ? 1 : 0), 1, 14);
      S.run.offlineChest = { count, ilv };
      logImportant(`<span class="good">未接続報酬</span>: ${capMins}分 <span class="gold">(+${fmt(gold)}功徳)</span> (+${fmt(exp)}経験) / 宝函${count}個分`);
    } else {
      log(`離席: ${capMins}分`);
    }
    dirtyHUD = true;
  }

  function openOfflineChest(){
    const c = S.run.offlineChest;
    if (!c) return;
    const st = calcStats();
    // reset aggregated auto-sell counters for this chest batch
    S.run._autoSoldN = 0;
    S.run._autoSoldG = 0;
    ensureMikkyoFields();
    const rarityBoost = st.gB.rarityBoost;
    for (let i=0;i<c.count;i++){
      const it = makeItem(c.ilv + st.gB.dropIlv, st.luckFactor, st.luck, rarityBoost);
      if (it && it.rarity === "unique"){
        const rk = biomeForFloor(S.run.floor).key;
        applySealToUnique(it, rk);
        grantSealFragment(rk);
      }
      S.inv.push(it);
      const rarName = RAR.find(r=>r.key===it.rarity)?.name ?? it.rarity;
      const rarTag = (it.rarity === "unique") ? "★六印欠片" : rarName;
      logImportant(`宝函: <span class="rar ${it.rarity}">${rarTag}</span> ${SLOT_NAME[it.slot]}「${dispItemName(it)}」`);
      maybeAutoEquip(it);
      if (it.rarity === "unique"){ try{ ensureMikkyoFields(); S.hero.codex.uniques = (S.hero.codex.uniques||0) + 1; }catch(_){ } }

      // Auto-sell (instant) if enabled and the chest item is still in inventory (i.e., not equipped)
      if (S.inv.findIndex(x=>x.id===it.id) >= 0 && shouldAutoSell(it)){
        const idx = S.inv.findIndex(x=>x.id===it.id);
        if (idx >= 0){
          const soldIt = S.inv[idx];
          const rar = RAR.find(r=>r.key===soldIt.rarity) ?? RAR[0];
          const base = 8 + (soldIt.ilv||1) * 2.7;
          const price = Math.round(base * rar.sell);
          S.hero.gold += price;
          S.inv.splice(idx, 1);
          // aggregate log to reduce spam
          S.run._autoSoldN = (S.run._autoSoldN||0) + 1;
          S.run._autoSoldG = (S.run._autoSoldG||0) + price;
        }
      }
    }

    if (S.run._autoSoldN){
      const n = S.run._autoSoldN || 0;
      const g = S.run._autoSoldG || 0;
      logImportant(`<span class="warn">自動布施(宝函)</span>: ${n}個 <span class="gold">(+${fmt(g)}功徳)</span>`);
      dirtyHUD = true;
    }

    if (S.inv.length > 900){
      autoTrimInventory();
    }

    S.run.offlineChest = null;
    save();
    dirtyInv = true;
    dirtyHUD = true;
  }

  // --------------------
  // Logging + dirty flags
  // --------------------
  
  // Smooth log flow (auto-scroll + incremental render)
  let logPinned = true;              // whether log is currently pinned to bottom
  let lastLogScrollAt = 0;
  const reduceMotion = !!(window.matchMedia && window.matchMedia('(prefers-reduced-motion: reduce)').matches);

  // Live log pacing: show new cards one-by-one (reduces burst)
  // Pacing is tuned by simulation speed so the user can read it.
  // Target: at 1× speed, show ~1 log line per second.
  function logPumpMs(){
  try{
    const label = (S && S.run) ? Number(S.run.speed) : 1;
    let pace = speedPace(label); // 1× => 1 log card / sec (baseline)

    // Keep logs and simulation in sync even when iOS calibration boosts sim speed.
    if (IS_IOS && S && S.run){
      const k = Number(S.run._iosSpeedScale);
      if (Number.isFinite(k) && k > 0) pace *= k;
    }

    if (!Number.isFinite(pace) || pace <= 0) return 1000;
    const ms = 1000 / pace;

    // iOS timers can be coarse; allow a slightly smaller min so it can catch up.
    const minMs = IS_IOS ? 60 : 40;
    return clamp(ms, minMs, 3500);
  }catch(_){
    return 1000;
  }
}

let logPending = [];     // [{id:number, node:HTMLElement}]
  let logQueuedUpTo = 0;   // max log id already rendered or queued
  let logPumpOn = false;

  function trimLogDomToRange(firstId){
    try{
      if (!els || !els.log) return;
      const el = els.log;
      while (el.firstElementChild && Number(el.firstElementChild.dataset.id || 0) < firstId){
        el.removeChild(el.firstElementChild);
      }
    }catch(_){}
  }
  function dropPendingBefore(firstId){
    while (logPending.length && Number(logPending[0].id || 0) < firstId) logPending.shift();
  }
  function flushLogPending(){
    try{
      if (!els || !els.log) return;
      if (!logPending.length) return;
      const frag = document.createDocumentFragment();
      for (const it of logPending){
        if (it && it.node) frag.appendChild(it.node);
      }
      logPending = [];
      els.log.appendChild(frag);
    }catch(_){}
  }
  function startLogPump(){
    if (logPumpOn) return;
    logPumpOn = true;

    const step = ()=>{
      if (!logPumpOn) return;

      // If user scrolled up, pause pacing (keep pending; don't burst-append)
      if (!logPinned){
        logPumpOn = false;
        return;
      }

      // Append in small batches to reduce layout/paint overhead (especially on iOS Safari)
      if (els && els.log && logPending.length){
        const backlog = logPending.length;

        // Catch-up: if pending is piling up, append more per tick.
        let batch = 1;
        if (backlog > 8) batch = Math.min(12, 1 + Math.floor(backlog / 6));

        // iOS: favor batching even at low backlog (DOM append is relatively expensive).
        if (IS_IOS) batch = Math.max(batch, 2);

        const frag = document.createDocumentFragment();
        for (let i=0;i<batch;i++){
          const it = logPending.shift();
          if (!it) break;
          if (it.node) frag.appendChild(it.node);
        }
        els.log.appendChild(frag);
      }

      // Align DOM to current window (handles rotation)
      const want = (S && Array.isArray(S.log)) ? S.log.slice(-logCap()) : [];
      const firstId = want.length ? Number(want[0].id || 0) : 0;
      if (firstId){
        trimLogDomToRange(firstId);
        dropPendingBefore(firstId);
      }

      // Keep glued to bottom
      try{
        if (IS_IOS || reduceMotion){
          pinLogToBottom(els.log, 0);
        }else{
          smoothFollowLogBottom(els.log, {offset:0, snapDiff:1400, maxStep:520});
        }
      }catch(_){ }

      if (logPending.length){
        let ms = logPumpMs();

        // If we are far behind, tick a bit faster to catch up (without pegging CPU).
        if (logPending.length > 12) ms = Math.max(24, ms * 0.6);

        setTimeout(step, ms);
      }else{
        logPumpOn = false;
      }
    };

    // Kick immediately
    step();
  }


  function isLogPinned(el){
    try{
      return (el.scrollHeight - el.scrollTop - el.clientHeight) < 180;
    }catch(_){
      return true;
    }
  }

  

  function pinLogToBottom(el, offset){
    try{
      offset = clamp(num(offset, 0), 0, 80);
      el.scrollTop = Math.max(0, el.scrollHeight - el.clientHeight - offset);
    }catch(_){ }
  }
// Waterfall log follow (time-based easing / ヌルヌル pin)
  let logFollowRAF = 0;
  let logFollowEl = null;
  let logFollowLastT = 0;

  function smoothFollowLogBottom(el, opt){
    if (!el) return;
    opt = opt || {};
    const offset   = clamp(num(opt.offset, 0), 0, 80);           // keep 0 to truly pin
    const maxStep  = clamp(num(opt.maxStep, 520), 20, 1600);
    const snapDiff = clamp(num(opt.snapDiff, 1400), 80, 8000);

    if (reduceMotion){
      el.scrollTop = Math.max(0, el.scrollHeight - el.clientHeight - offset);
      return;
    }

    logFollowEl = el;
    if (logFollowRAF) return;
    logFollowLastT = 0;

    const step = (t)=>{
      if (!logPinned || !logFollowEl){
        logFollowRAF = 0;
        logFollowEl = null;
        logFollowLastT = 0;
        return;
      }
      const el = logFollowEl;
      const target = Math.max(0, el.scrollHeight - el.clientHeight - offset);
      const cur = el.scrollTop;
      const diff = target - cur;

      // If we somehow got far behind (e.g., long pause / tab hidden), snap once.
      if (diff > snapDiff){
        el.scrollTop = target;
        logFollowRAF = 0;
        logFollowEl = null;
        logFollowLastT = 0;
        return;
      }

      const dt = logFollowLastT ? clamp((t - logFollowLastT)/1000, 0.012, 0.05) : 0.016;
      logFollowLastT = t;

      // Exponential smoothing (time-based)
      const alpha = 1 - Math.exp(-dt * 22);
      let stepPx = diff * alpha;
      stepPx = clamp(stepPx, -maxStep, maxStep);
      el.scrollTop = cur + stepPx;

      // Stop when settled (renderLog()/pump will re-start us)
      if (Math.abs(target - el.scrollTop) < 0.45 && (!logPending || logPending.length === 0)){
        el.scrollTop = target;
        logFollowRAF = 0;
        logFollowEl = null;
        logFollowLastT = 0;
        return;
      }

      logFollowRAF = requestAnimationFrame(step);
    };

    logFollowRAF = requestAnimationFrame(step);
  }




  // --------------------
  // MAX-speed performance helpers
  // --------------------
  function markStatsDirty(){
    try{
      if (!S || !S.run) return;
      S.run._stCacheDirty = true;
    }catch(_){}
  }
  function calcStatsFast(){
    // calcStats() can be expensive on mobile Safari.
    // We cache for a short real-time window and invalidate on stat-changing actions.
    const r = S.run;
    const t = now();
    const sp = Number(r && r.speed) || 1;

    const useCache = (sp >= 8) || isSpeedMax() || (IS_IOS && sp >= 4);
   // iPhoneで1×/2×が遅く感じる原因になりやすいので、低速域はキャッシュしない
    if (IS_IOS && sp <= 2 && !isSpeedMax()) return calcStats();
    if (!useCache) return calcStats();

    const dirty = !!(r && r._stCacheDirty);
    const age = t - (Number.isFinite(r._stCacheT) ? r._stCacheT : 0);

    // iOS: keep cache a bit longer to reduce per-tick cost.
    const cacheMs = IS_IOS ? (isSpeedMax() ? 750 : 450) : (isSpeedMax() ? 250 : 180);

    if (!r._stCache || dirty || age > cacheMs){
      r._stCache = calcStats();
      r._stCacheT = t;
      r._stCacheDirty = false;
    }
    return r._stCache;
  }

  function isSpeedMax(){
    // Simulation speed selector (MAX is usually 256)
    return !!(S && S.run && Number(S.run.speed) >= SPEED_MAX_LABEL);
  }
  function isSpdMax(){
    // Combat stat "迅行" (spd) hard cap is 2.75. When capped, actions/logs can explode.
    return !!(S && S.run && S.run._spdIsMax);
  }
  function isLogLite(){
    // Log-lite mode is ONLY for simulation speed MAX.
    // (User request) When speed is not MAX, keep the normal (detailed) logs even if spd is capped.
    return isSpeedMax();
  }
  function logCap(){
    // In log-lite mode, keep the DOM small.
    return isLogLite() ? 40 : 240;
  }

  function _logLiteCtx(){
    const r = (S && S.run) ? S.run : null;
    if (!r) return null;
    if (!r._logLite) r._logLite = { lastFlush:0, skipped:0 };
    return r._logLite;
  }
  function _logLiteBump(){
    const ctx = _logLiteCtx();
    if (!ctx) return;
    ctx.skipped += 1;

    // Avoid calling Date.now() for every skipped log at very high speed.
    if ((ctx.skipped & 255) !== 0) return;

    const t = now();
    if ((t - (ctx.lastFlush||0)) < 3000) return;

    const n = ctx.skipped;
    ctx.skipped = 0;
    ctx.lastFlush = t;

    // Super short summary. (No parsing / no formatting)
    pushLog(S, `<span class="mutedTxt">速度MAX</span>: ログ${n}件 省略`);
    dirtyLog = true;
  }

  function compactMsgIfNeeded(msg){
    if (!isLogLite()) return msg;
    const s = String(msg || "");
    let c = s.replace(/<br\s*\/?>/gi, " / ").replace(/\s+/g, " ").trim();
    if (c.length > 110) c = c.slice(0, 110) + "…";
    return c;
  }

  function pushLog(state, msg){
    const cap = logCap();
    const t = new Date().toLocaleTimeString("ja-JP",{hour:"2-digit",minute:"2-digit",second:"2-digit"});
    state.log = Array.isArray(state.log) ? state.log : [];
    state.logSeq = Math.floor(num(state.logSeq, 0)) || 0;
    state.logSeq += 1;
    state.log.push({ id: state.logSeq, t, msg });
    if (state.log.length > cap) state.log.splice(0, state.log.length - cap);
  }

  // Archive only meaningful texts to the Codex library (avoid "記録" spam).
function _archiveImportantLog(msgHtml){
  try{
    const txtRaw = stripHtmlToText(msgHtml);
    const txt = String(txtRaw || "").trim();
    if (!txt) return;

    const norm = txt.replace(/\s+/g, " ").trim();
    if (!norm || norm === "記録") return;

    // Keep only meaningful one-liners, unless they match key patterns.
    const keepShort = /^(昇位|層|宝函|自動布施|復活|救済復活|未接続報酬|調伏に至らず|例外|描画例外|起動)/.test(norm);
    if (!keepShort && norm.length < 18) return;

    ensureLibrary();
    const lib = S.hero.codex.library;
    const docs = lib.docs || {};
    const lastKey = (Array.isArray(lib.order) && lib.order.length) ? lib.order[0] : "";
    if (lastKey && docs[lastKey] && String(docs[lastKey]._norm||"") === norm) return;

    let kind = "出来事";
    let title = norm;

    // If the text is "X: Y" or "X：Y", treat X as kind.
    const m = norm.match(/^([^：:]{1,10})[：:]\s*(.+)$/);
    if (m){
      kind = (m[1] || "").trim() || kind;
      title = (m[2] || "").trim() || kind;
    }

    // Heuristics for better grouping
    if (/昇位/.test(norm)) kind = "進行";
    else if (/^層\s*\d+/.test(norm)) kind = "進行";
    else if (/調伏に至らず/.test(norm)) kind = "死亡";
    else if (/^救済復活/.test(norm) || /^復活/.test(norm)) kind = "復活";
    else if (/^未接続報酬/.test(norm)) kind = "報酬";
    else if (/^宝函/.test(norm)) kind = "宝函";
    else if (/^自動布施/.test(norm)) kind = "自動布施";
    else if (/^(例外|描画例外|起動)/.test(norm)) kind = "システム";

    // Make title compact
    if (title.length > 46) title = title.slice(0, 46) + "…";

    const key = "log:" + String(S.logSeq||0);
    recordDoc(key, title, txt, "", kind, "");
    try{
      const d = (S.hero.codex.library && S.hero.codex.library.docs) ? S.hero.codex.library.docs[key] : null;
      if (d) d._norm = norm;
    }catch(_){}
  }catch(_){}
}

function logImportant(msg){
  pushLog(S, compactMsgIfNeeded(msg));
  _archiveImportantLog(msg);
  dirtyLog = true;
}

function log(msg){

    // Log-lite mode: drop almost everything without inspecting the message.
    // This keeps MAX speed from freezing the browser.
    if (isLogLite()){
      _logLiteBump();
      return;
    }
    pushLog(S, compactMsgIfNeeded(msg));
    dirtyLog = true;
  }

  function ensureLogIds(){
    try{
      S.log = Array.isArray(S.log) ? S.log : [];
      let seq = Math.floor(num(S.logSeq, 0)) || 0;
      // If older logs have no id, assign sequentially in order
      for (const x of S.log){
        if (!x) continue;
        if (typeof x.id !== "number"){
          seq += 1;
          x.id = seq;
        }else{
          seq = Math.max(seq, x.id);
        }
      }
      S.logSeq = seq;
    }catch(_){}
  }



  // --------------------
  // Save / Load
  // --------------------
  function save(){
    S.t = now();
    try{ localStorage.setItem(KEY_V8, JSON.stringify(S)); } catch(e){}
  }
  function load(key){
    try{
      const raw = localStorage.getItem(key);
      if (!raw) return null;
      const obj = JSON.parse(raw);
      if (!obj) return null;
      return obj;
    } catch(e){
      return null;
    }
  }
  function hardReset(){
    localStorage.removeItem(KEY_V3);
    localStorage.removeItem(KEY_V4);
    localStorage.removeItem(KEY_V5);
    localStorage.removeItem(KEY_V6);
    localStorage.removeItem(KEY_V7);
    localStorage.removeItem(KEY_V8);
    try{ if (typeof SOUND!=="undefined" && SOUND) SOUND.stop(); }catch(_){ }
    S = defaultState();
    // v58: 輪廻時に名前を設定できる
    promptHeroName(true);
    log("輪廻が成就しました。");
    save();
    dirtyHUD = true; dirtyInv = true; dirtyLog = true;
  }

  // v58: hero name
  function promptHeroName(force){
    try{
      const cur = (S.hero && typeof S.hero.name === 'string' && S.hero.name.trim()) ? S.hero.name.trim() : '行者';
      const msg = force ? '行者の名前を入力してください' : '行者の名前';
      const raw = window.prompt(msg, cur);
      if (raw === null){
        // 取消でも行持は進められるようにする
        S.hero.name = cur;
        S.hero.nameSet = true;
        return false;
      }
      const clean = String(raw).replace(/\s+/g,' ').trim().slice(0,16);
      S.hero.name = clean || cur;
      S.hero.nameSet = true;
      save();
      dirtyHUD = true;
      return true;
    }catch(_){
      try{ S.hero.name = S.hero.name || '行者'; S.hero.nameSet = true; }catch(__){}
      return false;
    }
  }
  function ensureHeroName(){
    if (!S || !S.hero) return;
    if (S.hero.nameSet) return;
    promptHeroName(true);
  }

  // --------------------
  // UI (optimized)
  // --------------------
  const $ = (id) => document.getElementById(id);
  const els = {
    btnExplore: $("btnExplore"), btnPause: $("btnPause"), btnNext: $("btnNext"), btnSave: $("btnSave"), btnReset: $("btnReset"), btnChant: $("btnChant"), btnCodex: $("btnCodex"),
    speedSel: $("speedSel"), autoSel: $("autoSel"), fxSel: $("fxSel"),
    locText: $("locText"),
    lvExp: $("lvExp"), expBar: $("expBar"), expText: $("expText"), goldText: $("goldText"), karmaText: $("karmaText"), satoriText: $("satoriText"),
    heroName: $("heroName"),
    hpText: $("hpText"), heroSprite: $("heroSprite"), heroStageSprite: $("heroStageSprite"), heroActor: $("heroActor"), hpBar: $("hpBar"), dpsText: $("dpsText"), luckText: $("luckText"),
    enemyName: $("enemyName"), enemySprite: $("enemySprite"), enemyStageSprite: $("enemyStageSprite"), enemyActor: $("enemyActor"), battleStage: $("battleStage"), battleFx: $("battleFx"), battleFxFull: $("battleFxFull"), battleFlash: $("battleFlash"), biomeText: $("biomeText"), floorText: $("floorText"), roomText: $("roomText"),
    eliteTag: $("eliteTag"), bossTag: $("bossTag"),
    enemyHpBar: $("enemyHpBar"), enemyHpText: $("enemyHpText"), enemyStatsText: $("enemyStatsText"),
    atkVal: $("atkVal"), defVal: $("defVal"), critText: $("critText"), spdText: $("spdText"),
    eqWeapon: $("eqWeapon"), eqWeaponIcon: $("eqWeaponIcon"), eqWeaponRar: $("eqWeaponRar"), eqWeapon位: $("eqWeapon位"), eqWeaponPerf: $("eqWeaponPerf"),
    eqArmor: $("eqArmor"), eqArmorIcon: $("eqArmorIcon"), eqArmorRar: $("eqArmorRar"), eqArmor位: $("eqArmor位"), eqArmorPerf: $("eqArmorPerf"),
    eqAcc: $("eqAcc"), eqAccIcon: $("eqAccIcon"), eqAccRar: $("eqAccRar"), eqAcc位: $("eqAcc位"), eqAccPerf: $("eqAccPerf"),
    lockWeapon: $("lockWeapon"), lockArmor: $("lockArmor"), lockAcc: $("lockAcc"),
    upgText: $("upgText"), upgCostText: $("upgCostText"), pathBulkSel: $("pathBulkSel"), pathText: $("pathText"), pathCostText: $("pathCostText"), pathNoteText: $("pathNoteText"), btnDedicate: $("btnDedicate"), dedicateText: $("dedicateText"), gupgText: $("gupgText"), gupgCostText: $("gupgCostText"),
    upgBulkSel: $("upgBulkSel"), gupgBulkSel: $("gupgBulkSel"),
    log: $("log"), runInfo: $("runInfo"),
    invCount: $("invCount"), invList: $("invList"),
    search: $("search"), sortSel: $("sortSel"),
    btnClearSearch: $("btnClearSearch"), btnSellAll: $("btnSellAll"),
    autoSellOn: $("autoSellOn"), autoSellRarMax: $("autoSellRarMax"), autoSellUseEq: $("autoSellUseEq"), autoSellEqPct: $("autoSellEqPct"), autoSellProtectUnique: $("autoSellProtectUnique"),
    btnRevive: $("btnRevive"),
    deathNote: $("deathNote"),
    deathOverlay: $("deathOverlay"),
    offlineNote: $("offlineNote"), btnOpenChest: $("btnOpenChest"),
    btnBack: $("btnBack"), locBadge: $("locBadge"), tabs: $("tabs"), safeTag: $("safeTag"), safeText: $("safeText"),
    cmpPanel: $("cmpPanel"), cmpHint: $("cmpHint"), cmpBody: $("cmpBody"),
    cmpSlotPill: $("cmpSlotPill"), cmpNewRar: $("cmpNewRar"), cmpNewName: $("cmpNewName"), cmpNewPower: $("cmpNewPower"), cmpNewStats: $("cmpNewStats"),
    cmpCurRar: $("cmpCurRar"), cmpCurName: $("cmpCurName"), cmpCurPower: $("cmpCurPower"), cmpDelta: $("cmpDelta"),
    btnEquipSelected: $("btnEquipSelected"), btnClearSelected: $("btnClearSelected"), eventOverlay: $("eventOverlay"), eventTitle: $("eventTitle"), eventBody: $("eventBody"), eventChoices: $("eventChoices"), eventFoot: $("eventFoot"), btnEventClose: $("btnEventClose"), codexOverlay: $("codexOverlay"), codexBody: $("codexBody"), btnCodexClose: $("btnCodexClose"),
  };

  // Keep log pin state in sync when the user scrolls the log
  try{
    if (els.log){
      els.log.addEventListener("scroll", ()=>{ logPinned = isLogPinned(els.log); }, {passive:true});
    }
  }catch(_){}


  // v64: log-only battle view — lock "演出" to OFF
  try{
    if (els.fxSel){
      els.fxSel.value = "0";
      els.fxSel.disabled = true;
      els.fxSel.title = "調伏演出は廃止（記のみ）";
    }
  }catch(_){ }


  function setEquipLock(slot, on){
    S.hero.lock = S.hero.lock ?? { weapon:false, armor:false, accessory:false };
    S.hero.lock[slot] = !!on;
    save();
    dirtyHUD = true;
  }
  function toggleEquipLock(slot){
    const cur = !!(S.hero.lock && S.hero.lock[slot]);
    setEquipLock(slot, !cur);
    log(`<span class="warn">加持封印</span>: ${SLOT_NAME[slot]} ${!cur ? "封" : "解"}`);
    dirtyLog = true;
  }

  // init battle FX sizing
  try{ BFX.resize(true); window.addEventListener('resize', () => { try{ BFX.resize(); }catch(_){ } }, { passive:true }); }catch(_){ }

  function rarLabel(key){
    const r = RAR.find(x=>x.key===key);
    return r ? r.name : key;
  }

  function statLines(stats){
    const s = stats || {};
    const lines = [];
    // 装備サマリ（statToken）と同じ語彙へ統一
    const push = (k, extra="") => {
      const t = statToken(k, s[k]);
      if (t) lines.push(t + extra);
    };
    push('atk');
    push('def');
    push('hp');
    push('crit');
    push('spd');
    push('luck');
    push('lifesteal');
    push('thorns');
    push('regen');      // 息災+xx%/s
    push('goldBonus');  // 功徳+xx%
    push('xpBonus');    // 行+xx%
    push('dmgMult');
    push('dr');
    // 付記（tooltipのみ詳細）
    if (s.execute) {
      const t = statToken('execute', s.execute);
      if (t) lines.push(t + '（命25%以下）');
    }
    if (s.shred) {
      const t = statToken('shred', s.shred);
      if (t) lines.push(t + '（魔の持戒↓）');
    }
    return lines.join("\n");
  }


  function statLinesWithCaps(it){
    if (!it) return "";
    const s = it.stats || {};
    const lines = [];

    let before = null, after = null;
    try{
      if (it && it.slot){
        before = calcStatsPure(S.gear);
        const g2 = { ...S.gear, [it.slot]: it };
        after = calcStatsPure(g2);
      }
    }catch(_){
      before = null; after = null;
    }

    const push = (k, extra="") => {
      const t = statToken(k, s[k]);
      if (!t) return;

      let note = "";
      const cap = capMetaForKey(k);
      if (cap && before && after && (s[k]||0) > 0){
        const b = before[k] ?? 0;
        const a = after[k] ?? 0;
        const delta = a - b;
        const isMax = (cap.max != null) && (a >= cap.max - 1e-9);
        const wasMax = (cap.max != null) && (b >= cap.max - 1e-9);
        if (wasMax && delta <= 1e-12) note = "（MAX：上昇なし）";
        else if (isMax) note = "（MAX）";
      }

      lines.push(t + note + extra);
    };

    push('atk');
    push('def');
    push('hp');
    push('crit');
    push('spd');
    push('luck');
    push('lifesteal');
    push('thorns');
    push('regen');
    push('goldBonus');
    push('xpBonus');
    push('dmgMult');
    push('dr');

    if (s.execute) {
      const t = statToken('execute', s.execute);
      if (t){
        let note = "";
        const cap = capMetaForKey('execute');
        if (cap && before && after){
          const b = before.execute ?? 0;
          const a = after.execute ?? 0;
          const delta = a - b;
          const isMax = (cap.max != null) && (a >= cap.max - 1e-9);
          const wasMax = (cap.max != null) && (b >= cap.max - 1e-9);
          if (wasMax && delta <= 1e-12) note = "（MAX：上昇なし）";
          else if (isMax) note = "（MAX）";
        }
        lines.push(t + note + '（命25%以下）');
      }
    }
    if (s.shred) {
      const t = statToken('shred', s.shred);
      if (t){
        let note = "";
        const cap = capMetaForKey('shred');
        if (cap && before && after){
          const b = before.shred ?? 0;
          const a = after.shred ?? 0;
          const delta = a - b;
          const isMax = (cap.max != null) && (a >= cap.max - 1e-9);
          const wasMax = (cap.max != null) && (b >= cap.max - 1e-9);
          if (wasMax && delta <= 1e-12) note = "（MAX：上昇なし）";
          else if (isMax) note = "（MAX）";
        }
        lines.push(t + note + '（魔の持戒↓）');
      }
    }

    return lines.join("\n");
  }

  function statToken(key, v){
    if (!v) return "";
    switch(key){
      case 'atk': return `降魔+${fmt(v)}`;
      case 'def': return `持戒+${fmt(v)}`;
      case 'hp': return `命+${fmt(v)}`;
      case 'crit': return `慧眼+${pct(v)}`;
      case 'spd': return `迅行+${pct(v)}`;
      case 'luck': return `縁+${fmt(v)}`;
      case 'lifesteal': return `還命+${pct(v)}`;
      case 'thorns': return `返業+${pct(v)}`;
      case 'regen': return `息災+${pct(v)}/s`;
      case 'goldBonus': return `功徳+${pct(v)}`;
      case 'xpBonus': return `行+${pct(v)}`;
      case 'dmgMult': return `威光+${pct(v)}`;
      case 'dr': return `苦減+${pct(v)}`;
      case 'execute': return `断業+${pct(v)}`;
      case 'shred': return `破障+${pct(v)}`;
      default: return '';
    }
  }

  const STAT_CAPS = {
    crit:{ min:0, max:0.65 },
    spd:{ min:0.55, max:2.75 },
    dr:{ min:0, max:0.60 },
    execute:{ min:0, max:0.35 },
    shred:{ min:0, max:0.35 },
  };
  function capMetaForKey(k){ return STAT_CAPS[k] || null; }

  function statPillsHTML(stats, it){
    const s = stats || {};
    const keys = ['atk','def','hp','crit','spd','luck','lifesteal','thorns','regen','goldBonus','xpBonus','dmgMult','dr','execute','shred'];

    let before = null, after = null;
    try{
      if (it && it.slot){
        before = calcStatsPure(S.gear);
        const g2 = { ...S.gear, [it.slot]: it };
        after = calcStatsPure(g2);
      }
    }catch(_){
      before = null; after = null;
    }

    return keys.map(k => {
      const tok = statToken(k, s[k]);
      if (!tok) return '';
      let cls = '';
      let tag = '';
      const cap = capMetaForKey(k);

      if (cap && before && after && (s[k]||0) > 0){
        const b = before[k] ?? 0;
        const a = after[k] ?? 0;
        const delta = a - b;
        const isMax = (cap.max != null) && (a >= cap.max - 1e-9);
        const wasMax = (cap.max != null) && (b >= cap.max - 1e-9);
        if (isMax) tag = `<span class="maxTag">MAX</span>`;
        if (wasMax && delta <= 1e-12) cls = ' capDead';
      }

      return `<span class="sp${cls}">${escapeHtml(tok)}${tag ? ` ${tag}` : ''}</span>`;
    }).join('');
  }

  function affixNamesFromDesc(desc){

    const s = String(desc ?? '');
    // desc例: "付与: 俊敏、吸血" / Uniqueは "... / 付与: ○○、○○"
    const ms = [...s.matchAll(/(?:付与|Affix|Affixes)\s*:\s*([^\n]+)/g)];
    if (!ms.length) return [];
    const last = String(ms[ms.length-1][1] ?? '').split('|')[0].trim();
    if (!last) return [];
    return last.split(/[、,]/).map(x=>x.trim()).filter(Boolean);
  }

  function equipAffixCount(it){
    if (!it) return 0;
    if (typeof it.affCount === 'number') return Math.max(0, Math.round(it.affCount));
    if (Array.isArray(it.affixes)) return it.affixes.length;
    const n = affixNamesFromDesc(it.desc).length;
    if (n) return n;
    // 旧記録等でdescが空のときは、宝格の標準付与数から推定
    try{ const r = RAR.find(x=>x.key === it.rarity); return r ? (r.aff||0) : 0; }catch(_){ return 0; }
  }

  function equipSummary(it){
    if (!it || !it.stats) return '—';
    const s = it.stats || {};
    const slot = it.slot || '';

    const order = (slot==='weapon')
      ? ['atk','crit','spd','dmgMult','execute','shred','lifesteal','luck','def','hp','dr','regen','goldBonus','xpBonus','thorns']
      : (slot==='armor')
        ? ['def','hp','dr','regen','thorns','atk','crit','spd','dmgMult','execute','shred','lifesteal','luck','goldBonus','xpBonus']
        : ['luck','goldBonus','xpBonus','crit','spd','dmgMult','dr','regen','hp','atk','def','lifesteal','thorns','execute','shred'];

    const parts = [];
    for (const k of order){
      const v = s[k];
      if (!v) continue;
      const t = statToken(k, v);
      if (t) parts.push(t);
    }

    const affN = equipAffixCount(it);
    const shown = parts.slice(0, 3);
    const extra = Math.max(0, parts.length - shown.length);

    let out = `付与${affN}`;
    if (shown.length){
      out += ' | ' + shown.join(' / ');
      if (extra > 0) out += ` / 他${extra}`;
    } else {
      out += ' | 効果なし';
    }
    return out;
  }

  function equipPerfTitle(it){
    if (!it) return '';
    const lines = [];
    try{ lines.push(`強さ ${fmt(itemPower(it))}`); }catch(_){ }
    lines.push(`付与 ${equipAffixCount(it)}`);
    const stats = statLinesWithCaps(it) || statLines(it.stats);
    if (stats) lines.push(stats);
    else lines.push('効果なし');
    if (it.desc) lines.push(dispDesc(it.desc));
    return lines.join('\n');
  }


  // 日本語表示（旧記録の英語名称も、できる範囲で置換）
  const JP_REPLACE = [
    [/(\b)Ruins(\b)/g, '遺跡'], [/(\b)Forest(\b)/g, '森林'], [/(\b)Crypt(\b)/g, '霊廟'], [/(\b)Forge(\b)/g, '炉心工房'], [/(\b)Tundra(\b)/g, '雪原'], [/(\b)Abyss(\b)/g, '深淵'], [/(\b)Skyreach(\b)/g, '天空回廊'], [/(\b)Mythic(\b)/g, '神秘領域'],
    [/(\b)Slime(\b)/g,'煩悩粘体'],[/(\b)Goblin(\b)/g,'羅刹小鬼'],[/(\b)Skeleton(\b)/g,'白骨'],[/(\b)Bandit(\b)/g,'盗賊'],[/(\b)Wolf(\b)/g,'狼'],[/(\b)Bat(\b)/g,'蝙蝠'],[/(\b)Spider(\b)/g,'蜘蛛'],[/(\b)Rat(\b)/g,'鼠'],
    [/(\b)Armored(\b)/g,'装甲'],[/(\b)Frenzied(\b)/g,'狂乱'],[/(\b)Titanic(\b)/g,'巨躯'],[/(\b)Hexed(\b)/g,'呪詛'],[/(\b)Volatile(\b)/g,'暴走'],[/(\b)Vampiric(\b)/g,'吸血'],[/(\b)Swift(\b)/g,'俊敏'],[/(\b)Unyielding(\b)/g,'不屈'],[/(\b)Spiteful(\b)/g,'怨嗟'],[/(\b)Mystic(\b)/g,'神秘'],
    [/(\b)Sword(\b)/g,'剣'],[/(\b)Axe(\b)/g,'斧'],[/(\b)Spear(\b)/g,'槍'],[/(\b)Dagger(\b)/g,'短金剛剣'],[/(\b)Bow(\b)/g,'弓'],[/(\b)Staff(\b)/g,'杖'],[/(\b)Hammer(\b)/g,'金剛槌'],[/(\b)Mace(\b)/g,'金剛棍'],[/(\b)Wand(\b)/g,'加持錫杖'],[/(\b)Katana(\b)/g,'刀'],
    [/(\b)Leather(\b)/g,'皮法衣'],[/(\b)Chain(\b)/g,'鎖子衣'],[/(\b)Plate(\b)/g,'板衣'],[/(\b)Robe(\b)/g,'袈裟'],[/(\b)Scale(\b)/g,'鱗衣'],[/(\b)Mantle(\b)/g,'外套'],
    [/(\b)Ring(\b)/g,'戒環'],[/(\b)Amulet(\b)/g,'護符'],[/(\b)Charm(\b)/g,'念符'],[/(\b)Talisman(\b)/g,'霊符'],[/(\b)Bracelet(\b)/g,'念珠護腕輪'],[/(\b)Pendant(\b)/g,'佩符'],
    [/(\b)Training Sword(\b)/g,'訓練用の金剛剣'],[/(\b)Padded Vest(\b)/g,'厚綿法衣'],[/(\b)Traveler's Charm(\b)/g,'行旅の護符'],
    [/(\b)Level Up!(\b)/g,'位上昇！'], [/(\b)Gold(\b)/g,'功徳'], [/(\b)行(\b)/g,'行'],
    [/Affix:/g,'付与:'], [/Mods:/g,'特性:'],
  ];
  function jpText(s){
    let out = String(s ?? '');
    for (const [re, rep] of JP_REPLACE) out = out.replace(re, rep);
    return out;
  }
  function dispItemName(it){ return jpText(it?.name ?? ''); }
  function dispDesc(desc){ return jpText(desc ?? ''); }
  function nameText(x){
    if (x == null) return '';
    if (typeof x === 'string' || typeof x === 'number') return String(x);
    if (typeof x === 'object'){
    // Prefer common fields; also handle nested objects / circular refs without showing "[object Object]"
    const keys = ["jp","name","text","label","title","en","id","key","type","kind"];
    for (const k of keys){
      try{
        if (Object.prototype.hasOwnProperty.call(x, k)){
          const v = x[k];
          if (typeof v === "string" || typeof v === "number") return String(v);
          if (v && typeof v === "object"){
            const vv = nameText(v);
            if (vv && vv !== "[object Object]") return vv;
          }
        }
      }catch(_){}
    }
    try{
      const seen = new WeakSet();
      const s = JSON.stringify(x, (kk,vv)=>{
        if (vv && typeof vv === "object"){
          if (seen.has(vv)) return "[Circular]";
          seen.add(vv);
        }
        return vv;
      });
      // keep it short for logs
      return (s && s.length > 80) ? (s.slice(0, 77) + "...") : (s || "");
    }catch(_){
      return "[魔]";
    }
  }
    return String(x);
  }
  function dispEnemyName(name){ return jpText(nameText(name)); }
function escapeHtml(s){
    return String(s).replace(/[&<>"']/g, c => ({ "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#039;" }[c]));
  }

  // --------------------
  // Pixel sprites (procedural)
  // --------------------
  
// High-res (32x32) stylish sprites for hero/enemies (PNG). Items/FX still use ASCII sprites.
const SPRIMG = {
  none: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mNgYGBgAAAABQABeqhXUAAAAABJRU5ErkJggg==',
  hero: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAABd0lEQVR42mNkIBLUXv5TwUACaNZl6cCnDybPxDDAgJFUn3eY8LfjU19x5mMlVvFvWe0MDAwMHVzTKgdVCLCQ6vPWScvwGlgNVYcrJNDNH3whQMjnrU01EJ/WtaDog4nD1KGHBLf5rDAGBgaGmXmXVjEwMDA8ST1SObjTAC6fP7x1Cav6tBg/BgYGBgZ5NT2sIcHAwBBGkgOoDWov/1FmYGBgYJhtQx0H/Pd3RS1QNu4my5zBmwYIgdmhuahpgExzBm8I/P75NYyBgYGhOi9qFXKqhqXyZ+ssUTVc2YoiLhVUM8zTgFTQcZpXRsrQAmlwlYSkAi4RJRTzpqTrDpM0AAPouYHUtDH0Q4DS3DD0SkL03NAVzI3CL1v7FYX/7c09FPMYGBhWDa00gB4S6Pk4fdIJlJbOzDyLVQwMDAw5My+j+5y8krBZl+UuLVtEgy8K0DuVhOoEuM/gLRUb/PKkpgH0viB6nNemMqBYAIt7XAAmX5E6SKIAAJYRpzIJ1RlTAAAAAElFTkSuQmCC',
  hero_atk: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAByElEQVR42mNkIBJ8PZnWxEAG6OCaVovMr/iW1czAwMDAbT6rjoGBgYGJYYABC6k+F7BbWotP/YdD0c1oPsZr/oCHACOpPm+dtAyvgdV5UeghgR5izYMqBFhI9XlrUw3Ep3UtKPpg4jB1AnZRtQwMDAy/f34NQ1Y3M89iFQMDA0NMtF7z4M4FuHz+8NYlrOrTYvwYGBgYGOTV9FBCojovahW2kKB7Gvh6Mk3368k0XZwhQGpJ99/fFTU7bdxNlsMGXxr4rTMTmm+X4tU4OzQXNQ2Q6YDBFwKsV9KbGRgYGF6/+1LLwMDAICrEg5KqYan82TpLVI1XtqKISwXVkOcAbvNZlxkYGBg+fJ05wOUAN2MYNHesYmBgYJh6AVVeKug4VRzARGx+pXsIsLJzQ33ujVISkgq4RJRQStYp6brYQ4DbfFYdrJk0qFpEhAB6biA1bQz+NiEhQGluGLwhAKu/YfU5ersABrqCuVH4ZWu/ovC/vbnHgNYeWDW00gB6SKDn4/RJJ7C2+XJmXmbA1xIiGALULhFxmTf4ogBWGsKaaDBXC9gtxekzZP6SpZfwypOcBtD7guhxHhOth2IBLO5xAZh8TLTe4IgCAMOeuacLuXKuAAAAAElFTkSuQmCC',
  hero_dead: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAABV0lEQVR42mNgGOmAEZfElMU7oigxOCfWYxkx6pgGXQig+7wwJXgpKQb2z1kbTUpIDJ4QwOXz1knLSDKwOi+KpJAY8BBgQRdA93lrUw0DAwMDw8Nbl/AaJK+mx4CsD2YOekgM/hAgBESFeFD4r999ocgBgy8Efv/8agtNzYeR4xQWx69sLVHU//d3xZoLYOYwMDDIDc00gCskFKC5Ah18e3MP3efkOWDK4h1y0ILjESU+g5lDcS5ADwkuESWq+JzoyggWEqzs3EQ5AN3nhCojgiGAy+IBK4iIjXNiGyQEa0NifQ6LiqHfHsDl865gbqwGlK39SlFIDN6SEN3H6ZNO4M3nM/MsDkNYuhAfD9n2AKxAyZl5+TADAwPDlHRdFB+ihwTC59C4nnmZgRifk10OYJTxpxtwdUweEVMnEKwNYSGB8DL+fsLwrQ3xFLmPqFIQEaoNaVUnAACX2sQlgPuzHQAAAABJRU5ErkJggg==',
  enemy_generic: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAABYklEQVR42mNkIADeu7hUMFAABPfs6cAnz8QwwICRWJ+LHT7eTorBr2wtK4kJmcEXArh8/srWkgFNnFAIYFWPHjKDJwSI9fns0FySLEhdPRlvSAy+EID5vHXSMqJ8xLhxNwr/v78rUSFWnRc1ONIAC7klHbrP0cXRQ2LQloQs6KkeV9ynxfhBGFAa5kP08gCWa2AhkQYVn7Vk0yAPAXIBejlBKhjwEBh1ADwN/P75NQxaQq3ClhtgqRhWEuIqB9BLREJ1x9DNBTAfEqoLiHbAexcXZWIaGlSvDdHrAsE9e+4yMDAwsLJzr8JXMpIKYLUfLK3B04Dgnj0dhJrOdE0DuHwO88GUdF28BubMvMxASsix0NvHsLSG0wGwtppguj9KWqBWnDMwMOB3ACwR0hrA0h3BKED3Qc7My6uISQtYfE5cGkCPI0pDBN08ihMhzGewkCDVx2R3TnEVVLgcgCUksZY1AODIqUn/J1qBAAAAAElFTkSuQmCC',
  i_flame: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAz0lEQVR42mNgGAVDHdRe/vOfEv1M1LCcEkcwUcvn5DqCiZrBTo4jmAY6DTFR6vsSpb8UhQITNSynxBFMtMpuxKon2gHNuiyM+IIenY+uftAmQrKy4MevP3FimiZCGOi5x0ySOM1yATUSLCMlBiInPFy+J5QYmahhOTY+saHBSE4w4rKMUDrAFhokJ0J8lhMjT7QDcMUdoZROaloYerUhXcsBfFkI3TJSE9/QiQJiQoFc31MlBMiJ90EVBYzEKkQvGbEFLTFq6NYDorTHNHIAANcdmemvHu1aAAAAAElFTkSuQmCC',
  i_crown: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAoklEQVR42mNgGAWjYBQMdVB7+c9/SvQzDbQHmKjhe0pCgYlWQU2s+qERBdiCGt2H2OSICYUBDwFGWme1Zl0WRopCgNJ8Tkj/4E6ElPqeGHMGdwgQSkDUSIiMlERBidJfOLvnHjNZjmAi1vISpb8oFiKz0fnoavF5hqg0gM9iStQOnboAOX5hbPQ4xyZOKF1QnAipkRMGPBsyUaKZGpXRKBgFAHTqY6scKg2vAAAAAElFTkSuQmCC',
  i_chain: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAoElEQVR42mNgGAWjYBSMgpEOGIlVWHv5z390sWZdFrj+j19/Ysjzc7MTNJ+JXMuRxbFZjk+cJAfgspxYSwjJM5JiOXKQ117+879E6S/OIEe3GFd0MBGbBpAtx8ZHt4CY+CfJAbQCow4YOg5AzxHofPRUT0wZQFRJSKgcQM+K2AC+HMFEavYjtbglJM9EThmALo7LEmLLglEwCkbBKBhQAACF+kYYOTG/KAAAAABJRU5ErkJggg==',
  i_eye: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAm0lEQVR42mNgGAWjYBSMggEGjIQUTFm84z+lluTEeuC0h2nQhwAM1F7+Q3JINOuyMFLsAHwWlyj9hbN77jGT5RBGcixHthgd4HIILkcwDaksU3v5z/+PX3+iYG5+MQwxmiRCGEC2QEpKFi7+7NljOJufm51oc5lIDQFkPsxSZMupmg1HRCIc3OXAoCgJSXUMMZaOglEwCkbBoAIAZUxfJdScGq4AAAAASUVORK5CYII=',
  i_wheel: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAABgUlEQVR42u1WoY6DQBAd2k0qKirx9ST8AgniNJ4/qKxFYSvvD/DVFST9BRJ8PRKBIKHZU0OGze4yS7mcOEbB7jLz5s3bYQA22+y/m7fko6weJD77VQkAAE0YAwBAHggnn2Jp4LkzXCC7NYOr57+Lh1wFQFYPEqlGywPh0SzVjPH8HAjhEtyvSrikX0ZqEQQNitpYxADSTp2g87brZdv1YyB81gW3lY+tAZq5iVa6bmOKBUCHmjot7s/JHn3XBTexwGIAa9t2vUyTaFy/vfbQhPGkRGkSjeXgXEWxpBGlSQS3136y1oQxXM/v9Trh3PXRqVu9qrYSOovwt0xwMqQaQMH5VTk5g9mjRk7Hg8fpoOxOiE6p2q/nN/hVOaG+uD/Zwa0AdAqmuqC3QX3X6cd0I9ga4DQZTrNyAoCoKcUY5HQ8eEg1rTkFgd/Z+sGO04RQbE0YQ1YP0lRb3NOJ8+OJyBRUnYjUvbl/ArsT5oHwXIYS7kTk1IrRqQ2I60y42WZ/bj8C7dqWc4kKrwAAAABJRU5ErkJggg==',
  i_skull: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAsElEQVR42u2VMQrAIAxFVQodOnTrUOj9D1bo3qGDk52EIqj5iVKEvElRkxh/jDGKovyM5Ry6Hx/ieF1mm84RW07inLMuCoBqHAnCtXaO7nc9nCPnJo7hfT+y8+s6TVcRps6XdQul9eYBtGa8AGpvjGrAStRMEV/tZ2Q/QakSuvSCXBbSXoDcHsoA2mSo+7UMnVSA35+QI8SxMkAVFiJYOAM142i1sLkfH2L9f8eKgvICXrpTT9NWDrMAAAAASUVORK5CYII=',
  i_scales: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAyElEQVR42mNgGAWjYBQMdVB7+c9/SvQzUcNyShzBSIyij19/km0BPzc7I0UhQInlxOhnItYHi9ftZ1i8bj/RFsPUUxwC6MHIz83OCMM995gZYBhZnJClZCXCnFgPRgYGBoYpi3cQjBKYGpgemuUCaoBRB5DkAGLSASnxz8DAwMBCanH7koC6l2h6mnVZGCkqCSkt6wk5YvCnAVyuRxcnVh1ZlREx0UPIokEbBYzk+piShEdWCJCaG4hVP3RKQlITGbmJchSMPAAAGIdW2yi+COsAAAAASUVORK5CYII=',
  i_cloud: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAm0lEQVR42u2UMQ6AIAxFC3ISdm/H6uTq7dw9iUQnEoKAFAoO9k0GTf+DFgEYhmH+jqAqtOzn5Z7XWYlhAn5wSImI7BVe8h4AQFEGdp2BMNxo+/hmOyZ0K1TNrmPhbj0lUSWQC48FGW3REpIq3F9PnVCxQE342xw03wJMYZIWUJK7vkME0CeA+Zd3EaCWyNX6vAWidYhqd84wjOMGiXpJCTstBSIAAAAASUVORK5CYII=',
  i_question: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAkElEQVR42mNgGAWjYKQDRnI11l7+8x9drFmXhZHmDsBmMSUOYaK25aSoIykE0A3F5kti1FAUAoQMJicNMFHLcmzyxEQFC7UsJhcwUdMwUhIf1R0As5xURzANlM8pLgmpVSIyDaTlFDsA3TJa5RSapoFRQDH4+PXn/49ff5IdBUyUWo6NPWBF8ZCMglEwCkYBAKCbTpyOVYJ+AAAAAElFTkSuQmCC',

  slime: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAABVElEQVR42mNgGOmAkZACpaNxFZRYcM96UQc+eaZBFwK4fPzYaW07KQbL7guuJCZEBk8IoPsc3cey+4JJMvix01q8IQILiYEPAVw+J9XHxIYIekgMeAiwkOrzaL55eOWXfkrClSvQ7akcXCFACMB8XqzETKDom4c3JAZfScjKzv0fX9yfM1hIkQVGF+Lx5ooBDwGSHSAqxMMgKsRDtPpzBgvxhuKgqAtCGRgYGFjZuVdRMy0QivvfP7+GDa1yAN1Hl1k4UPi6f34QVRfAfA53gNLROGVs1SetAcxeeAjAXPbYae0qcmpDUkOE5Cigts9xOgA9JHC1iGA+JORzQlHLgu6ye9aL7tIjJGBNMpxRgJ5acaUNXHGNK9UzMDCgRAHTPetFHchNZaWjccro8TQoygFcaYNQyFGtYwJLG7Aim1gH4ApNgmmAWj6keueUUC4h5GN0AADtR6kxkbFAGwAAAABJRU5ErkJggg==',
  goblin: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAABm0lEQVR42mNkwAGUjsblMeAB96wXTaJEPQwwMQwwYCTk88dOayci82X3BefjM5CQevSQGDwhgMvnsvuC0X2I1WekqoeFxMCHALE+xxLXDGhxTZR69JAYPCFAyOfnDBaSZLDRhXiiQmLAQ4CFkAKYz//7u6IG3cbdKHx0+XNQeVwhMWjSAAuxCmeH5qIKLNmEykeTTyPS3IHPBazs3P+xpX5Y3M9C82m2wVa8Bk694I0aEjF+WNMCLDcMeAiMOoCRgYEhlIGBgYGVnXsVKWmBECAU979/fg0bGuUAzAfnYlDrAgFuxjBk/oev/1cRUxdgOEDpaJwktuqV1gBmL7w2vGe96Dm+tABz4JR0XbwG58y8zIBPPyzuYQ4YfGkA5sLHTmtXofgYSiP5EGubEK5+5S0U9TBzcToAFiSwqCAE0NWxsnOTFPeDpzqGNY9hiZHYXIHuE1LVw+zFWQ7A4ixn5mWUXCEbroarB8TAwMDA0Ikj1TMwMEjiTQPoIUErgN41I1gSoucKXH0+9BDBleqJLooJ5QpicwF63KMDAOpe3PS2TXKqAAAAAElFTkSuQmCC',
  skeleton: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAABUElEQVR42tVXOw7CMAxNKhBDkBohcS3YmBgp3IBDcAM+I1M3uBZSBRIMiAEWngRRXdsU0ZCtrZP6PT+/utYw63i5T0yN5Z3dVD1PTMPLShH3e9215uBDcc4kjMTDQIg8RHwozqqD+71uJSNgonEGWlSttYhLNECdm0WlgURT07CudeKiYaAldTrUFOhKaqzqFry3eR9AJpz6V9v92/V0PFA9L2Eqi9MHuEUhoxih4uPpAu0GCplUA/HNA+gC7+zJGGPaHZd/41tAqf92vYyePpD+lwYop/POjgKHy5l9+ev95GVjCloa0QA3D4RIF8tdXnXwfDYUMZN4Zzfc6PzTmZDrBo4JKXJ0g9qIoBMkysXV7gLuOx863nwm8wEyAWTOjVUUQilyxJEMIFNoQeoDiA/PYUuATqj7MypFLtZACYJU80/onf1MhJ+qPYynNAHGH0FK0C5j6uQKAAAAAElFTkSuQmCC',
  wolf: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAABhUlEQVR42mNkQAO/J9nkMeABrHlHJuGTJ1U/E8MAA0ZcLucqPT8Rmf+t2zAfn0/I1T/wIYDL5a2TlqEorM6LwuoTdECq/sETArhcjg5gPsEFiNUPC4mBDwFWdu7/+FyeunoyqoaNu/Ea+N/fFYU/OzQXb0gMeAiwEAwiAj4mqH7JJrzqBzwESHaAqBAPg6gQD9XUDYq6IJSBgYGBlZ17Fb7ckBbjR5LBs3DEPSz1//75NWxwhQC8liIQEuQCdJ/Ds+HvSTaS0OrxOT19DrMXoxyAubA6L2oVvlqN2LoAl88xCiJ6hQTMHpwlIa40APPJlHRdvBbkQNXB9MNoWIgyMDAMsfYAsT7HCImZlxmIaRkN3toQl8/TJ51ASc0z8yxW4ZPnv9q+ioGBgeGjduUgrQtgaQCW/WC5AL1cwAUIhQCuXEZ0g4RQPp535w9eeULlCs6SkNTUDgNJ3Yb4PQA1H6MoxlUSovuI0hCDRzWUZqE0EWEJMZIczEhutxo98WIJyUnEdNsB6b3VTX1o50oAAAAASUVORK5CYII=',
  bat: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAABX0lEQVR42s1Xu3LCQAyUM2Yo4Af4IFpC4xQMNaXpaKhp6EyZmklBGpKWD+IHoGAoTAFiYDnd6Rw7d2qY8UPaXa1PIqFbbGdlTooYLpOV7b5vnjcKHAkizopuYXrwe3qY2pSomie4AikiXqy+jA9m+fU+M5B67ZsnvAda7U5pQ4wxz0fGXrqYS3ni8YA2mCH3Eq/7RngPEFFGRNRqdzY2JpPxwCvx5/rX2vvz6fgRlwcY0TwfbTQ9Ld/7z1L+7FSu5zp3ANtZ2bsdrfv/ZM5177MAAUiecHkBey8xZwApXmhaCa7jPAckT0ju1vb8xYQ8VrkVTSmBzLmu8yT0/Tq0zF9a0JQSEvPKswCZ/nUWpNKyiEpkRbdW5o+zgDS7HTOUeoznhrQ3IJAopqFRAdxqta5GRXAbrs2Ehh7vazGhAXGlxKwYAlUDwMKuRJIi/Cu9H+9SKiHW/jl1KRaNAsHjAliF66S3S1klAAAAAElFTkSuQmCC',
  spider: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAABtElEQVR42tVXsU4CQRCdM0souNof4Css/AVDsxbEVjvPjkCoCYbutJPWWBwN8Rcs/Ap+wFoLY4ENQ27f7TC7HHhxun3ZnXtvdnZmLlkO1kOKsN4suS+v654/oYZtS8Dm6dTm6RQ3SHjoPsSXg/WwHLXGI5C02p01EdHi7nOEzH24lgPSOcTZjyk5Xm0cduGDXtyTXCsiola7E4SzGWZk87TYYCNgSjFZj8pb7U7hw7cENOaa8hKx7j6RNBpzm6dRScVCQs8ZjfmhTPJrfO+WiGjy8HJQAjZzXwHnkkGGsSGvXQeYiab8evHorE/f3p31x/mZs57bW6+fcdZ3cq7xSmhCN6KiCaznynlU3lgv6M2SFb+4qAjcXF1Efejp+dWN2Ca3xlnfqbjNd0N+BaWSXByjDvyfHPj5/rqEu6J9IsKK0a/4DLEnHMvEbohdEBlzRBCX9ks4Tkbmr+5e6jVmx8y2UwneLe5DHCct/p6RZjuJsTTphOYSTmCVqRjrAeLaqMXKOAIabjTl2qSEillZKB49FWt29KlY+jGJnYorVyAxrGtaJCvNSLprVO7JheGurJci+QubWGPTb8K0FgAAAABJRU5ErkJggg==',
  boss: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAABkklEQVR42mNkwAG+nkxrYsADuM1n1VGiHgaYGAYYMBLyuYDd0lpk/odD0c34DCSkHj0kBk8I4PL5h0PR6D7E6jNS1cNCYuBDgFifY4lrBrS4Jko9ekgMnhDA5fPda2di1Wh/zhWFf9BoN1Z1rsHpeENiwEOAhViFDvWo/AONuwnIE2fuwKcBVnbu/8SkYhj4rTMTrzzrlXSizIGlhcGbBqZe8EbhZxtsJcmHuPQPytowlIGBgYGVnXsVtrSA7pPU1ZPxGjg7NBevz2Fx//vn17DBFQLwVExkSBAChHwOT4RfT6bpQqvHy/T0OcxejFwAc6GA3VKUkID5aMnSS3gNjonWI8rnGNmQXiEBswdnOYArDZALYObAQpSBgQGlPcACaxoRalZTG8DsZcGjIAwt6FaRaEEYtpAddCUhzlyAC6RPOhFGIBdg9SmSubpEVUboqZXS1I4rdxFsEaH3dGBxiR5SMHGk1nItMT0pFnJ9jq4OvZlOrLmMJPRuLxPjQBLU1WHtnKI7CFfcERvHSCUs1u45APwb1mTbD7S3AAAAAElFTkSuQmCC',
};

const SPRIMG_IMG = (() => {
  const out = Object.create(null);
  for (const k in SPRIMG){
    if (k === 'none') continue;
    const im = new Image();
    im.decoding = 'async';
    im.src = SPRIMG[k];
    out[k] = im;
  }
  return out;
})();

const SPR = (() => {
    const PAL = {
      '.': null,
      'K': '#0b0f16',
      'D': '#0f1b2d',
      'W': '#f1f5f9',
      'S': '#94a3b8',
      'B': '#3b82f6',
      'G': '#22c55e',
      'Y': '#f59e0b',
      'P': '#a855f7',
      'R': '#ef4444',
      'T': '#a16207',
      'O': '#fb923c'
    };

    // 16x16 sprites: '.' is transparent
    const SPRITES = {
      hero: [
        '................',
        '......KKKK...Y..',
        '.....KSSSSK..Y..',
        '....KSDSSDSK..T.',
        '...KSDWWWWDSK.T.',
        '...KSDWRRWDSK.T.',
        '...KSDWSSWDSK.T.',
        '....KSDYYYYDK.T.',
        '....KSDDDDDDK.T.',
        '...KSDDDDDDDDKT.',
        '...KSDDDYYDDDKT.',
        '...KSDDDDDDDDKT.',
        '....KSDDTTDDK.T.',
        '.....KTT..TK..T.',
        '.....KTT..TK..T.',
        '....KK....KK..K.',
      ],
      hero_dead: [
        '................',
        '................',
        '....KKKKKK......',
        '...KSSSSSSK.....',
        '..KSDWWWWDSK....',
        '..KSDWKKWDSK....',
        '...KSDRRRDK.....',
        '....KSDDDK......',
        '.....KDDK.......',
        '....KDDDK.......',
        '...KDDDDDK......',
        '..KDDTTTDDK.....',
        '..KTT....TTK....',
        '...KTT..TTK.....',
        '....KKKKKK......',
        '................',
      ],
      enemy_generic: [
        '................',
        '.....KKKKKK.....',
        '....KRRKKKKRRK..',
        '...KRRSSSSSSRRK.',
        '..KSSSRRWWRRSSSK',
        '..KSSSRWWWWRSSSK',
        '.KSSSWWRKKRWWSSK',
        '.KSSSWWRRRRWWSSK',
        '.KSSSWWRRRRWWSSK',
        '..KSSSRWWWWRSSSK',
        '..KSSSRRWWRRSSSK',
        '...KSSSSSSSSSK..',
        '..KSSKTTTTKSSK..',
        '....KKTTTTKK....',
        '......KTTTK.....',
        '.......KK.......',
      ],
      slime: [
        '................',
        '................',
        '.....KKKKKK.....',
        '...KKGGGGGGKK...',
        '..KGGGGGGGGGGK..',
        '.KGGGGBBBBGGGGK.',
        '.KGGGBWWWWBGGGK.',
        'KGGGWWWWWWWWGGGK',
        'KGGGWWKWWWWWWGGK',
        '.KGGGWWWWWWGGGK.',
        '.KGGGGGYYGGGGK..',
        '..KGGGGYYYYGGK..',
        '...KKGGGYYGGKK..',
        '.....KGGGGGK....',
        '......KKKK......',
        '................',
      ],
      goblin: [
        '................',
        '....KK....KK....',
        '...KGGK..KGGK...',
        '..KGGGGKKGGGGK..',
        '.KGGGWWWWWWGGGK.',
        '.KGGWRRWWRRWGGK.',
        '.KGGWSSSSSSWGGK.',
        'KGGWSSYYYYSSWGGK',
        'KGGWSSYYYYSSWGGK',
        '.KGGWSSSSSSWGGK.',
        '.KGGGWW..WWGGGK.',
        '..KGGKTTTTKGGK..',
        '...KTTK..KTTK...',
        '...KTTK..KTTK...',
        '....KGGKKGGK....',
        '.....KK..KK.....',
      ],
      skeleton: [
        '................',
        '.....KKKKKK.....',
        '...KKWWWWWWKK...',
        '..KWWWWWWWWWWK..',
        '..KWWKWWWWKWWK..',
        '..KWWWKWWKWWWK..',
        '.KWWWSSWWSSWWWK.',
        '.KWWWSWWWWWSWWK.',
        '.KWWWSSWWSSWWWK.',
        '..KWWWWWWWWWWK..',
        '..KWWKWW..WWKWWK',
        '..KWW..SSSS..WWK',
        '...KWW..SS..WWK.',
        '...KKW..WW..WK..',
        '....KK....KK....',
        '................',
      ],
      wolf: [
        '................',
        '...KK......KK...',
        '..KSSK....KSSK..',
        '.KSSSSKKKKSSSSK.',
        'KSSSRRWWWWRRSSSK',
        'KSSSWWWWWWWWSSSK',
        'KSSSWWKWWWWKSSSK',
        '.KSSSWWWWWWSSSK.',
        '..KSSSSSSSSSSK..',
        '...KSSKKKKSSK...',
        '..KSSKTTTTKSSK..',
        '.KSSKTTTTTTKSSK.',
        '.KSKTT..TT..TSK.',
        '..KK....TT....KK',
        '........KK......',
        '................',
      ],
      bat: [
        '................',
        '..KKK......KKK..',
        '.KSSSK....KSSSK.',
        'KSSSSSK..KSSSSSK',
        'KSSSSSSKKSSSSSSK',
        '.KSSSWWWWWWSSSK.',
        '..KSSWWRRWWSSK..',
        '...KSSWWWWSSK...',
        '....KSSSSSSK....',
        '.....KSSSSK.....',
        '.....KSKKSK.....',
        '....KSK..KSK....',
        '...KK......KK...',
        '................',
        '................',
        '................',
      ],
      spider: [
        '................',
        '.K..K....K..K...',
        'K..K......K..K..',
        '.K..........K...',
        '...KKKKKKKKKK...',
        '..KSSSSSSSSSSK..',
        '.KSSSRRKKRRSSSK.',
        '.KSSSSSSSSSSSK..',
        '.KSSSWWWWWWSSSK.',
        '..KSSSSSSSSSSK..',
        '...KKSSSSSSKK...',
        '..K..K..K..K..K.',
        '.K..K....K..K..K',
        'K..K......K..K..',
        '.K..........K...',
        '................',
      ],
      boss: [
        '................',
        '....KK....KK....',
        '...KYYK..KYYK...',
        '..KYYYYKKYYYYK..',
        '.KYYPPPRRPPPYYK.',
        '.KYYPWWPPWWPYYK.',
        'KYYYYYWWWWYYYYYK',
        'KYYSSYYYYYYSSYYK',
        '.KYYSSRRRRSSYYK.',
        '..KYYSSSSSSYYK..',
        '...KYYTTTTYYK...',
        '..KYYYTTTTYYYK..',
        '..K..YTTTTY..K..',
        '.....Y....Y.....',
        '....KKK..KKK....',
        '................',
      ],
      // fx
      fx_slash: [
        '................',
        '........W.......',
        '.......WWY......',
        '......WWYY......',
        '.....WWYY.......',
        '....WWYY........',
        '...WWYY.........',
        '..WWYY..........',
        '.WWYY...........',
        'WWYY............',
        'YY..............',
        '................',
        '................',
        '................',
        '................',
        '................',
      ],
      fx_claw: [
        '................',
        '........R.......',
        '.......RRO......',
        '......RROO......',
        '.....RROO.......',
        '....RROO........',
        '...RROO.........',
        '..RROO..........',
        '.RROO...........',
        'RROO............',
        'OO..............',
        '................',
        '................',
        '................',
        '................',
        '................',
      ],
      fx_spark: [
        '................',
        '................',
        '.......Y........',
        '......YWY.......',
        '.....YWYWY......',
        '......YWY.......',
        '.......Y........',
        '................',
        '................',
        '................',
        '................',
        '................',
        '................',
        '................',
        '................',
        '................',
      ],
      fx_crit: [
        '................',
        '.......R........',
        '....Y..RY..Y....',
        '.....YRRRY......',
        '..Y..RRWRR..Y...',
        '...YRRRWRRRY....',
        '....YRRRRY......',
        '....Y..RY..Y....',
        '.......R........',
        '................',
        '................',
        '................',
        '................',
        '................',
        '................',
        '................',
      ],


      // items
      w_sword: [
        '.......WW.......',
        '......KSSK......',
        '......KSWK......',
        '......KSSK......',
        '......KSWK......',
        '......KSSK......',
        '......KSWK......',
        '......KSSK......',
        '......KSWK......',
        '......YKKY......',
        '......KYTK......',
        '......KTTK......',
        '......KYTK......',
        '......KTTK......',
        '......KBBK......',
        '.......KK.......',
      ],
      w_axe: [
        '................',
        '................',
        '....KSSK........',
        '....KWSK........',
        '...KKWSK........',
        '....KSSK........',
        '....KSSKKTK.....',
        '........KTK.....',
        '........KTK.....',
        '........KTK.....',
        '........KTK.....',
        '........KTK.....',
        '........KTK.....',
        '........KTK.....',
        '........KTK.....',
        '.........K......',
      ],
      w_spear: [
        '.......WW.......',
        '......SSSS......',
        '.......WW.......',
        '......KTTK......',
        '......KTTK......',
        '......KTTK......',
        '......KTTK......',
        '......KTTK......',
        '......KTTK......',
        '......KTTK......',
        '......KTTK......',
        '......KTTK......',
        '......KTTK......',
        '......KTTK......',
        '.......KK.......',
        '.......KK.......',
      ],
      w_dagger: [
        '................',
        '.......WW.......',
        '......KSWK......',
        '......KSSK......',
        '......KSWK......',
        '......KSSK......',
        '......KSWK......',
        '......YKKY......',
        '......KTTK......',
        '......KTTK......',
        '......KTTK......',
        '.......BB.......',
        '.......KK.......',
        '................',
        '................',
        '................',
      ],
      w_bow: [
        '................',
        '................',
        '....KT.W..TK....',
        '...KT..W...TK...',
        '...KT..W...TK...',
        '...KT..W...TWW..',
        '...KT..W...TK...',
        '...KT..W...TK...',
        '...KT..W...TK...',
        '....KT.W..TK....',
        '................',
        '................',
        '................',
        '................',
        '................',
        '................',
      ],
      w_staff: [
        '.......PP.......',
        '......PBBP......',
        '.......YY.......',
        '......KTTK......',
        '......KTTK......',
        '......KTTK......',
        '......KTTK......',
        '......KTTK......',
        '......KTTK......',
        '......KTTK......',
        '......KTTK......',
        '......KTTK......',
        '......KTTK......',
        '......KTTK......',
        '......KTTK......',
        '.......KK.......',
      ],
      w_hammer: [
        '................',
        '......WWWW......',
        '....KSSSSSSK....',
        '....KSSSSSSK....',
        '.....KKKKKK.....',
        '......KTK.......',
        '......KTK.......',
        '......KTK.......',
        '......KTK.......',
        '......KTK.......',
        '......KTK.......',
        '......KTK.......',
        '......KTK.......',
        '......KTK.......',
        '......KTK.......',
        '.......K........',
      ],
      w_mace: [
        '................',
        '.......K........',
        '......KWK.......',
        '.....KWSWK......',
        '......KWK.......',
        '.......K........',
        '......KTK.......',
        '......KTK.......',
        '......KTK.......',
        '......KTK.......',
        '......KTK.......',
        '......KTK.......',
        '......KTK.......',
        '......KTK.......',
        '.......B........',
        '.......K........',
      ],
      w_wand: [
        '................',
        '.......P........',
        '......PBP.......',
        '.......Y........',
        '......KTK.......',
        '......KTK.......',
        '......KTK.......',
        '......KTK.......',
        '......KTK.......',
        '......KTK.......',
        '......KTK.......',
        '......KTK.......',
        '.......B........',
        '.......K........',
        '................',
        '................',
      ],
      w_katana: [
        '................',
        '................',
        '....KS..........',
        '.....KS.........',
        '......KS........',
        '.......KS.......',
        '........KS......',
        '.........KS.....',
        '..........KT....',
        '...........KT...',
        '............KT..',
        '.............KT.',
        '............KBK.',
        '.............K..',
        '................',
        '................',
      ],

      w_greatsword: [
        '.......WW.......',
        '......KSSK......',
        '......KSWK......',
        '......KSSK......',
        '......KSWK......',
        '......KSSK......',
        '......KSWK......',
        '......KSSK......',
        '......KSWK......',
        '.....YYKKYY.....',
        '......KTTK......',
        '......KTTK......',
        '......KTTK......',
        '......KTTK......',
        '.......BB.......',
        '.......KK.......',
      ],
      w_rapier: [
        '.......W........',
        '......KSSK......',
        '......KSWK......',
        '......KSSK......',
        '......KSWK......',
        '......KSSK......',
        '......KSWK......',
        '......KSSK......',
        '......KSWK......',
        '......KSSK......',
        '.....YYKKYY.....',
        '......KTTK......',
        '......KTTK......',
        '......KTTK......',
        '.......BB.......',
        '.......KK.......',
      ],
      w_scythe: [
        '................',
        '................',
        '.........KKW....',
        '........KKW.....',
        '....KTKKKW......',
        '....KTKKW.......',
        '....KTKW........',
        '....KTK.........',
        '....KTK.........',
        '....KTK.........',
        '....KTK.........',
        '....KTK.........',
        '....KTK.........',
        '....KTK.........',
        '....KTK.........',
        '.....K..........',
      ],
      w_flail: [
        '................',
        '................',
        '............K...',
        '...........WW...',
        '..........SWW...',
        '.........S...K..',
        '........S.......',
        '.......S........',
        '.....KTK........',
        '.....KTK........',
        '.....KTK........',
        '.....KTK........',
        '.....KTK........',
        '.....KTK........',
        '.....KTK........',
        '................',
      ],
      w_crossbow: [
        '................',
        '................',
        '................',
        '.......W........',
        '.......W........',
        '...SSSSSSSSSS...',
        '...KSSSWSSSSK...',
        '.....TTWTTT.....',
        '......KTK.......',
        '......KTK.......',
        '......KTK.......',
        '......KTK.......',
        '......KTK.......',
        '................',
        '................',
        '................',
      ],
      w_glaive: [
        '................',
        '.........KKW....',
        '........KKKS....',
        '.......KKKS.....',
        '......KTK.......',
        '......KTK.......',
        '......KTK.......',
        '......KTK.......',
        '......KTK.......',
        '......KTK.......',
        '......KTK.......',
        '......KTK.......',
        '......KTK.......',
        '......KTK.......',
        '......KTK.......',
        '.......K........',
      ],
      w_gun: [
        '................',
        '................',
        '................',
        '................',
        '................',
        '...KY......W....',
        '..KYSSSSSSSS....',
        '..KYSSSSSSSS....',
        '...KY...KTK.....',
        '........KTK.....',
        '........KTK.....',
        '........KTK.....',
        '........KTK.....',
        '................',
        '................',
        '................',
      ],
      w_grimoire: [
        '................',
        '................',
        '....KKKKKKKK....',
        '...KPPPPPPPSK...',
        '...KPPPPPPPWK...',
        '...KPPPPPPPSK...',
        '...KPPPPPPPWK...',
        '...KPPPPPPPSK...',
        '...KPPPYYPPWK...',
        '...KPPPPPPPSK...',
        '...KPPPPPPPWK...',
        '...KPPPPPPPSK...',
        '...KPPPPPPPSK...',
        '....KKKKKKKK....',
        '................',
        '................',
      ],
      a_armor: [
        '................',
        '................',
        '.......YY.......',
        '....KDDDDDDK....',
        '....KDDDDDDK....',
        '....KYDDDDYK....',
        '....KYDDDDYK....',
        '....KYDDDDYK....',
        '....KYDDDDYK....',
        '....KYDDDDYK....',
        '....KYYYYYYK....',
        '....KYDDDDYK....',
        '....KYDDDDYK....',
        '.....KKKKKK.....',
        '................',
        '................',
      ],
      acc_ring: [
        '................',
        '................',
        '................',
        '................',
        '.......YW.......',
        '......Y..Y......',
        '.....Y....Y.....',
        '.....Y....Y.....',
        '......Y..Y......',
        '.......YY.......',
        '................',
        '................',
        '................',
        '................',
        '................',
        '................',
      ],
      acc_amulet: [
        '................',
        '................',
        '................',
        '......SSSS......',
        '......KKKK......',
        '.....KYYYYK.....',
        '.....KYYYYK.....',
        '.....KYBBYK.....',
        '.....KYYYYK.....',
        '.....KYYYYK.....',
        '.....KYYYYK.....',
        '......KKKK......',
        '................',
        '................',
        '................',
        '................',
      ],
      acc_charm: [
        '................',
        '................',
        '......KKKK......',
        '.....KWWWWK.....',
        '.....KWSSWK.....',
        '.....KWWWWK.....',
        '.....KWWWWK.....',
        '.....KWWWWK.....',
        '.....KWWWWK.....',
        '.....KWRRWK.....',
        '.....KWRRWK.....',
        '.....KWRRWK.....',
        '.....KWWWWK.....',
        '......KKKK......',
        '................',
        '................',
      ],

      // v18: pixel art readability (integer scaling) + compact numbers + 行 bar styling + smaller rarity pill
      acc_talisman: [
        '................',
        '................',
        '.....KKKKKK.....',
        '....KWWWWWSK....',
        '....KWWWWWSK....',
        '....KWWPWWSK....',
        '....KWWRWWSK....',
        '....KWWPWWSK....',
        '....KWWRWWSK....',
        '....KWWPWWSK....',
        '....KWWRWWSK....',
        '....KWWWWWSK....',
        '.....KKKKKK.....',
        '................',
        '................',
        '................',
      ],
      acc_bracelet: [
        '................',
        '................',
        '................',
        '................',
        '................',
        '................',
        '.....K....K.....',
        '.....BYBYBY.....',
        '.....YYYYYY.....',
        '.....K....K.....',
        '................',
        '................',
        '................',
        '................',
        '................',
        '................',
      ],
      acc_pendant: [
        '................',
        '................',
        '................',
        '.......YY.......',
        '......KYYK......',
        '.....KY..YK.....',
        '.....KY..YK.....',
        '.......PP.......',
        '.......YY.......',
        '.......YY.......',
        '......K..K......',
        '................',
        '................',
        '................',
        '................',
        '................',
      ],
      acc_earring: [
        '................',
        '................',
        '................',
        '........S.......',
        '........S.......',
        '.......KKK......',
        '......KPPPK.....',
        '......KPBPK.....',
        '......KPPPK.....',
        '......KPPPK.....',
        '.......KKK......',
        '................',
        '................',
        '................',
        '................',
        '................',
      ],
      acc_sigil: [
        '................',
        '................',
        '................',
        '.....KKKKKK.....',
        '....KDDDDDDK....',
        '....KDDDDDDK....',
        '....KDDYYDDK....',
        '....KDYYYYDK....',
        '....KDDYYDDK....',
        '....KDDYYDDK....',
        '....KDDDDDDK....',
        '....KDDDDDDK....',
        '.....KKKKKK.....',
        '................',
        '................',
        '................',
      ],
      acc_gem: [
        '................',
        '................',
        '................',
        '................',
        '........K.......',
        '.......KBK......',
        '......KB.BK.....',
        '.....KB...BK....',
        '.....K..W..K....',
        '.....BK...KB....',
        '......BK.KB.....',
        '.......BKB......',
        '........B.......',
        '................',
        '................',
        '................',
      ],
      acc_beads: [
        '................',
        '................',
        '................',
        '................',
        '................',
        '.......YY.......',
        '......B..B......',
        '.....B....B.....',
        '......Y..Y......',
        '.......YB.......',
        '................',
        '................',
        '................',
        '................',
        '................',
        '................',
      ],
      acc_watch: [
        '................',
        '................',
        '.......SS.......',
        '.......SS.......',
        '.......SS.......',
        '.......YY.......',
        '......Y..Y......',
        '.....Y.WW.Y.....',
        '.....Y..W.Y.....',
        '......Y..Y......',
        '.......YY.......',
        '.......SS.......',
        '.......SS.......',
        '.......SS.......',
        '................',
        '................',
      ],

      unique: [
        '................',
        '.......KK.......',
        '.......WW.......',
        '.......YY.......',
        '.......YY.......',
        '.......YY.......',
        '.......YY.......',
        '.......YY.......',
        '.......YY.......',
        '......YPPY......',
        '......P..P......',
        '.....P.BB.P.....',
        '......B..B......',
        '................',
        '................',
        '................',
      ],      // v13 override (hero)
      hero: [
        '................',
        '......KKKK...Y..',
        '.....KSSSSK..Y..',
        '....KSDSSDSK..T.',
        '...KSDWWWWDSK.T.',
        '...KSDWRRWDSK.T.',
        '...KSDWSSWDSK.T.',
        '....KSDYYYYDK.T.',
        '....KSDDDDDDK.T.',
        '...KSDDDDDDDDKT.',
        '...KSDDDYYDDDKT.',
        '...KSDDDDDDDDKT.',
        '....KSDDTTDDK.T.',
        '.....KTT..TK..T.',
        '.....KTT..TK..T.',
        '....KK....KK..K.',
      ],
      hero_atk: [
        '............BB..',
        '......KKKK..YY..',
        '.....KSSSSK.YY..',
        '....KSDSSDSK..T.',
        '...KSDWWWWDSK.T.',
        '...KSDWRRWDSK.T.',
        '..WKSDWSSWDSK.T.',
        '...WKSDYYYYDK.T.',
        '....YSDDDDDDK.T.',
        '...KSDDDDDDDDKT.',
        '...KSDDDYYDDDKT.',
        '...KSDDDDDDDDKT.',
        '....KSDDTTDDK.T.',
        '.....KTT..TK..T.',
        '.....KTT..TK..T.',
        '....KK....KK..K.',
      ],
      hero_dead: [
        '................',
        '................',
        '....KKKKKK......',
        '...KSSSSSSK.....',
        '..KSDWWWWDSK....',
        '..KSDWKKWDSK....',
        '...KSDRRRDK.....',
        '....KSDDDK......',
        '.....KDDK.......',
        '....KDDDK.......',
        '...KDDDDDK......',
        '..KDDTTTDDK.....',
        '..KTT....TTK....',
        '...KTT..TTK.....',
        '....KKKKKK......',
        '................',
      ],
      none: [
        '................',
        '................',
        '................',
        '................',
        '................',
        '................',
        '................',
        '................',
        '................',
        '................',
        '................',
        '................',
        '................',
        '................',
        '................',
        '................',
      ],
    };

    const cache = new Map();
    function bake(key){
      if (cache.has(key)) return cache.get(key);
      const spr = SPRITES[key] || SPRITES.none;
      const c = document.createElement('canvas');
      c.width = 16; c.height = 16;
      const ctx = c.getContext('2d');
      ctx.imageSmoothingEnabled = false;
      ctx.clearRect(0,0,16,16);
      for (let y=0;y<16;y++){
        const row = spr[y] || '';
        for (let x=0;x<16;x++){
          const ch = row[x] || '.';
          const col = PAL[ch];
          if (!col) continue;
          ctx.fillStyle = col;
          ctx.fillRect(x, y, 1, 1);
        }
      }
      cache.set(key, c);
      return c;
    }

    
    function rarityColorFromCanvas(canvas){
      try{
        const cl = canvas && canvas.classList;
        if (!cl) return '#e6edf3';
        if (cl.contains('rar-unique')) return '#fb7185';
        if (cl.contains('rar-legendary')) return '#fbbf24';
        if (cl.contains('rar-epic')) return '#c4b5fd';
        if (cl.contains('rar-rare')) return '#93c5fd';
        if (cl.contains('rar-uncommon')) return '#86efac';
        if (cl.contains('rar-common')) return '#cbd5e1';
      }catch(_){}
      return '#e6edf3';
    }

    function drawGlyphIcon(ctx, w, h, glyph, canvas){
      if (!glyph) return;
      ctx.save();
      ctx.clearRect(0,0,w,h);

      // subtle plate
      ctx.imageSmoothingEnabled = true;
      ctx.fillStyle = 'rgba(9,14,22,0.45)';
      ctx.fillRect(0,0,w,h);
      ctx.lineWidth = Math.max(1, Math.round(Math.min(w,h)*0.08));
      ctx.strokeStyle = 'rgba(226,237,243,0.10)';
      ctx.strokeRect(0.5,0.5,w-1,h-1);

      // glyph (centered by metrics; colored by rarity)
      const fg = rarityColorFromCanvas(canvas);
      const fs = Math.round(Math.min(w,h)*0.78);
      ctx.font = `900 ${fs}px "Noto Serif JP","Hiragino Mincho ProN","Yu Mincho",serif`;
      ctx.lineWidth = Math.max(2, Math.round(fs*0.10));
      ctx.strokeStyle = 'rgba(0,0,0,0.60)';
      ctx.fillStyle = fg;

      // metric-centering
      let x = Math.round(w/2), y = Math.round(h/2);
      try{
        const m = ctx.measureText(glyph);
        if (m && m.actualBoundingBoxLeft != null && m.actualBoundingBoxRight != null && m.actualBoundingBoxAscent != null && m.actualBoundingBoxDescent != null){
          const bw = m.actualBoundingBoxLeft + m.actualBoundingBoxRight;
          const bh = m.actualBoundingBoxAscent + m.actualBoundingBoxDescent;
          x = Math.round((w - bw)/2 + m.actualBoundingBoxLeft);
          y = Math.round((h - bh)/2 + m.actualBoundingBoxAscent);
          ctx.textAlign = 'left';
          ctx.textBaseline = 'alphabetic';
        } else {
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
        }
      } catch(_){
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
      }

      // small glow only for high rarities (kept tight to avoid blur)
      if (canvas && canvas.classList){
        if (canvas.classList.contains('rar-legendary') || canvas.classList.contains('rar-unique')){
          ctx.shadowColor = fg;
          ctx.shadowBlur = Math.round(fs*0.10);
        }
      }

      ctx.strokeText(glyph, x, y);
      ctx.fillText(glyph, x, y);

      ctx.restore();
    }

function draw(canvas, key){
      if (!canvas) return;
      const ctx = canvas.getContext('2d');
      if (!ctx) return;
      ctx.imageSmoothingEnabled = true;
      const w = canvas.width|0, h = canvas.height|0;
      ctx.clearRect(0,0,w,h);

      const glyph = canvas.getAttribute('data-glyph');
      if (glyph){
        drawGlyphIcon(ctx, w, h, glyph, canvas);
        return;
      }

      const im = (typeof SPRIMG_IMG !== 'undefined') ? SPRIMG_IMG[key] : null;
      if (im){
        if (im.complete && im.naturalWidth){
          ctx.drawImage(im, 0, 0, w, h);
        } else {
          im.addEventListener('load', () => {
            try { draw(canvas, key); } catch(_){}
          }, { once: true });
        }
        return;
      }

      // Fallback: avoid pixelated dot-sprites on modern displays.
      // If we don't have an image sprite and no explicit glyph, render a clean monogram.
      try{
        let g = '';
        if (key === 'unique') g = '★';
        else if (key === 'none') g = '';
        else if (String(key||'').startsWith('w_')) g = '武';
        else if (String(key||'').startsWith('a_')) g = '防';
        else if (String(key||'').startsWith('acc_')) g = '飾';
        else if (String(key||'').startsWith('i_')) g = '印';
        else g = (key ? String(key)[0] : '・');
        if (g){
          drawGlyphIcon(ctx, w, h, g, canvas);
          return;
        }
      }catch(_){ }

      // Last resort (debug): legacy dot sprite
      ctx.imageSmoothingEnabled = false;
      const src = bake(key);
      ctx.drawImage(src, 0, 0, w, h);
    }

    const WEAPON_BASES = ['加持錫杖','陀羅尼経巻','破魔弩','金剛連珠砲','短金剛剣','大金剛剣','蓮華剣','金剛薙刀','金剛珠鎚','金剛剣','破煩悩斧','金剛槍','断業鎌','蓮弓','錫杖','金剛槌','金剛棍','不動刀'];
    const ARMOR_BASES = ['金剛鎖衣','龍鱗法衣','金剛板衣','結界外套','隠密衣','皮法衣','鎖子衣','板衣','鱗衣','袈裟','法衣','外套'];
    const ACC_BASES = ['時輪','祈祷珠','念珠護腕輪','耳輪','護符','佩符','霊符','印契章','如意宝珠','護護腕輪','念符','戒環'];

    function baseFromName(name, slot){
      name = String(name||'');
      const list = slot==='weapon' ? WEAPON_BASES : slot==='armor' ? ARMOR_BASES : ACC_BASES;
      for (const b of list){
        if (name.endsWith(b)) return b;
      }
      return '';
    }

    function itemGlyph(it){
      if (!it) return '・';
      const slot = it.slot || '';
      const name = String(it.name || '');
      const base = baseFromName(name, slot);
      // Prefer a type-like kanji from the base name (e.g., 剣/槍/杖/衣/珠/符/輪...)
      if (base){
        for (let i = base.length - 1; i >= 0; i--){
          const ch = base[i];
          if (/[一-龯々]/.test(ch)) return ch;
        }
      }
      // Otherwise pick the first kanji-ish character in the full name
      for (const ch of name){
        if (/[一-龯々]/.test(ch)) return ch;
      }
      // Fallback by slot
      if (slot === 'weapon') return '刃';
      if (slot === 'armor') return '衣';
      if (slot === 'accessory') return '珠';
      return name ? name[0] : '・';
    }

    function itemKey(it){
      if (!it) return 'none';
      if (it.rarity === 'unique') return 'unique';
      if (it.slot === 'weapon'){
        const b = baseFromName(it.name, 'weapon');
        const map = { '金剛剣':'w_sword','大金剛剣':'w_greatsword','蓮華剣':'w_rapier','破煩悩斧':'w_axe','金剛槍':'w_spear','金剛薙刀':'w_glaive','断業鎌':'w_scythe','金剛珠鎚':'w_flail','短金剛剣':'w_dagger','蓮弓':'w_bow','破魔弩':'w_crossbow','錫杖':'w_staff','加持錫杖':'w_wand','陀羅尼経巻':'w_grimoire','金剛槌':'w_hammer','金剛棍':'w_mace','金剛連珠砲':'w_gun','不動刀':'w_katana' };
        return (map[b] || 'w_sword');
      }
      if (it.slot === 'armor') return 'a_armor';
      if (it.slot === 'accessory'){
        const b = baseFromName(it.name, 'accessory');
        const map = { '戒環':'acc_ring','護符':'acc_amulet','念符':'acc_charm','霊符':'acc_talisman','念珠護腕輪':'acc_bracelet','佩符':'acc_pendant','耳輪':'acc_earring','護護腕輪':'acc_bracelet','印契章':'acc_sigil','如意宝珠':'acc_gem','祈祷珠':'acc_beads','時輪':'acc_watch' };
        return (map[b] || 'acc_ring');
      }
      return 'none';
    }

    

const ENEMY_SPRITE_MAP = {
    "不浄貪":"i_chain",
    "五蘊":"i_skull",
    "分別":"enemy_generic",
    "剛強我慢":"enemy_generic",
    "因果の法":"i_scales",
    "因果顛倒":"i_scales",
    "執取":"i_chain",
    "増上慢":"i_crown",
    "天人五衰":"i_skull",
    "妄想":"i_cloud",
    "嫉":"enemy_generic",
    "害":"i_flame",
    "常顛倒":"i_cloud",
    "幻化":"i_cloud",
    "忿":"i_flame",
    "怨恨":"i_flame",
    "愚痴":"i_eye",
    "慢":"i_crown",
    "憍":"i_crown",
    "我執":"enemy_generic",
    "我語取":"i_chain",
    "我顛倒":"i_cloud",
    "戒禁取":"i_chain",
    "掉挙":"enemy_generic",
    "放逸":"enemy_generic",
    "散乱":"i_cloud",
    "有愛":"i_chain",
    "有身見":"i_eye",
    "有頂":"i_crown",
    "有頂慢":"i_crown",
    "染愛":"i_chain",
    "根本無明":"i_eye",
    "業果":"i_scales",
    "業果・異熟":"i_scales",
    "業火":"i_flame",
    "業障":"i_scales",
    "楽顛倒":"i_cloud",
    "欲取":"i_chain",
    "欲愛":"i_chain",
    "欲貪蓋":"i_chain",
    "死畏":"i_skull",
    "浄顛倒":"i_cloud",
    "渇愛":"i_chain",
    "無常":"i_skull",
    "無明":"i_eye",
    "無明縁識":"i_cloud",
    "無色界愛":"i_chain",
    "煩悩":"i_flame",
    "煩熱":"i_flame",
    "疑":"i_question",
    "痴":"i_eye",
    "瞋恚":"i_flame",
    "瞋恚随眠":"enemy_generic",
    "瞋火":"i_flame",
    "色界愛":"i_chain",
    "苦苦":"i_skull",
    "見取":"i_chain",
    "貪欲":"i_chain",
    "貪痴":"i_chain",
    "輪廻":"i_wheel",
    "邪見":"i_cloud",
    "闘諍":"i_flame",
    "闘諍随眠":"i_flame",
    "随眠":"i_eye",
    "顛倒":"i_cloud"
  };

function enemyKey(enemy){
      if (!enemy) return 'none';
      const n = String(enemy.name||'');
      const mapped = (typeof ENEMY_SPRITE_MAP !== 'undefined') ? ENEMY_SPRITE_MAP[n] : null;
      if (mapped) return mapped;
      if (enemy.isBoss) return 'boss';
      return 'enemy_generic';
    }

    function has(k){ return !!SPRITES[k]; }

    return { draw, itemKey, enemyKey, has, itemGlyph };
  })();

  function renderSpriteCanvases(root){
    try{
      if (!root) return;
      root.querySelectorAll('canvas[data-spr]').forEach(c => {
        const key = c.getAttribute('data-spr') || 'none';
        SPR.draw(c, key);
      });
    } catch(_){ }
  }
  // --------------------
  // Enemy "kanji icon" (single-character) rendering
  // --------------------
  function enemyKanji1(name){
    const s = String(name||'');
    for (const ch of s){
      if (/[一-龯々]/.test(ch)) return ch;
    }
    return s ? s[0] : '魔';
  }

  function roundRectPath(ctx, x, y, w, h, r){
    r = Math.max(0, Math.min(r, Math.min(w,h)/2));
    ctx.beginPath();
    ctx.moveTo(x+r, y);
    ctx.arcTo(x+w, y, x+w, y+h, r);
    ctx.arcTo(x+w, y+h, x, y+h, r);
    ctx.arcTo(x, y+h, x, y, r);
    ctx.arcTo(x, y, x+w, y, r);
    ctx.closePath();
  }

  function drawEnemyKanji(canvas, enemy){
    if (!canvas) return;
    const ctx = canvas.getContext('2d');
    if (!ctx) return;
    const w = canvas.width|0, h = canvas.height|0;
    ctx.clearRect(0,0,w,h);

    // subtle plate
    ctx.save();
    ctx.imageSmoothingEnabled = true;
    const pad = Math.round(Math.min(w,h) * 0.06);
    const rr = Math.round(Math.min(w,h) * 0.22);
    roundRectPath(ctx, pad, pad, w-pad*2, h-pad*2, rr);
    ctx.fillStyle = 'rgba(9,14,22,0.45)';
    ctx.fill();
    ctx.lineWidth = Math.max(1, Math.round(Math.min(w,h)*0.06));
    ctx.strokeStyle = 'rgba(226,237,243,0.08)';
    ctx.stroke();

    // glyph
    const g = enemyKanji1(enemy && enemy.name);
    let fg = '#e6edf3';
    if (enemy && enemy.isBoss) fg = '#fb7185';
    else if (enemy && enemy.isElite) fg = '#fbbf24';

    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    const fs = Math.round(Math.min(w,h)*0.76);
    ctx.font = `900 ${fs}px "Noto Serif JP","Hiragino Mincho ProN","Yu Mincho",serif`;
    ctx.lineWidth = Math.max(2, Math.round(fs*0.10));
    ctx.strokeStyle = 'rgba(0,0,0,0.55)';
    ctx.strokeText(g, w/2, h/2 + 1);
    ctx.fillStyle = fg;
    ctx.fillText(g, w/2, h/2 + 1);
    ctx.restore();
  }

  function drawHeroKanji(canvas, hero, mode){
    if (!canvas) return;
    const ctx = canvas.getContext('2d');
    if (!ctx) return;
    const w = canvas.width|0, h = canvas.height|0;
    ctx.clearRect(0,0,w,h);

    // subtle plate (same as enemy/icons)
    ctx.save();
    ctx.imageSmoothingEnabled = true;
    const pad = Math.round(Math.min(w,h) * 0.06);
    const rr = Math.round(Math.min(w,h) * 0.22);
    roundRectPath(ctx, pad, pad, w-pad*2, h-pad*2, rr);
    ctx.fillStyle = 'rgba(9,14,22,0.45)';
    ctx.fill();
    ctx.lineWidth = Math.max(1, Math.round(Math.min(w,h)*0.06));
    ctx.strokeStyle = 'rgba(226,237,243,0.08)';
    ctx.stroke();

    // glyph
    const g = (hero && hero.dead) ? '亡' : (mode==='atk' ? '撃' : '行');
    let fg = (hero && hero.dead) ? '#fb7185' : (mode==='atk' ? '#fbbf24' : '#e6edf3');
    try{
      const md = document.documentElement.getAttribute('data-mandala');
      if (!(hero && hero.dead)){
        if (md === 'kongo') fg = '#93c5fd';
        else if (md === 'taizo') fg = '#86efac';
      }
    }catch(_){}

    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    const fs = Math.round(Math.min(w,h)*0.76);
    ctx.font = `900 ${fs}px "Noto Serif JP","Hiragino Mincho ProN","Yu Mincho",serif`;
    ctx.lineWidth = Math.max(2, Math.round(fs*0.10));
    ctx.strokeStyle = 'rgba(0,0,0,0.55)';
    ctx.strokeText(g, w/2, h/2 + 1);
    ctx.fillStyle = fg;
    ctx.fillText(g, w/2, h/2 + 1);
    ctx.restore();
  }





  function updateHUDSprites(){
    try{
      // hero
      if (els.heroSprite){
        drawHeroKanji(els.heroSprite, S.hero);
      }
      if (els.heroStageSprite){
        drawHeroKanji(els.heroStageSprite, S.hero);
      }
      // enemy
      if (els.enemySprite){
        drawEnemyKanji(els.enemySprite, S.run && S.run.enemy);
      }
      if (els.enemyStageSprite){
        drawEnemyKanji(els.enemyStageSprite, S.run && S.run.enemy);
      }
      // gear
      if (els.eqWeaponIcon){
        const it = S.gear && S.gear.weapon;
        els.eqWeaponIcon.classList.toggle('rar-common', !!it && it.rarity==='common');
        els.eqWeaponIcon.classList.toggle('rar-uncommon', !!it && it.rarity==='uncommon');
        els.eqWeaponIcon.classList.toggle('rar-rare', !!it && it.rarity==='rare');
        els.eqWeaponIcon.classList.toggle('rar-epic', !!it && it.rarity==='epic');
        els.eqWeaponIcon.classList.toggle('rar-legendary', !!it && it.rarity==='legendary');
        els.eqWeaponIcon.classList.toggle('rar-unique', !!it && it.rarity==='unique');
        if (it) els.eqWeaponIcon.setAttribute('data-glyph', SPR.itemGlyph(it)); else els.eqWeaponIcon.removeAttribute('data-glyph');
        SPR.draw(els.eqWeaponIcon, it ? SPR.itemKey(it) : 'none');
      }
      if (els.eqArmorIcon){
        const it = S.gear && S.gear.armor;
        els.eqArmorIcon.classList.toggle('rar-common', !!it && it.rarity==='common');
        els.eqArmorIcon.classList.toggle('rar-uncommon', !!it && it.rarity==='uncommon');
        els.eqArmorIcon.classList.toggle('rar-rare', !!it && it.rarity==='rare');
        els.eqArmorIcon.classList.toggle('rar-epic', !!it && it.rarity==='epic');
        els.eqArmorIcon.classList.toggle('rar-legendary', !!it && it.rarity==='legendary');
        els.eqArmorIcon.classList.toggle('rar-unique', !!it && it.rarity==='unique');
        if (it) els.eqArmorIcon.setAttribute('data-glyph', SPR.itemGlyph(it)); else els.eqArmorIcon.removeAttribute('data-glyph');
        SPR.draw(els.eqArmorIcon, it ? SPR.itemKey(it) : 'none');
      }
      if (els.eqAccIcon){
        const it = S.gear && S.gear.accessory;
        els.eqAccIcon.classList.toggle('rar-common', !!it && it.rarity==='common');
        els.eqAccIcon.classList.toggle('rar-uncommon', !!it && it.rarity==='uncommon');
        els.eqAccIcon.classList.toggle('rar-rare', !!it && it.rarity==='rare');
        els.eqAccIcon.classList.toggle('rar-epic', !!it && it.rarity==='epic');
        els.eqAccIcon.classList.toggle('rar-legendary', !!it && it.rarity==='legendary');
        els.eqAccIcon.classList.toggle('rar-unique', !!it && it.rarity==='unique');
        if (it) els.eqAccIcon.setAttribute('data-glyph', SPR.itemGlyph(it)); else els.eqAccIcon.removeAttribute('data-glyph');
        SPR.draw(els.eqAccIcon, it ? SPR.itemKey(it) : 'none');
      }
    } catch(_){ }
  }


  function updateHUDSpritesLite(){
    try{
      // Kanji icons only (cheap): keeps MAX speed UI from looking frozen.
      if (els.heroSprite) drawHeroKanji(els.heroSprite, S.hero);
      if (els.enemySprite) drawEnemyKanji(els.enemySprite, S.run && S.run.enemy);
      if (els.heroStageSprite) drawHeroKanji(els.heroStageSprite, S.hero);
      if (els.enemyStageSprite) drawEnemyKanji(els.enemyStageSprite, S.run && S.run.enemy);
    } catch(_){ }
  }


  // --------------------
  // Battle stage animation (CSS + optional sprite swap)
  // --------------------
  // --------------------
  // Battle FX (v30: full-canvas particles + camera punch)
  // --------------------
  const BFX = (() => {
    const st = { running:false, lastT:0, acc:0, dpr:1, vw:1, vh:1, maxP:140, fps:40, stageSize:64 };
    const fx = { particles:[], rings:[], slashes:[], haze:0, hazeHue:190 };
    const cam = { x:0, y:0, z:1, vx:0, vy:0, vz:0 };
    let enabled = true;

    function ok(){ return !!(els.battleFxFull && els.battleStage); }
    function rect(){ return els.battleStage.getBoundingClientRect(); }

    function resetAll(clearCanvas=true){
      fx.particles.length = 0; fx.rings.length = 0; fx.slashes.length = 0;
      fx.haze = 0;
      cam.x = cam.y = 0; cam.z = 1; cam.vx = cam.vy = 0; cam.vz = 0;
      if (els.battleStage){
        els.battleStage.style.setProperty('--camX','0px');
        els.battleStage.style.setProperty('--camY','0px');
        els.battleStage.style.setProperty('--camZ','1');
        try{ els.battleStage.classList.remove('hitstop'); }catch(_){ }
      }
      if (clearCanvas && els.battleFxFull){
        try{
          resize();
          const ctx = els.battleFxFull.getContext('2d');
          if (ctx){
            ctx.setTransform(st.dpr,0,0,st.dpr,0,0);
            ctx.clearRect(0,0,st.vw,st.vh);
          }
        }catch(_){ }
      }
    }

    function setEnabled(v){
      enabled = !!v;
      if (!enabled){
        st.running = false;
        resetAll(true);
      }
    }

    function resize(force=false){
      if (!ok()) return;
      const r = rect();
      if (!(r.width>0 && r.height>0)) return;
      st.dpr = Math.min(1.5, window.devicePixelRatio || 1);
      const cw = Math.max(1, Math.round(r.width * st.dpr));
      const ch = Math.max(1, Math.round(r.height * st.dpr));
      const c = els.battleFxFull;
      if (force || c.width !== cw || c.height !== ch){
        c.width = cw; c.height = ch;
      }
      st.vw = r.width; st.vh = r.height;
      // stage sprite display size (hero height) for scaling slash thickness
      try{
        const v = getComputedStyle(document.documentElement).getPropertyValue("--stageSize");
        const n = parseFloat(v);
        st.stageSize = (Number.isFinite(n) && n>0) ? n : 64;
      } catch(_){ st.stageSize = 64; }
      // dash distance for CSS keyframes
      const dash = clamp(r.width * 0.22, 90, 220);
      els.battleStage.style.setProperty('--dash', `${Math.round(dash)}px`);
    }

    function posFromEl(el, yBias=0.58, xBias=0.55){
      const sr = rect();
      if (!(sr.width>0 && sr.height>0)) return { x: sr.width*0.5, y: sr.height*0.6 };
      if (!el) return { x: sr.width*0.5, y: sr.height*0.6 };
      const r = el.getBoundingClientRect();
      const x = (r.left + r.width * xBias) - sr.left;
      const y = (r.top  + r.height * yBias) - sr.top;
      return { x, y };
    }

    function flash(hue=190){
      if (!enabled) return;
      if (!els.battleFlash) return;
      els.battleFlash.style.setProperty('--flashHue', String(hue));
      els.battleFlash.classList.remove('on');
      void els.battleFlash.offsetWidth;
      els.battleFlash.classList.add('on');
    }

    function hitStop(ms=60){
      if (!enabled) return;
      if (!els.battleStage) return;
      els.battleStage.classList.add('hitstop');
      window.setTimeout(() => {
        try { els.battleStage && els.battleStage.classList.remove('hitstop'); } catch(_){ }
      }, ms);
    }

    function punch(power=1, dir=1){
      if (!enabled) return;
      if (!ok()) return;
      resize();
      // Clamp impulses so ultra-high game speed (e.g., 16x) doesn't shove the stage out of view
      const maxVx = Math.max(26, st.vw * 0.09);
      const maxVy = Math.max(18, st.vh * 0.16);
      const maxVz = 0.10;
      cam.vx = clamp(cam.vx + dir * 22 * power, -maxVx, maxVx);
      cam.vy = clamp(cam.vy + (-12 * power), -maxVy, maxVy);
      cam.vz = clamp(cam.vz + 0.045 * power, -maxVz, maxVz);
      fx.haze = Math.min(1, fx.haze + 0.20 * power);
      start();
    }

    function impact(x, y, power=1, hue=190){
      if (!enabled) return;
      if (!ok()) return;
      resize();
      fx.hazeHue = hue;
      // ring
      fx.rings.push({ x, y, r: 8, dr: 520 * power, w: 10 + 10*power, a: 0.9, t:0, life: 0.22 + 0.12*power, hue });
      // particles
      const n = Math.floor(12 + 16 * power);
      for (let i=0;i<n;i++){
        const ang = rand(0, Math.PI*2);
        const spd = rand(140, 420) * power;
        fx.particles.push({ x, y, vx: Math.cos(ang)*spd, vy: Math.sin(ang)*spd - rand(30,140)*power, s: rand(2, 4)*power, t:0, life: rand(0.18, 0.38), hue, a: rand(0.55, 0.95) });
      }
      if (fx.particles.length > st.maxP) fx.particles.splice(0, fx.particles.length - st.maxP);
      fx.haze = Math.min(1, fx.haze + 0.30 * power);
      start();
    }

    function slash(x1, y1, x2, y2, power=1, hue=190, lv=1){
      if (!enabled) return;
      if (!ok()) return;
      resize();
      fx.hazeHue = hue;
      const p = clamp(power, 0.60, 2.35);
      const LMAX = (typeof LV_VIS_MAX !== "undefined") ? LV_VIS_MAX : 99999;
      const lvN = clamp(Math.floor((lv ?? 1) || 1), 1, LMAX);
      // 斬撃の線幅は "位" で決める: 位1=糸 / 位MAX=行者の身長（--stageSize）
      const t位 = (lvN <= 1) ? 0 : (Math.log10(lvN) / Math.log10(LMAX));
      const maxW = (Number.isFinite(st.stageSize) && st.stageSize>0) ? st.stageSize : 64;
      const wMin = 0.45;
      const w0 = wMin + (maxW - wMin) * Math.pow(clamp(t位, 0, 1), 3.2);
      const curve = rand(-1,1) * (50 + 60*p);
      fx.slashes.push({ x1, y1, x2, y2, curve, t:0, life: 0.18 + 0.08*p, hue, w0 });
      // lightweight after-image: only sometimes (mostly on crit / high power)
      if (p > 1.15 && rand(0,1) < 0.55){
        const w1 = Math.max(0.35, w0 * rand(0.42, 0.62));
        fx.slashes.push({ x1: x1 + rand(-8,8), y1: y1 + rand(-8,8), x2: x2 + rand(-8,8), y2: y2 + rand(-8,8), curve: curve*0.75, t:0, life: 0.14 + 0.06*p, hue: hue+rand(-8,8), w0: w1 });
      }
      fx.haze = Math.min(1, fx.haze + 0.20 * power);
      start();
    }

    function start(){
      if (!enabled) return;
      if (st.running) return;
      st.running = true;
      st.lastT = performance.now();
      st.acc = 0;
      requestAnimationFrame(tick);
    }

    function tick(t){
      if (!enabled){ st.running = false; resetAll(true); return; }
      if (!ok()) { st.running = false; return; }
      const raw = (t - st.lastT) / 1000;
      st.lastT = t;
      st.acc += raw;
      const step = 1 / st.fps;
      if (st.acc < step){
        requestAnimationFrame(tick);
        return;
      }
      const dt = Math.min(0.05, st.acc);
      st.acc = 0;
      resize();

      // camera spring
      cam.x += cam.vx; cam.y += cam.vy;
      cam.z += cam.vz;
      cam.vx *= 0.72; cam.vy *= 0.72; cam.vz *= 0.68;
      cam.x *= 0.72; cam.y *= 0.72;
      cam.z = 1 + (cam.z - 1) * 0.72;

      // Clamp camera offset to viewport so it never drifts off-screen
      const maxX = Math.max(22, st.vw * 0.06);
      const maxY = Math.max(14, st.vh * 0.18);
      cam.x = clamp(cam.x, -maxX, maxX);
      cam.y = clamp(cam.y, -maxY, maxY);

      // apply camera vars
      els.battleStage.style.setProperty('--camX', `${cam.x.toFixed(1)}px`);
      els.battleStage.style.setProperty('--camY', `${cam.y.toFixed(1)}px`);
      els.battleStage.style.setProperty('--camZ', `${cam.z.toFixed(3)}`);

      // step FX
      for (const p of fx.particles){
        p.t += dt;
        p.vy += 900 * dt; // gravity
        p.x += p.vx * dt;
        p.y += p.vy * dt;
        p.vx *= Math.pow(0.18, dt);
        p.vy *= Math.pow(0.40, dt);
      }
      for (const r of fx.rings){
        r.t += dt;
        r.r += r.dr * dt;
        r.a = Math.max(0, 1 - (r.t / r.life));
      }
      for (const s of fx.slashes){ s.t += dt; }
      fx.haze = Math.max(0, fx.haze - 1.8 * dt);

      // prune
      fx.particles = fx.particles.filter(p => p.t < p.life);
      fx.rings = fx.rings.filter(r => r.t < r.life);
      fx.slashes = fx.slashes.filter(s => s.t < s.life);

      // draw
      const c = els.battleFxFull;
      const ctx = c.getContext('2d');
      if (ctx){
        ctx.setTransform(st.dpr,0,0,st.dpr,0,0);
        ctx.clearRect(0,0,st.vw,st.vh);

        // subtle haze flash (lightweight)
        if (fx.haze > 0.001){
          ctx.globalCompositeOperation = 'screen';
          ctx.fillStyle = `hsla(${fx.hazeHue}, 100%, 70%, ${0.10*fx.haze})`;
          ctx.fillRect(0,0,st.vw,st.vh);
        }

        ctx.globalCompositeOperation = 'lighter';

        // rings
        for (const r of fx.rings){
          const t0 = r.t / r.life;
          const lw = r.w * (1 - t0);
          ctx.save();
          ctx.lineCap = 'round';
          ctx.lineWidth = lw;
          ctx.strokeStyle = `hsla(${r.hue}, 100%, 70%, ${0.55*r.a})`;
          ctx.beginPath();
          ctx.arc(r.x, r.y, r.r, 0, Math.PI*2);
          ctx.stroke();
          ctx.restore();
        }

        // slashes
        for (const s of fx.slashes){
          const tt = clamp(s.t / s.life, 0, 1);
          const a = 1 - tt;
          const w = s.w0 * (1 - tt*0.55);
          const mx = (s.x1 + s.x2) / 2 + s.curve;
          const my = (s.y1 + s.y2) / 2 - s.curve;
          ctx.save();
          ctx.lineCap = 'round';
          ctx.lineJoin = 'round';
          ctx.lineWidth = w;
          ctx.strokeStyle = `hsla(${s.hue}, 100%, 72%, ${0.85*a})`;
          ctx.beginPath();
          ctx.moveTo(s.x1, s.y1);
          ctx.quadraticCurveTo(mx, my, s.x2, s.y2);
          ctx.stroke();
          ctx.restore();
        }

        // particles
        for (const p of fx.particles){
          const a = (1 - p.t/p.life) * p.a;
          ctx.fillStyle = `hsla(${p.hue}, 100%, 70%, ${a})`;
          ctx.fillRect(p.x - p.s*0.5, p.y - p.s*0.5, p.s, p.s);
        }
      }

      // stop condition
      const camEnergy = Math.abs(cam.vx)+Math.abs(cam.vy)+Math.abs(cam.vz) + Math.abs(cam.x)+Math.abs(cam.y) + Math.abs(cam.z-1);
      const alive = fx.particles.length + fx.rings.length + fx.slashes.length;
      if (alive === 0 && camEnergy < 0.35 && fx.haze < 0.01){
          // reset
        els.battleStage.style.setProperty('--camX','0px');
        els.battleStage.style.setProperty('--camY','0px');
        els.battleStage.style.setProperty('--camZ','1');
        st.running = false;
        return;
      }

      requestAnimationFrame(tick);
    }

    // python-like boolean fix (we'll rewrite above in python to JS)
    return { resize, posFromEl, flash, hitStop, punch, impact, slash, setEnabled };
  })();

  const BATTLE = (() => {
    const st = { lastText: 0, lastFx: 0 };

    function fxEnabled(){ return !((S.ui && Number(S.ui.fx) === 0)); }

    function toggleSound(){
      ensureMikkyoFields();
      S.ui.sound = (Number(S.ui.sound)===1) ? 0 : 1;
      if (S.ui.sound){ try{ SOUND.start(); }catch(_){ } } else { try{ SOUND.stop(); }catch(_){ } }
      try{ updateRealmFx(); }catch(_){ }
      save();
      dirtyHUD = true;
    }

    function fxPowFromDmg(dmg, isCrit=false){
      const d = Math.max(0, Number(dmg) || 0);
      // 伸びは逓減（高調伏力でも描画負荷が爆発しないように log 尺度）
      let pow = 0.78 + 0.22 * Math.log10(d + 10);
      if (isCrit) pow *= 1.18;
      // 高速時は少し抑える（16x でも破綻しにくい）
      const spd = Number(S.run && S.run.speed) || 4;
      if (spd >= 12) pow *= 0.85;
      else if (spd >= 8) pow *= 0.92;
      return clamp(pow, 0.70, 2.15);
    }

    function pulse(el, cls, ms){
      if (!el) return;
      if (!fxEnabled()) return;
      el.classList.remove(cls);
      // restart animation
      void el.offsetWidth;
      el.classList.add(cls);
      window.setTimeout(() => el.classList.remove(cls), ms);
    }

    function floatDmg(side, text, kind){
      const layer = els.battleFx;
      if (!layer) return;
      if (!fxEnabled()) return;
      const t = Date.now();
      if (t - st.lastText < 60) return; // throttle
      st.lastText = t;

      const d = document.createElement('div');
      d.className = 'floatDmg' + (kind ? (' ' + kind) : '');
      d.textContent = text;
      if (!fxEnabled()){
        d.style.animation = "none";
        d.style.opacity = "1";
      }

      // place near actor (falls back to old fixed positions)
      try{
        const sr = els.battleStage ? els.battleStage.getBoundingClientRect() : null;
        const el = (side === 'hero') ? els.heroActor : els.enemyActor;
        const r = (sr && el) ? el.getBoundingClientRect() : null;
        if (sr && r && sr.width>0 && sr.height>0){
          const x0 = (r.left + r.width*0.55 - sr.left) / sr.width;
          const y0 = (r.top  + r.height*0.32 - sr.top)  / sr.height;
          d.style.left = (clamp(x0, 0.05, 0.95) * 100).toFixed(1) + '%';
          d.style.top  = (clamp(y0, 0.10, 0.92) * 100).toFixed(1) + '%';
        } else {
          d.style.left = (side === 'hero') ? '28%' : '72%';
          d.style.top  = (side === 'hero') ? '62%' : '52%';
        }
      } catch(_){
        d.style.left = (side === 'hero') ? '28%' : '72%';
        d.style.top  = (side === 'hero') ? '62%' : '52%';
      }

      layer.appendChild(d);
      window.setTimeout(() => d.remove(), 720);
    }
    function fxSprite(side, key, cls, ms, x, y, scale){
      const layer = els.battleFx;
      if (!layer) return;
      const t = Date.now();
      if (t - st.lastFx < 28) return;
      st.lastFx = t;
      const c = document.createElement('canvas');
      c.width = 16; c.height = 16;
      c.className = 'fxSprite ' + cls;

      // default position: near actor
      try{
        const sr = els.battleStage ? els.battleStage.getBoundingClientRect() : null;
        const el = (side === 'hero') ? els.heroActor : els.enemyActor;
        const r = (sr && el) ? el.getBoundingClientRect() : null;
        if (sr && r && sr.width>0 && sr.height>0){
          const x0 = (r.left + r.width*0.55 - sr.left) / sr.width;
          const y0 = (r.top  + r.height*0.55 - sr.top)  / sr.height;
          c.style.left = ((clamp(x0, 0.05, 0.95) * 100).toFixed(1) + '%');
          c.style.top  = ((clamp(y0, 0.05, 0.95) * 100).toFixed(1) + '%');
        } else {
          c.style.left = (side === 'hero') ? '30%' : '70%';
          c.style.top  = (side === 'hero') ? '56%' : '46%';
        }
      } catch(_){
        c.style.left = (side === 'hero') ? '30%' : '70%';
        c.style.top  = (side === 'hero') ? '56%' : '46%';
      }

      if (x != null) c.style.left = String(x);
      if (y != null) c.style.top  = String(y);

        if (scale != null){
        const base = 84;
        const sc = clamp(Number(scale) || 1, 0.65, 1.75);
        c.style.width = Math.round(base*sc) + 'px';
        c.style.height = Math.round(base*sc) + 'px';
      }

      SPR.draw(c, key);
      layer.appendChild(c);
      window.setTimeout(() => c.remove(), ms ?? 300);
    }


    function drawBase(){
      if (els.heroStageSprite) drawHeroKanji(els.heroStageSprite, S.hero);
      if (els.enemyStageSprite) drawEnemyKanji(els.enemyStageSprite, S.run && S.run.enemy);
    }

    function heroAttack(isCrit, dmg){
      const pow = fxPowFromDmg(dmg, !!isCrit);
      const fxOn = fxEnabled();
      const lite = isSpeedMax();
      if (fxOn) pulse(els.heroActor, 'atk', 240);
      if (lite){
        // MAX speed: keep only the minimal stage icon feedback.
        if (els.heroStageSprite){
          drawHeroKanji(els.heroStageSprite, S.hero, 'atk');
          window.setTimeout(drawBase, 240);
        }
        return;
      }
      // Big FX
      if (fxOn){
        try{
          const pH = BFX.posFromEl(els.heroActor, 0.62, 0.70);
          const pE = BFX.posFromEl(els.enemyActor, 0.58, 0.35);
          const hue = isCrit ? 45 : 190;
          BFX.hitStop(clamp(45 + 18*pow, 40, 110));
          BFX.punch(clamp(0.82*pow, 0.55, 1.95), +1);
          BFX.flash(hue);
          BFX.slash(pH.x + 18, pH.y - 18, pE.x - 22, pE.y - 26, clamp(0.95*pow, 0.70, 2.25), hue, (S.hero && S.hero.lv) ? S.hero.lv : 1);
          BFX.impact(pE.x - 4, pE.y - 10, clamp(0.98*pow, 0.70, 2.25), hue);
        } catch(_){ }
      }

      // Sprite FX (front layer)
      if (fxOn){
        const sc = 1 + (pow-1)*0.70;
        fxSprite('enemy', 'fx_slash', 'fxSlash', 300, null, null, sc);
        window.setTimeout(() => fxSprite('enemy', 'fx_spark', 'fxSpark', 240, null, null, sc*0.95), 60);
      }

      if (els.heroStageSprite){
        drawHeroKanji(els.heroStageSprite, S.hero, 'atk');
        window.setTimeout(drawBase, 240);
      }
      if (isCrit) floatDmg('enemy', '破魔!!', 'crit');
    }

    function enemyAttack(dmg){
      const pow = fxPowFromDmg(dmg, false);
      const fxOn = fxEnabled();
      const lite = isSpeedMax();
      if (fxOn) pulse(els.enemyActor, 'atk', 240);
      if (lite){
        // MAX speed: skip heavy FX.
        return;
      }
      if (fxOn){
        try{
          const pE = BFX.posFromEl(els.enemyActor, 0.60, 0.30);
          const pH = BFX.posFromEl(els.heroActor, 0.60, 0.70);
          const hue = 10;
          BFX.hitStop(clamp(40 + 15*pow, 35, 95));
          BFX.punch(clamp(0.72*pow, 0.50, 1.60), -1);
          BFX.flash(hue);
          BFX.slash(pE.x - 24, pE.y - 26, pH.x + 18, pH.y - 10, clamp(0.90*pow, 0.65, 2.0), hue, (S.run && S.run.enemy && S.run.enemy.ilv) ? S.run.enemy.ilv : 1);
          BFX.impact(pH.x + 6, pH.y - 8, clamp(0.92*pow, 0.65, 2.0), hue);
        } catch(_){ }
      }

      if (fxOn){
        const sc = 1 + (pow-1)*0.65;
        fxSprite('hero', 'fx_claw', 'fxClaw', 300, null, null, sc);
        window.setTimeout(() => fxSprite('hero', 'fx_spark', 'fxSpark', 240, null, null, sc*0.95), 60);
      }
    }

    function enemyHit(dmg, isCrit){
      const pow = fxPowFromDmg(dmg, !!isCrit);
      const fxOn = fxEnabled();
      const lite = isSpeedMax();
      if (fxOn) pulse(els.enemyActor, 'hit', 260);
      if (lite){
        // MAX speed: skip heavy FX/text.
        return;
      }
      if (fxOn){
        try{
          const pE = BFX.posFromEl(els.enemyActor, 0.60, 0.35);
          const hue = isCrit ? 45 : 210;
          BFX.hitStop(clamp(38 + 17*pow, 35, 105));
          BFX.punch(clamp(0.75*pow, 0.50, 1.85), +1);
          BFX.flash(hue);
          BFX.impact(pE.x, pE.y - 10, clamp(1.02*pow, 0.70, 2.3), hue);
        } catch(_){ }
      }

      if (fxOn){
        const sc = 1 + (pow-1)*0.65;
        fxSprite('enemy', 'fx_spark', 'fxSpark', 240, null, null, sc);
        if (isCrit) fxSprite('enemy', 'fx_crit', 'fxCrit', 420, null, null, sc*1.05);
      }
      if (dmg > 0) floatDmg('enemy', '-' + Math.max(1, Math.round(dmg)), isCrit ? 'crit' : '');
    }

    function heroHit(dmg){
      const pow = fxPowFromDmg(dmg, false);
      const fxOn = fxEnabled();
      const lite = isSpeedMax();
      if (fxOn) pulse(els.heroActor, 'hit', 260);
      if (lite){
        // MAX speed: skip heavy FX/text.
        return;
      }
      if (fxOn){
        try{
          const pH = BFX.posFromEl(els.heroActor, 0.60, 0.70);
          const hue = 0;
          BFX.hitStop(clamp(38 + 16*pow, 35, 100));
          BFX.punch(clamp(0.70*pow, 0.50, 1.70), -1);
          BFX.flash(hue);
          BFX.impact(pH.x, pH.y - 8, clamp(0.95*pow, 0.65, 2.0), hue);
        } catch(_){ }
      }

      if (fxOn){
        const sc = 1 + (pow-1)*0.60;
        fxSprite('hero', 'fx_spark', 'fxSpark', 240, null, null, sc);
      }
      if (dmg > 0) floatDmg('hero', '-' + Math.max(1, Math.round(dmg)), '');
    }

    function sync(){
      const fxOn = fxEnabled();
      try{ if (typeof BFX !== 'undefined' && BFX && BFX.setEnabled) BFX.setEnabled(fxOn); }catch(_){ }
      try{ if (typeof BFX !== 'undefined' && BFX) BFX.resize(); }catch(_){ }
      if (els.battleStage){
        const running = !!(S.run && S.run.active && !(S.hero && S.hero.dead));
        els.battleStage.classList.toggle('running', running && fxOn);
        els.battleStage.classList.toggle('noAnim', !fxOn);
        if (!fxOn) els.battleStage.classList.remove('hitstop');
      }
      if (els.heroActor) els.heroActor.classList.toggle('dead', !!(S.hero && S.hero.dead));
      if (els.enemyActor) els.enemyActor.classList.toggle('dead', !!(S.run && S.run.enemyHp <= 0));
      drawBase();
    }
    function syncLite(){
      // Lightweight sync for MAX speed: no resize/particles, only state + stage icons.
      const fxOn = fxEnabled();
      if (els.battleStage){
        const running = !!(S.run && S.run.active && !(S.hero && S.hero.dead));
        els.battleStage.classList.toggle('running', running && fxOn);
        els.battleStage.classList.toggle('noAnim', !fxOn);
        if (!fxOn) els.battleStage.classList.remove('hitstop');
      }
      if (els.heroActor) els.heroActor.classList.toggle('dead', !!(S.hero && S.hero.dead));
      if (els.enemyActor) els.enemyActor.classList.toggle('dead', !!(S.run && S.run.enemyHp <= 0));
      try{
        if (els.heroStageSprite) drawHeroKanji(els.heroStageSprite, S.hero);
        if (els.enemyStageSprite) drawEnemyKanji(els.enemyStageSprite, S.run && S.run.enemy);
      }catch(_){ }
    }

    return { heroAttack, enemyAttack, enemyHit, heroHit, sync, syncLite };
  })();

  let dirtyHUD = true, dirtyInv = true, dirtyLog = true;
  let lastSimFrame = now();
  let lastRenderFrame = now();
  let lastInvSig = "";
  let lastQuery = "";
  let lastSort = "";

  function renderRunLocMini(){
    try{
      const h = S.hero;
      const r = S.run;
      if (!r) return;
      const loc = "F" + r.floor + " R" + r.room + "/" + r.roomsPerFloor;
      const spv = (Number.isFinite(r.speed) ? r.speed : 1);
      const sp = "×" + (spv >= SPEED_MAX_LABEL ? "MAX" : spv);
      if (els.runInfo) els.runInfo.textContent = (r.active ? "巡礼中" : (h && h.dead ? "調伏不能" : "待機")) + " • " + loc + " " + sp;
      if (els.biomeText) els.biomeText.textContent = biomeForFloor(r.floor).name;
      try{ document.documentElement.dataset.realm = biomeForFloor(r.floor).key || ''; }catch(_){ }
    } catch(_){ }
  }

  function renderHUD(){
    try{ ensureMikkyoFields(); }catch(_){ }
    const st = calcStats();
    const h = S.hero;
    const r = S.run;

    els.speedSel.value = String(r.speed ?? 1);
    syncSpeedSelUnlock();
    els.autoSel.value = r.auto ? "1" : "0";
    if (els.fxSel){ els.fxSel.value = (S.ui && Number(S.ui.fx) === 0) ? "0" : "1"; }

    if (els.upgBulkSel){ els.upgBulkSel.value = String((S.ui && S.ui.upgBulk) || 1); }
    if (els.gupgBulkSel){ els.gupgBulkSel.value = String((S.ui && S.ui.gupgBulk) || 1); }

    // Auto-sell UI
    if (els.autoSellOn){ els.autoSellOn.checked = !!(S.ui && Number(S.ui.autoSellOn) === 1); }
    if (els.autoSellRarMax){ els.autoSellRarMax.value = (S.ui && S.ui.autoSellRarMax) ? String(S.ui.autoSellRarMax) : "common"; }
    if (els.autoSellUseEq){ els.autoSellUseEq.checked = !!(S.ui && Number(S.ui.autoSellUseEq) === 1); }
    if (els.autoSellEqPct){ els.autoSellEqPct.value = String((S.ui && S.ui.autoSellEqPct) ? S.ui.autoSellEqPct : 90); }
    if (els.autoSellProtectUnique){ els.autoSellProtectUnique.checked = !(S.ui && Number(S.ui.autoSellProtectUnique) === 0); }

    // disable states
    try{
      const _on = els.autoSellOn && els.autoSellOn.checked;
      if (els.autoSellRarMax) els.autoSellRarMax.disabled = !_on;
      if (els.autoSellUseEq) els.autoSellUseEq.disabled = !_on;
      if (els.autoSellEqPct) els.autoSellEqPct.disabled = (!_on) || !(els.autoSellUseEq && els.autoSellUseEq.checked);
      if (els.autoSellProtectUnique) els.autoSellProtectUnique.disabled = !_on;
    }catch(_){ }

    const loc = "F" + r.floor + " R" + r.room + "/" + r.roomsPerFloor;
    const spv = (Number.isFinite(r.speed) ? r.speed : 1);
    const sp = "×" + (spv >= SPEED_MAX_LABEL ? "MAX" : spv);
    els.runInfo.textContent = (r.active ? "巡礼中" : (h.dead ? "調伏不能" : "待機")) + " • " + loc + " " + sp;
    if (els.locText) els.locText.textContent = loc + " " + sp;
    try{ document.documentElement.dataset.realm = biomeForFloor(r.floor).key || ''; }catch(_){ }
    els.btnExplore.textContent = r.active ? "▶ 巡礼中" : "▶ 巡礼開始";
    els.deathNote.style.display = h.dead ? "" : "none";
    if (els.deathOverlay) els.deathOverlay.style.display = h.dead ? "flex" : "none";

    const need = expNeed(h.lv);
    els.lvExp.textContent = `位 ${fmt(h.lv)}`;
    const needDisp = Number.isFinite(need) ? fmt(need) : "∞";
    els.expText.textContent = `行 ${fmt(h.exp)}/${needDisp}`;
    els.goldText.textContent = "功徳 " + fmt(h.gold);
    if (els.karmaText) els.karmaText.textContent = "業 " + ((h.karma>=0)?("+"+fmt(h.karma)):fmt(h.karma)) + karmaPullTag(h.karma);
    if (els.satoriText) els.satoriText.textContent = "菩提 " + fmt(h.satori);
    els.expBar.style.width = Number.isFinite(need) ? `${clamp(h.exp/need, 0, 1)*100}%` : "0%";

    if (els.heroName) els.heroName.textContent = (h.name && String(h.name).trim()) ? String(h.name).trim() : '行者';

    els.hpText.textContent = `${fmt(h.hp)}/${fmt(h.hpMax)}`;
    els.hpBar.style.width = `${clamp(safeDiv(h.hp, h.hpMax, 0),0,1)*100}%`;


    const dps = st.atk * st.spd * (1 + st.crit*0.6) * st.dmgFactor;
    els.dpsText.textContent = `調伏/秒 ${fmt(dps)}`;
    els.luckText.textContent = "縁×" + st.luckFactor.toFixed(2) + " 功徳×" + st.goldMult.toFixed(2) + " 行×" + st.xpMult.toFixed(2) + (st.mantraOn?" / 真言:顕現":"");

    if (els.atkVal) els.atkVal.textContent = fmt(st.atk);
    if (els.defVal) els.defVal.textContent = fmt(st.def);
    const _critCap = 0.65, _spdCap = 2.75, _drCap = 0.60, _eps = 1e-9;
    const critDisp = (st.crit >= _critCap - _eps) ? "MAX" : pct(st.crit);
    const spdDisp  = (st.spd  >= _spdCap  - _eps) ? "MAX" : st.spd.toFixed(2);
    const drDisp   = (st.dr   >= _drCap   - _eps) ? "MAX" : pct(st.dr);
    if (els.critText) els.critText.textContent = `慧眼 ${critDisp}`;
    if (els.spdText)  els.spdText.textContent  = `迅行 ${spdDisp}× / 苦減 ${drDisp}`;



// 真言 UI
try{
  // Chant button state
  if (els.btnChant){
    const t = now();
    const cd = (S.run && S.run.mantraCdUntil) ? S.run.mantraCdUntil : 0;
    const ready = t >= cd;
    els.btnChant.classList.toggle('ready', ready);
    els.btnChant.classList.toggle('cooldown', !ready);
    if (!ready){
      const left = Math.max(0, cd - t);
      const leftS = left / 1000;
      els.btnChant.textContent = `🕉 真言 (${leftS.toFixed(0)}s)`;
    } else {
      els.btnChant.textContent = '🕉 真言';
    }
  }
}catch(_){ }

const g = S.gear;
    const locks = (h.lock || {});
    if (els.lockWeapon){ const on=!!locks.weapon; els.lockWeapon.textContent = on ? '🔒' : '🔓'; els.lockWeapon.classList.toggle('locked', on); els.lockWeapon.title = on ? '自動加持: 止（封印中）' : '自動加持: 顕'; }
    if (els.lockArmor){ const on=!!locks.armor; els.lockArmor.textContent = on ? '🔒' : '🔓'; els.lockArmor.classList.toggle('locked', on); els.lockArmor.title = on ? '自動加持: 止（封印中）' : '自動加持: 顕'; }
    if (els.lockAcc){ const on=!!locks.accessory; els.lockAcc.textContent = on ? '🔒' : '🔓'; els.lockAcc.classList.toggle('locked', on); els.lockAcc.title = on ? '自動加持: 止（封印中）' : '自動加持: 顕'; }

    if (g.weapon){
      if (els.eqWeapon) els.eqWeapon.textContent = dispItemName(g.weapon);
      if (els.eqWeaponRar){ els.eqWeaponRar.className = `rar ${g.weapon.rarity}`; els.eqWeaponRar.textContent = rarLabel(g.weapon.rarity); }
      if (els.eqWeapon位) els.eqWeapon位.textContent = `位 ${fmt(g.weapon.ilv)}`;
      if (els.eqWeaponPerf){ els.eqWeaponPerf.textContent = equipSummary(g.weapon); els.eqWeaponPerf.title = equipPerfTitle(g.weapon); }
    } else {
      if (els.eqWeapon) els.eqWeapon.textContent = "—";
      if (els.eqWeaponRar){ els.eqWeaponRar.className = "rar common"; els.eqWeaponRar.textContent = "—"; }
      if (els.eqWeapon位) els.eqWeapon位.textContent = "—";
      if (els.eqWeaponPerf){ els.eqWeaponPerf.textContent = '—'; els.eqWeaponPerf.title = ''; }
    }

    if (g.armor){
      if (els.eqArmor) els.eqArmor.textContent = dispItemName(g.armor);
      if (els.eqArmorRar){ els.eqArmorRar.className = `rar ${g.armor.rarity}`; els.eqArmorRar.textContent = rarLabel(g.armor.rarity); }
      if (els.eqArmor位) els.eqArmor位.textContent = `位 ${fmt(g.armor.ilv)}`;
      if (els.eqArmorPerf){ els.eqArmorPerf.textContent = equipSummary(g.armor); els.eqArmorPerf.title = equipPerfTitle(g.armor); }
    } else {
      if (els.eqArmor) els.eqArmor.textContent = "—";
      if (els.eqArmorRar){ els.eqArmorRar.className = "rar common"; els.eqArmorRar.textContent = "—"; }
      if (els.eqArmor位) els.eqArmor位.textContent = "—";
      if (els.eqArmorPerf){ els.eqArmorPerf.textContent = '—'; els.eqArmorPerf.title = ''; }
    }

    if (g.accessory){
      if (els.eqAcc) els.eqAcc.textContent = dispItemName(g.accessory);
      if (els.eqAccRar){ els.eqAccRar.className = `rar ${g.accessory.rarity}`; els.eqAccRar.textContent = rarLabel(g.accessory.rarity); }
      if (els.eqAcc位) els.eqAcc位.textContent = `位 ${fmt(g.accessory.ilv)}`;
      if (els.eqAccPerf){ els.eqAccPerf.textContent = equipSummary(g.accessory); els.eqAccPerf.title = equipPerfTitle(g.accessory); }
    } else {
      if (els.eqAcc) els.eqAcc.textContent = "—";
      if (els.eqAccRar){ els.eqAccRar.className = "rar common"; els.eqAccRar.textContent = "—"; }
      if (els.eqAcc位) els.eqAcc位.textContent = "—";
      if (els.eqAccPerf){ els.eqAccPerf.textContent = '—'; els.eqAccPerf.title = ''; }
    }

    const e = r.enemy;
    els.biomeText.textContent = biomeForFloor(r.floor).name;
    if (els.floorText) els.floorText.textContent = r.floor;
    if (els.roomText) els.roomText.textContent = `${r.room}/${r.roomsPerFloor}`;
    if (els.safeTag && els.safeText){
      const sec = (r.entryShield || 0);
      els.safeTag.style.display = sec > 0 ? "" : "none";
      els.safeText.textContent = sec > 0 ? `${sec.toFixed(1)}s` : "—";
    }

    els.eliteTag.style.display = e && e.isElite ? "" : "none";
    els.bossTag.style.display = e && e.isBoss ? "" : "none";

    if (e){
      els.enemyName.textContent = dispEnemyName(e.name);
      els.enemyHpBar.style.width = `${clamp(safeDiv(r.enemyHp, r.enemyHpMax, 0), 0, 1) * 100}%`;

      els.enemyHpText.textContent = `${fmt(r.enemyHp)}/${fmt(r.enemyHpMax)}`;
      const modHtml = (r.mods && r.mods.length) ? ` <span class="warn">[${modsHtml(r.mods)}]</span>` : "";
      els.enemyStatsText.innerHTML = `降魔 ${fmt(e.atk)} / 持戒 ${fmt(e.def)} / 戦利品位 ${fmt(e.ilv)}${modHtml}`;
      // Tooltip: include per-affix explanation
      els.enemyStatsText.title = `降魔 ${fmt(e.atk)} / 持戒 ${fmt(e.def)} / 戦利品位 ${fmt(e.ilv)}` + (r.mods && r.mods.length ? `\n${modsTitle(r.mods)}` : "");
    } else {
      els.enemyName.textContent = "—";
      els.enemyHpBar.style.width = "0%";
      els.enemyHpText.textContent = "—";
      els.enemyStatsText.textContent = "—";
      els.enemyStatsText.title = "";
    }

    const u = h.base;
    els.upgText.textContent = `精進 ${u.str} / 忍辱 ${u.vit} / 持戒 ${u.def} / 縁 ${u.luck}`;
    els.upgCostText.textContent = `次の代価: ${fmt(upgradeCost())}功徳（×${(S.ui&&S.ui.upgBulk)||1}）`;

        if (els.gupgText && els.gupgCostText){
const gg = h.guild;
    const capForge = guildCap("forge"), capBounty = guildCap("bounty"), capLib = guildCap("library"), capShr = guildCap("shrine");
    const nextForge  = (gg.forge  >= capForge) ? "MAX" : `${fmt(guildCost("forge"))}徳`;
    const nextBounty = (gg.bounty >= capBounty)? "MAX" : `${fmt(guildCost("bounty"))}徳`;
    const nextLib    = (gg.library>= capLib)   ? "MAX" : `${fmt(guildCost("library"))}徳`;
    const nextShr    = (gg.shrine >= capShr)   ? "MAX" : `${fmt(guildCost("shrine"))}徳`;

    els.gupgText.textContent = `鍛冶 ${gg.forge}/${capForge} / 賞金 ${gg.bounty}/${capBounty} / 図書 ${gg.library}/${capLib} / 祈り ${gg.shrine}/${capShr}`;
    els.gupgCostText.textContent = `次: 鍛冶 ${nextForge} | 賞金 ${nextBounty} | 図書 ${nextLib} | 祈り ${nextShr}`;

    // 上限に達した設備は押せないようにする
    document.querySelectorAll("button[data-gupg]").forEach(btn=>{
      const which = btn.getAttribute("data-gupg");
      const cap = guildCap(which);
      const cur = Math.max(0, Math.floor(num(S.hero.guild[which], 0)));
      const atCap = cur >= cap;
      btn.disabled = atCap;
      btn.classList.toggle("disabled", atCap);
    });    }

try{
      if (typeof syncBulkLabels === "function") syncBulkLabels(false);
    }catch(_){ }


    if (r.offlineChest){
      els.offlineNote.textContent = `未接続宝函: ${r.offlineChest.count}個（ilv ${r.offlineChest.ilv}）`;
      els.btnOpenChest.style.display = "";
    } else {
      els.offlineNote.textContent = `記録: 自動（10秒ごと）+ 手動 | 界相: 20階層ごとに切替`;
      els.btnOpenChest.style.display = "none";
    }

    els.btnRevive.style.display = h.dead ? "" : "none";

    if (!isSpeedMax()){
      updateHUDSprites();
      try{ BATTLE.sync(); }catch(_){ }
    }
  }

  function inventorySignature(){
    // At MAX sim speed, inventory changes can be extremely frequent; avoid heavy signatures.
    if (isSpeedMax()) return String(S.inv.length);
    const ids = S.inv.slice(0, 12).map(x=>x.id).join("|");
    const tail = S.inv.slice(-6).map(x=>x.id).join("|");
    return `${S.inv.length}:${ids}:${tail}`;
  }

  
  function compareRow(it){
    try{
      const d = compareDeltaForItem(it);
      const s = summarizeDelta(d, it.slot);
      const good = d.dpsPct >= 0;
      const cls = good ? "goodTxt" : "badTxt";
      return `<span class="${cls}">加持中より</span>: <span class="${cls}">${escapeHtml(s)}</span>`;
    } catch(e){
      return `<span class="mutedTxt">比較情報を計算できません</span>`;
    }
  }

function renderInventory(){
    els.invCount.textContent = `${S.inv.length} 個`;
    const tab = (S.ui && S.ui.tab) ? S.ui.tab : "all";
    if (els.tabs){
      els.tabs.querySelectorAll(".tabBtn").forEach(btn => btn.classList.toggle("active", (btn.dataset.tab||"all") === tab));
    }

    const q = (els.search.value || "").trim().toLowerCase();
    const sortKey = els.sortSel.value;

    let items = S.inv.slice();
    if (tab !== "all") items = items.filter(it => it.slot === tab);
    if (q){
      items = items.filter(it => {
        const blob = `${dispItemName(it)} ${it.slot} ${it.rarity} ${statLines(it.stats)} ${dispDesc(it.desc||"")}`.toLowerCase();
        return blob.includes(q);
      });
    }

    if (sortKey === "ilv"){
      items.sort((a,b)=> (b.ilv - a.ilv) || (itemPower(b)-itemPower(a)));
    } else if (sortKey === "rar"){
      items.sort((a,b)=> (rarScore(b.rarity)-rarScore(a.rarity)) || (b.ilv-a.ilv));
    } else if (sortKey === "slot"){
      const sidx = (s)=> SLOT_ORDER.indexOf(s);
      items.sort((a,b)=> (sidx(a.slot)-sidx(b.slot)) || (b.ilv-a.ilv));
    } else if (sortKey === "power"){
      items.sort((a,b)=> itemPower(b)-itemPower(a));
    }

    const SHOW_LIMIT = 220;
    const overflow = Math.max(0, items.length - SHOW_LIMIT);
    const show = overflow ? items.slice(0, SHOW_LIMIT) : items;

    els.invList.innerHTML = show.map(it => {
      const rname = rarLabel(it.rarity);
      const spr = SPR.itemKey(it);
      const glyph = SPR.itemGlyph(it);
      const stats = statLinesWithCaps(it) || statLines(it.stats);
      const statPills = statPillsHTML(it.stats, it);
      const descHtml = it.desc ? `<div class=\"idesc\">${escapeHtml(it.desc)}</div>` : ``;
      const pill = `${SLOT_NAME[it.slot]} / 加持位 ${fmt(it.ilv)}`;
      return `
        <div class="item rar-${it.rarity} ${((S.ui&&S.ui.preview)===it.id) ? "selected" : ""}" data-item="${it.id}">
          <div class="left">
            <canvas class="pxSprite pxMini itemIcon rar-${it.rarity}" width="64" height="64" data-spr="${spr}" data-glyph="${glyph}" aria-hidden="true"></canvas>
            <div class="itText">
              <div class="iname">
              <span class="rar ${it.rarity}">${rname}</span>
              <span class="inameName">${escapeHtml(dispItemName(it))}</span>
              <span class="pill">${pill}</span>
              <span class="pill">強さ ${fmt(itemPower(it))}</span>
            </div>
            <div class="istat">${statPills || `<span class="sp">—</span>`}</div>
            ${descHtml}
            <div class="cmpBox">${compareRow(it)}</div>
            </div>
          </div>
          <div class="actions">
            <button class="small accent" data-eq="${it.id}">加持</button>
            <button class="small" data-sell="${it.id}">布施</button>
          </div>
        </div>
      `;
    }).join("");
    renderSpriteCanvases(els.invList);
  }

  
  function stripTags(s){
    return String(s||"").replace(/<[^>]*>/g, " ");
  }

  function toneLogMsg(msg){
    // Apply a slightly more polite / ritual-like tone without changing the meaning.
    // Works on stored logs too (render-time), so old saves also benefit.
    let s = String(msg ?? "");

    // --- label words inside spans ---
    s = s.replace(/>不足</g, ">不足しております<");
    s = s.replace(/>上限</g, ">上限です<");
    s = s.replace(/>戻れません</g, ">戻ることはできません<");
    s = s.replace(/>調伏に至らず</g, ">調伏に至りませんでした<");

    // --- common phrasing ---
    s = s.replace(/に到達。/g, "に到達しました。");
    s = s.replace(/戻れません/g, "戻ることはできません");
    s = s.replace(/手動記録しました。/g, "記録を残しました。");
    s = s.replace(/調伏に至らず/g, "調伏に至りませんでした");
    s = s.replace(/没収/g, "没収されました");

    // "必要" → "必要です" (avoid double)
    s = s.replace(/必要(?!です)/g, "必要です");

    // Verb endings for short phrases commonly used at the end of lines
    s = s.replace(/を更新(?!しました)/g, "を更新しました");
    s = s.replace(/を無効化(?!しました)/g, "を無効化しました");
    s = s.replace(/を布施(?!しました)/g, "を布施しました");

    // A touch of atmosphere for plain movement logs
    s = s.replace(/^歩を進めました。$/g, "静かに歩を進めました。");
    s = s.replace(/^歩を進めました$/g, "静かに歩を進めました");
    return s;
  }

function dqifyLogMsg(msg){
  let s = String(msg ?? "");

  // Avoid double-processing: already formatted (multi-line) battle logs.
  if (s.includes("の攻撃！") || (s.includes("HP:") && s.includes("<br>"))) return s;

  // Enemy appears
  s = s.replace(/^現前:\s*(<span[^>]*>[^<]*<\/span>)(.*)$/s, (m, nameSpan, tail)=>{
    const t = (tail||"").trim();
    return `${nameSpan}が あらわれた！` + (t ? `<br><span class="mutedTxt">${t}</span>` : "");
  });

  // Floor reach
  s = s.replace(/^<span class="good">層\s*([^<]+)<\/span>\s*に到達(?:しました)?。六道:\s*(.+)$/s, (m, floor, biome)=>{
    return `<span class="good">層 ${floor}</span>へ 進んだ！<br><span class="mutedTxt">六道: ${biome}</span>`;
  });

  // Chest open
  s = s.replace(/^宝函:\s*(.+)$/s, (m, rest)=>{
    const r = (rest||"").trim();
    return `宝箱を開けた！` + (r ? `<br>　${r}を手に入れた！` : "");
  });

  // Equip (HP upgrade)
  s = s.replace(/^加持:\s*\+([0-9,]+)命\s*(.*)$/s, (m, amt, tail)=>{
    const t = (tail||"").trim();
    return `行者の命が <span class="good">+${amt}</span> 上がった！` + (t ? `<br><span class="mutedTxt">${t}</span>` : "");
  });

  // Equip (item)
  s = s.replace(/^加持:\s*(.+)$/s, (m, rest)=>{
    const r = (rest||"").trim();
    if (!r) return m;
    // If it already looks like a DQ sentence, keep it.
    if (/を加持した！$/.test(stripTags(r))) return m;
    return `行者は ${r}を加持した！`;
  });

  // Sell (single)
  s = s.replace(/^布施:\s*(.+?)\s*<span class="gold">\(\+([^<]+)功徳\)<\/span>\s*$/s, (m, item, g)=>{
    return `行者は ${item}を布施した！<br><span class="gold">功徳が+${g}増えた！</span>`;
  });

  // Sell (bulk)
  s = s.replace(/^一括布施:\s*([0-9,]+)個\s*<span class="gold">\(\+([^<]+)功徳\)<\/span>\s*$/s, (m, n, g)=>{
    return `行者は 不要な法具をまとめて布施した！ <span class="mutedTxt">(${n}個)</span><br><span class="gold">功徳が+${g}増えた！</span>`;
  });

  // Auto-sell from chest / inventory
  s = s.replace(/^<span class="warn">自動布施(?:\(宝函\))?<\/span>:\s*([0-9,]+)個\s*<span class="gold">\(\+([^<]+)功徳\)<\/span>\s*$/s, (m, n, g)=>{
    return `<span class="warn">自動整理</span>: 行者は法具庫を整えた。 <span class="mutedTxt">(${n}個を布施)</span><br><span class="gold">功徳が+${g}増えた！</span>`;
  });
  s = s.replace(/^<span class="warn">自動整理<\/span>:\s*(.+?)を布施\s*<span class="gold">\(\+([^<]+)功徳\)<\/span>\s*$/s, (m, tail, g)=>{
    return `<span class="warn">自動整理</span>: 行者は法具庫を整えた。<br><span class="mutedTxt">${tail}を布施</span> / <span class="gold">功徳+${g}</span>`;
  });

  // Level up
  s = s.replace(/^<span class="good">昇位！<\/span>\s*位\s*([0-9,]+)\s*$/s, (m, lv)=>{
    return `行者の位が上がった！<br><span class="good">位 ${lv}</span>`;
  });

  // Enemy defeated (DQ-style)
  s = s.replace(/^<span class="good">撃破<\/span>:\s*([^（]+)（([^)]*)\)\s*<span class="gold">\(\+([^<]+)功徳\)<\/span>\s*\(\+([^)]+)経験\)\s*$/s, (m, enemy, last, g, xp)=>{
    let lastTxt = stripTags(String(last||"")).trim();
    const hasHama = lastTxt.includes("破魔");
    lastTxt = lastTxt.replace(/^最後の降魔:\s*/,"とどめの一撃: ");
    lastTxt = lastTxt.replace(/\s*苦\s*$/," ダメージ");
    const lastLines = lastTxt ? (hasHama ? `会心の一撃！<br><span class="mutedTxt">${lastTxt}</span>` : `<span class="mutedTxt">${lastTxt}</span>`) : "";
    return `行者の攻撃！<br><span class="good">${enemy}</span>を たおした！`
      + (lastLines ? `<br>${lastLines}` : ``)
      + `<br><span class="gold">功徳を +${g} てにいれた！</span>`
      + `<br><span class="good">経験を +${xp} かくとく！</span>`;
  });

  // Barrier (entry shield)
  s = s.replace(/^<span class="good">結界<\/span>:\s*次の入室盾を強化\s*<span class="gold">\(-([^<]+)功徳\)<\/span>\s*$/s, (m, g)=>{
    return `行者は 結界を張った！<br>次の入室盾が 厚くなった！<br><span class="gold">功徳 -${g}</span>`;
  });

  // Ritual (auto)
  s = s.replace(/^<span class="good">儀礼<\/span>:\s*(.+?)（自動処理）\s*$/s, (m, title)=>{
    const t = stripTags(String(title||"")).trim();
    const nice = t.replace(/^結界\s*[—\-–]\s*/,"");
    return `行者は 儀礼をおこなった！ <span class="mutedTxt">（自動）</span><br><span class="mutedTxt">${nice || t}</span>`;
  });

  // Pride recoil
  s = s.replace(/^<span class="warn">慢<\/span>:\s*返業\s*([0-9.,]+(?:[KMBT])?)\s*苦\s*$/s, (m, amt)=>{
    return `慢の返業！<br>行者は <span class="warn">${amt}</span>のダメージを うけた！ <span class="mutedTxt">(苦)</span>`;
  });

  // Death
  s = s.replace(/^<span class="bad">調伏に至らず<\/span>…（死因:\s*(.+)\)\s*$/s, (m, detail)=>{
    return `<span class="bad">行者は ちからつきた…</span><br><span class="mutedTxt">死因: ${detail}</span>`;
  });

  // Reborn
  s = s.replace(/^<span class="good">復活<\/span>:\s*<span class="gold">-([^<]+)功徳<\/span>\s*$/s, (m, g)=>{
    return `<span class="good">行者は復活した！</span><br><span class="gold">功徳 -${g}</span>`;
  });

  // Upgrades / training (light touch)
  s = s.replace(/^<span class="good">拠点強化<\/span>:\s*(.+)$/s, (m, tail)=>{
    return `拠点が強化された！<br><span class="mutedTxt">${tail}</span>`;
  });
  s = s.replace(/^<span class="rare">設備強化<\/span>:\s*(.+)$/s, (m, tail)=>{
    return `設備が強化された！<br><span class="mutedTxt">${tail}</span>`;
  });
  s = s.replace(/^<span class="good">修行<\/span>:\s*(.+)$/s, (m, tail)=>{
    return `行者は修行を積んだ！<br><span class="mutedTxt">${tail}</span>`;
  });

  // Seals
  s = s.replace(/^<span class="rare">六印<\/span>:\s*(.+)の欠片（(.+)）\s*$/s, (m, sealPart, inside)=>{
    return `六印の欠片を手に入れた！<br><span class="mutedTxt">${sealPart}（${inside}）</span>`;
  });
  s = s.replace(/^<span class="rare">印<\/span>:\s*(.+)（(.+)）\s*$/s, (m, seal, inside)=>{
    return `印が かがやいた！<br><span class="mutedTxt">${seal}（${inside}）</span>`;
  });

  // Not enough / cap / no-return
  s = s.replace(/^<span class="bad">不足<\/span>:\s*(.+)$/s, (m, tail)=>{
    return `<span class="bad">しかし たりない！</span><br><span class="mutedTxt">${tail}</span>`;
  });
  s = s.replace(/^<span class="warn">上限<\/span>:\s*(.+)$/s, (m, tail)=>{
    return `<span class="warn">しかし これ以上は できない！</span><br><span class="mutedTxt">${tail}</span>`;
  });
  s = s.replace(/^<span class="warn">戻れません<\/span>:\s*(.+)$/s, (m, tail)=>{
    return `<span class="warn">しかし もどれない！</span><br><span class="mutedTxt">${tail}</span>`;
  });

  return s;
}

  function isMaxSpeedUnlocked(){
    try{ return !!hasAllSixFragments(); }catch(_){ return false; }
  }
  function maxSpeedLockNote(){
    try{
      const n = Math.min(6, Math.max(0, fragmentCount()));
      return `${n}/6`;
    }catch(_){
      return "0/6";
    }
  }
  function syncSpeedSelUnlock(){
    try{
      if (typeof els === "undefined" || !els || !els.speedSel) return;
      const sel = els.speedSel;
      const optMax = sel.querySelector(`option[value="${SPEED_MAX_LABEL}"]`);
      if (!optMax) return;

      const ok = isMaxSpeedUnlocked();
      if (!ok){
        optMax.disabled = true;
        optMax.textContent = `MAX（六印 ${maxSpeedLockNote()}）`;
        optMax.title = "曼荼羅帳の六印の欠片を6つ揃えると解放";

        // If current speed is MAX but not unlocked (e.g., old saves), fall back.
        if (S && S.run && Number(S.run.speed) >= SPEED_MAX_LABEL){
          const fallback = Math.max(...SPEED_ALLOWED.filter(v => v < SPEED_MAX_LABEL));
          S.run.speed = fallback;
          sel.value = String(fallback);
        }
      } else {
        optMax.disabled = false;
        optMax.textContent = "MAX";
        optMax.title = "最高速度";
      }
    }catch(_){}
  }


  function detectSeverity(msg){
    const m = String(msg||"");
    if (/\bclass="[^"]*\bbad\b/.test(m) || /\bclass='[^']*\bbad\b/.test(m)) return "bad";
    if (/\bclass="[^"]*\bwarn\b/.test(m) || /\bclass='[^']*\bwarn\b/.test(m)) return "warn";
    if (/\bclass="[^"]*\brare\b/.test(m) || /\bclass='[^']*\brare\b/.test(m)) return "rare";
    if (/\bclass="[^"]*\bgood\b/.test(m) || /\bclass='[^']*\bgood\b/.test(m)) return "good";
    return "";
  }
  function detectKind(msg){
    const s = stripTags(msg).replace(/\s+/g," ").trim();
    const has = (w)=> s.indexOf(w) >= 0;
    // Order matters: specific → general
    if (has("六印") || has("欠片") || has("結願") || has("印成") || has("印を")) return {key:"seal",  label:"六印", ico:"🪷"};
    if (has("界門") || has("曼荼羅帳") || has("苦諦界") || has("集諦界") || has("無明界") || has("瞋慢界") || has("分別界") || has("有頂界") || has("六道")) return {key:"realm", label:"六道", ico:"🗺"};
    if (has("真言") || has("mantra")) return {key:"mantra", label:"真言", ico:"📿"};
    if (has("加持") || has("empower") || has("付与")) return {key:"empower", label:"加持", ico:"✨"};
    if (has("宝函") || has("未接続") || has("chest")) return {key:"chest", label:"宝函", ico:"📦"};
    if (has("自動布施") || has("布施") || has("売却")) return {key:"sell", label:"布施", ico:"🧹"};
    if (has("撃破") || has("討伐") || has("被弾") || has("会心") || has("HP") || has("ダメ") || has("敵") || has("戦闘")) return {key:"combat", label:"戦闘", ico:"⚔"};
    if (has("功徳") || has("行") || has("悟り") || has("業")) return {key:"reward", label:"収支", ico:"＋"};
    return {key:"system", label:"ログ", ico:"ℹ"};
  }

  function renderLog(){
    ensureLogIds();
    const wasPinned = isLogPinned(els.log);
    logPinned = wasPinned;

    const want = S.log.slice(-logCap());
    if (!want.length){
      els.log.innerHTML = "";
      logPending = [];
      logQueuedUpTo = 0;
      logPumpOn = false;
      return;
    }

    const firstId = Number(want[0].id || 0);
    const lastId  = Number(want[want.length-1].id || 0);

    const curFirst = els.log.firstElementChild ? Number(els.log.firstElementChild.dataset.id || 0) : 0;
    const curLast  = els.log.lastElementChild  ? Number(els.log.lastElementChild.dataset.id  || 0) : 0;

    // NOTE: Allow incremental updates when the log window slides forward.
    // If curFirst < firstId, we can trim instead of full re-render (prevents burst display).
    const needsFull = (!els.log.firstElementChild) || (curLast < firstId) || (curFirst > firstId) || (curLast > lastId);

    function makeEntry(x, isNew){
      const msg2 = dqifyLogMsg(toneLogMsg(x.msg));
      const k = detectKind(msg2);
      const sev = detectSeverity(msg2);
      const sevCls = sev ? ` sev-${sev}` : "";
      const d = document.createElement("div");
      d.className = `entry kind-${k.key}${sevCls}`;
      d.dataset.id = String(x.id || 0);
      d.innerHTML = `
        <span class="time">${x.t}</span>
        <span class="badge"><span class="ico">${k.ico}</span>${k.label}</span>
        <span class="msg">${msg2}</span>
      `;
      if (isNew && !isLogLite()){
        d.classList.add("new");
        if (reduceMotion){
          d.classList.remove("new");
        }else{
          requestAnimationFrame(()=>setTimeout(()=>d.classList.remove("new"), 50));
        }
      }
      return d;
    }

    if (needsFull){
      els.log.innerHTML = "";
      const frag = document.createDocumentFragment();
      for (const x of want) frag.appendChild(makeEntry(x, false));
      els.log.appendChild(frag);

      // Reset pacing queue
      logPending = [];
      logQueuedUpTo = lastId;
      logPumpOn = false;

      if (wasPinned){
        pinLogToBottom(els.log, 0);
      }
      return;
    }
const baseLast = Math.max(curLast, logQueuedUpTo);

    if (wasPinned){
      let maxQueued = baseLast;

      // Queue new rows (one-by-one display)
      for (const x of want){
        const id = Number(x.id || 0);
        if (id > baseLast){
          logPending.push({ id, node: makeEntry(x, true) });
          if (id > maxQueued) maxQueued = id;
        }
      }
      logQueuedUpTo = maxQueued;

      // Drop any rows that rotated out while queued
      dropPendingBefore(firstId);
      trimLogDomToRange(firstId);

      // Start paced append
      if (logPending.length) startLogPump();

    }else{
      // User is reading older logs: keep the view stable.
      // Queue new rows, but DO NOT insert them into DOM now (prevents bursts).
      let maxQueued = baseLast;
      for (const x of want){
        const id = Number(x.id || 0);
        if (id > baseLast){
          logPending.push({ id, node: makeEntry(x, true) });
          if (id > maxQueued) maxQueued = id;
        }
      }
      logQueuedUpTo = maxQueued;

      // Drop any rows that rotated out while queued
      dropPendingBefore(firstId);
      trimLogDomToRange(firstId);

      // (No auto-scroll / no flush here)
    }

    // Safety: if log rotated or pending flush made us longer than desired
    while (els.log.children.length > want.length){
      els.log.removeChild(els.log.firstElementChild);
    }
  }

  // --------------------
  // 密教拡張：行為
  // --------------------


  // --------------------
  // 二曼荼羅（分岐）
  // --------------------
  function mandalaName(k){
    return k==="kongo" ? "金剛界" : k==="taizo" ? "胎蔵界" : "未灌頂";
  }
  function mandalaSeal位(kind){
    ensureMikkyoFields();
    const s = S.hero.mandalaSeal || {kongo:0, taizo:0};
    return clamp(Math.floor(num(s[kind],0)), 0, 108);
  }
  function mandalaChoose(kind){
    ensureMikkyoFields();
    const cur = S.hero.mandala || "";
    if (cur && cur !== kind){
      return mandalaReattune(kind);
    }
    if (!cur){
      S.hero.mandala = kind;
      try{ document.documentElement.dataset.mandala = kind; }catch(_){ }
      addKarma(kind==="taizo" ? 2 : 1);
      log(`<span class="rare">灌頂</span>: 二曼荼羅「${mandalaName(kind)}」を選びました。`);
      try{ if (typeof BFX !== 'undefined' && BFX && BFX.pulse) BFX.pulse(kind==="kongo"?1:2); }catch(_){ }
      save(); dirtyHUD = true; dirtyLog = true;
      try{ updateRealmFx(); }catch(_){ }
    }
  }
  function mandalaReattune(to){
    ensureMikkyoFields();
    const cur = S.hero.mandala || "";
    if (!cur || cur === to){
      log(`<span class="warn">再灌頂</span>: まず片方を選んでください。`);
      return;
    }
    const sealSum = mandalaSeal位('kongo') + mandalaSeal位('taizo');
    const costSat = Math.round(14 + sealSum*0.06 + totalPath位()*0.05);
    const costGold = Math.round(1800 + sealSum*22 + S.run.floor*40);
    if (S.hero.satori < costSat || S.hero.gold < costGold){
      log(`<span class="bad">不足</span>: 再灌頂に 悟り${fmt(costSat)} / 功徳${fmt(costGold)} が必要`);
      return;
    }
    S.hero.satori -= costSat;
    S.hero.gold -= costGold;
    S.hero.mandala = to;
    try{ document.documentElement.dataset.mandala = to; }catch(_){ }
    addKarma(-2);
    log(`<span class="rare">再灌頂</span>: 「${mandalaName(to)}」へ切替 <span class="gold">(-${fmt(costGold)}功徳)</span> / (-${fmt(costSat)}悟り)`);
    save(); dirtyHUD = true; dirtyLog = true;
    try{ updateRealmFx(); }catch(_){ }
  }

  function mandalaSealCost(kind, bulk){
    const lv0 = mandalaSeal位(kind);
    const n = clampBulk(bulk);
    let g=0, s=0, got=0;
    for (let i=0;i<n;i++){
      const lv = lv0 + i;
      if (lv >= 108) break;
      g += Math.round(420 + Math.pow(lv+1, 1.42)*55);
      s += Math.round(2 + (lv+1)/18);
      got++;
    }
    return { costGold:g, costSat:s, got };
  }
  function buyMandalaSeal(kind, bulk){
    ensureMikkyoFields();
    const cur = S.hero.mandala || "";
    if (!cur){
      log(`<span class="warn">未灌頂</span>: まず「金剛界」か「胎蔵界」を選んでください。`);
      return;
    }
    if (cur !== kind){
      log(`<span class="warn">分岐</span>: 今は「${mandalaName(cur)}」の系統です。印の強化は同系統のみ。`);
      return;
    }
    const c = mandalaSealCost(kind, bulk);
    if (c.got <= 0){ log(`<span class="warn">上限</span>: これ以上強化できません。`); return; }
    if (S.hero.gold < c.costGold || S.hero.satori < c.costSat){
      log(`<span class="bad">不足</span>: 印の強化に 悟り${fmt(c.costSat)} / 功徳${fmt(c.costGold)} が必要`);
      return;
    }
    S.hero.gold -= c.costGold;
    S.hero.satori -= c.costSat;
    S.hero.mandalaSeal = S.hero.mandalaSeal || {kongo:0, taizo:0};
    S.hero.mandalaSeal[kind] = clamp(mandalaSeal位(kind) + c.got, 0, 108);
    log(`<span class="good">印の強化</span>: ${mandalaName(kind)}の印 +${c.got} <span class="gold">(-${fmt(c.costGold)}功徳)</span> / (-${fmt(c.costSat)}悟り)`);
    save(); dirtyHUD = true; dirtyLog = true;
  }
  function totalPath位(){
    const p = (S.hero && S.hero.path) ? S.hero.path : {};
    let t = 0;
    for (const k of ['view','thought','speech','action','livelihood','effort','mindfulness','concentration']) t += Math.floor(num(p[k],0));
    return t;
  }

  function pathCostFor(key, n){
    ensureMikkyoFields();
    const cur = clamp(Math.floor(num(S.hero.path[key],0)), 0, 108);
    n = clamp(Math.floor(num(n,1)), 1, 10000);
    let cost = 0;
    for (let i=0;i<n;i++){
      const lv = cur + i;
      if (lv >= 108) break;
      const base = 160 + (lv*22) + Math.pow(lv, 1.35)*8;
      const scale = 1 + Math.min(2.0, totalPath位()*0.0022);
      cost += Math.round(base * scale);
    }
    return Math.round(cost);
  }

  function buyPath(key, bulk){
    ensureMikkyoFields();
    const b = clamp(Math.floor(num(bulk,1)), 1, 10000);
    const cur = clamp(Math.floor(num(S.hero.path[key],0)), 0, 108);
    if (cur >= 108){ log('その修行は既に極まっております（位108）。'); dirtyLog=true; return; }
    const cost = pathCostFor(key, b);
    if (S.hero.gold < cost){ log(`<span class="warn">功徳が足りません</span>: ${fmt(cost)} 必要`); dirtyLog=true; return; }
    const before = cur;
    const canAdd = Math.min(b, 108 - cur);
    S.hero.gold -= cost;
    S.hero.path[key] = cur + canAdd;
    // 微量の善業（努力の積立）
    addKarma(Math.max(1, Math.floor(canAdd/10)));
    log(`<span class="good">修行</span>: ${PATH_KEYS.find(x=>x.key===key)?.name||key} +${canAdd} <span class="gold">(-${fmt(cost)}功徳)</span>`);
    save();
    dirtyHUD=true;
  }

  function dedicationPreview(){ return "回向は削除されました"; }
  function doDedicate(){ log("<span class=\"warn\">回向</span>: この要素は削除されました。"); dirtyLog=true; }


  function castMantra(){
    ensureMikkyoFields();
    const t = now();
    const cd = num(S.run.mantraCdUntil, 0);
    if (t < cd){ log(`<span class="warn">真言</span>: 冷却中（${(Math.max(0, cd-t)/1000).toFixed(0)}s）`); dirtyLog=true; return; }
    const need = 5;
    if (S.hero.satori < need){ log(`<span class="warn">真言</span>: 悟りが足りません（${need}必要）`); dirtyLog=true; return; }

    S.hero.satori -= need;

    // 八正道（永続）を削除したため、持続/冷却は固定
    const dur = 12; // 秒
    const cd2 = 30; // 秒

    S.run.mantraUntil = t + dur * 1000;
    S.run.mantraCdUntil = t + cd2 * 1000;
    S.hero.codex.mantras = (S.hero.codex.mantras||0) + 1;
    addKarma(1);
    log(`<span class="rare">真言</span>: 金剛界の加護（${dur.toFixed(0)}s）`);
    spawnMantraFx('ॐ');
    save();
    dirtyHUD=true;
  }


  function spawnMantraFx(glyph){
    if (!els.battleStage) return;
    if (!fxEnabled()) return;
    const ring = document.createElement('div');
    ring.className = 'mantraPulse';
    els.battleStage.appendChild(ring);
    const g = document.createElement('div');
    g.className = 'seedGlyph';
    g.textContent = glyph || 'ॐ';
    g.style.fontSize = '42px';
    els.battleStage.appendChild(g);
    window.setTimeout(()=>{ try{ ring.remove(); g.remove(); }catch(_){ } }, 1200);
    try{ if (typeof BFX !== 'undefined' && BFX && BFX.flash) BFX.flash(45); }catch(_){ }
  }

  function touchRealm(realmKey){
    ensureMikkyoFields();
    if (!realmKey) return;
    S.hero.codex.realms[realmKey] = 1;
  }

  function onEnemyDefeated(e, gold, xp){
    ensureMikkyoFields();
    S.hero.codex.kills = (S.hero.codex.kills||0) + 1;
    if (e.isBoss) S.hero.codex.bosses = (S.hero.codex.bosses||0) + 1;
    if (e.isElite) S.hero.codex.elites = (S.hero.codex.elites||0) + 1;
    if (S.run && S.run.floor) S.hero.codex.maxFloor = Math.max(S.hero.codex.maxFloor||1, Math.floor(S.run.floor));
    if (e && e.realmKey) touchRealm(e.realmKey);

    // 殺生の“負荷”を小さく入れる（真言中は苦減）
    const base = -(e.isBoss ? 3 : (e.isElite ? 2 : 1));
    const mantraEase = (S.run && S.run.mantraUntil && now() < S.run.mantraUntil) ? 20 : 0;
    const modK = Math.floor(num(e.karmaKill||0, 0));
    const delta = base + mantraEase + modK;
    const r = addKarma(delta);
    if (Math.random() < 0.18){
      const sign = delta>=0?'+':'';
      log(`<span class="muted">業</span>: ${sign}${delta}（${r.before}→${r.after}）`);
      dirtyLog = true;
    }
    // 章の印（根本のほどけ）
    if (e && e.isBoss && e.realmKey){ try{ storyBossSeal(e.realmKey); }catch(_){ } }
  }

  // ---- 儀礼（儀礼） ----
  function chance(p){ return Math.random() < p; }
  function openEvent(ev){
    if (!els.eventOverlay) return;
    ensureMikkyoFields();

    const r = S.run;
    const forceModal = !!(ev && ev.forceModal);
    try{
      const k = String(ev && ev.key || "");
      const isIntroStory = (ev && ev.kind === "章" && k.indexOf("realm_intro_") === 0);
      if (!isIntroStory) recordEventToLibrary(ev);
    }catch(_){ }

    // ✅ 自動巡礼中は「止めない」：儀礼は自動で処理して巡礼を継続（ただし forceModal は表示）
    if (r && r.auto && !forceModal){
      const choices = (ev && Array.isArray(ev.choices)) ? ev.choices : [];
      let pickIdx = 0;

      if (choices.length){
        const isSafe = (lab) => /見送|無視|閉じ|戻る|立ち去|やめる|省略|何もしない|見なかった/.test(String(lab||""));
        const safeIdx = choices.findIndex(c => isSafe(c && c.label));
        if (safeIdx >= 0){
          pickIdx = safeIdx;
        } else {
          // 灌頂など2択は「胎蔵（慈悲）」を優先して一旦決める（儀礼が繰り返し出るのを防ぐ）
          const taizoIdx = choices.findIndex(c => /胎蔵/.test(String(c && c.label || "")));
          pickIdx = (taizoIdx >= 0) ? taizoIdx : 0;
        }
      }

      const c = choices[pickIdx];
      try{
        if (c){
          if (typeof c.apply === "function") c.apply();
          else if (typeof c.effect === "function") c.effect();
        }
      }catch(_){}

      if (ev && ev.key){
        try{
          ensureMikkyoFields();
          S.hero.codex.events[ev.key] = 1;
        }catch(_){}
      }

      // 画面は止めず、記にだけ残す
      log(`<span class="good">儀礼</span>: ${ev && ev.title ? ev.title : '儀礼'}（自動処理）`);
      dirtyLog = true;

      // 次の魔がいない状態にならないように保険
      try{ ensureEnemy(); }catch(_){}
      save();
      dirtyHUD = true;
      return;
    }

    S.run._eventLock = now() + 200; // 連打封印（ms）
    if (S.run.active){
      S.run.active = false;
      S.run._resumeAfterEvent = 1;
    } else {
      S.run._resumeAfterEvent = 0;
    }
    els.eventTitle.textContent = ev.title || '—';
    els.eventBody.textContent = ev.body || '';
    els.eventFoot.textContent = ev.foot || '';
    els.eventChoices.innerHTML = '';
    (ev.choices||[]).forEach((c,idx)=>{
      const b = document.createElement('button');
      b.className = c.accent ? 'small accent' : 'small';
      b.textContent = c.label;
      b.onclick = ()=>{ chooseEvent(ev, idx); };
      els.eventChoices.appendChild(b);
    });
    els.eventOverlay.style.display = 'flex';
    dirtyHUD = true;
  }
  function closeEvent(){
    if (!els.eventOverlay) return;
    els.eventOverlay.style.display = 'none';
    // resume if needed
    if (S.run._resumeAfterEvent === 1 && !S.hero.dead){
      S.run.active = true;
      S.run.lastTick = now();
      ensureEnemy();
    }
    S.run._resumeAfterEvent = 0;
    save();
    dirtyHUD = true;
  }
  function chooseEvent(ev, idx){
    if (now() < num(S.run._eventLock,0)) return;
    const c = (ev.choices||[])[idx];
    try{ if (c){ if (c.apply) c.apply(); else if (c.effect) c.effect(); } }catch(_){ }
    if (ev && ev.key){
      ensureMikkyoFields();
      S.hero.codex.events[ev.key] = 1;
    }
    closeEvent();
  }

  function maybeTriggerEvent(){
    // 部屋進行で稀に発生。天魔部屋直前は避ける。
    const r = S.run;
    if (!r || S.hero.dead) return false;
    if (r.room % 10 === 0) return false;
    // 6〜9部屋に1回くらい（業の寄りが強いほど、儀礼が“濃く”なる）
    const karmaNow = clampKarma(S.hero.karma||0);
    const kNorm = clamp(karmaNow/108, -1, 1);
    const shift = Math.round(kNorm*2); // -2..2
    const biasStrength = Math.abs(shift)/2; // 0 / 0.5 / 1
    const pBase = clamp(0.06 + ((r.room % 9)===0 ? 0.08 : 0), 0, 0.20);
    const p = clamp(pBase + biasStrength*0.05, 0, 0.24);
    if (!chance(p)) return false;

    const biome = biomeForFloor(r.floor);
    const realmKey = biome.key;
    const goodBias = clamp((karmaNow + 108) / 216, 0, 1);

    const events = [];

    // 初回灌頂儀礼（未灌頂なら優先的に出す）
    try{
      ensureMikkyoFields();
      if (!(S.hero.mandala||"") && !(S.hero.codex.events && S.hero.codex.events.kanjo) && ((S.hero.satori||0) >= 12 || (S.run.floor||1) >= 12)){
        events.push({
          key:"kanjo",
          title:"灌頂：二曼荼羅",
          body:"師僧が砂曼荼羅を結ぶ。あなたは" + (biomeForFloor(S.run.floor).name) + "で『どちらの曼荼羅を生きるか』を問われた。",
          goodBias: 0.0,
          choices:[
            { label:"🔱 金剛界（調伏）", apply: () => { mandalaChoose("kongo"); S.hero.codex.events.kanjo = 1; } },
            { label:"🌸 胎蔵界（慈悲）", apply: () => { mandalaChoose("taizo"); S.hero.codex.events.kanjo = 1; } },
          ]
        });
      }
    }catch(_){ }

    // events list
    events.push({
      key:'ajikan',
      title:'阿字観（あじかん） — 「阿」の観想',
      body:'中心に「阿字」を観じ、生成と消滅を同一視する観法。',
      foot:'',
      choices:[
        { label:'静坐して観想する（安全）', accent:true, apply:()=>{ S.hero.satori += 6; addKarma(1); log('<span class="good">阿字観</span>: 悟りが少し澄みました'); spawnMantraFx('अ'); } },
        { label:'急いで通過する', apply:()=>{ log('静かに通り過ぎました。'); } },
      ]
    });

    

    events.push({
      key:'shakyo',
      title:'写経の間 — 反復する線',
      body:'文字の反復は「乱れを固定化」する。\n時間を費やせば、悟り（理解）を得るが進行は遅れる。',
      foot:'',
      choices:[
        { label:'丁寧に写す（悟り+）', accent:true, apply:()=>{ const gain=10; S.hero.satori += gain; addKarma(2); log(`<span class="good">写経</span>: 悟り +${fmt(gain)} / 業 +2`); spawnMantraFx('ॐ'); } },
        { label:'急いで写す（小）', apply:()=>{ S.hero.satori += 4; addKarma(1); log('<span class="good">写経</span>: 悟り +4'); } },
        { label:'手を合わせて出る', apply:()=>{ addKarma(1); log('合掌し、静かに場を離れました。'); } },
      ]
    });

    events.push({
      key:'kekkai',
      title:'結界 — 境界線の生成',
      body:'ここで結界を張れば、次の入室盾が厚くなる。',
      foot:'',
      choices:[
        { label:'結界を張る（徳消費）', accent:true, apply:()=>{ const c=240; if (S.hero.gold<c){ log('<span class="warn">功徳が足りません</span>'); return; } S.hero.gold-=c; S.run.entryShield = 2.4; S.run.entryShieldDR = 0.65; addKarma(1); log(`<span class="good">結界</span>: 次の入室盾を強化 <span class="gold">(-${fmt(c)}功徳)</span>`); spawnMantraFx('ॐ'); } },
        { label:'観察だけして進む', apply:()=>{ S.hero.satori += 2; log('ひと息観察し、そのまま歩を進めました。'); } },
      ]
    });

    // 領域（六道）に応じた儀礼を少し混ぜる
    if (realmKey === 'hungry'){
      events.push({
        key:'segaki',
        realmKey:'hungry',
        goodBias:0.66,
        title:'施餓鬼 — 欠乏への応答',
        body:'餓鬼の欠乏は「埋めても埋まらない」構造として表象される。\n施しは業を整えるが、資源を失う。',
        foot:'（【渇】渇愛印の気配が濃い）',
        choices:[
          { label:'布施する（徳→業/悟り）', accent:true, apply:()=>{ const c=Math.min(S.hero.gold, 380); if (c<=0){ log('<span class="warn">功徳が足りません</span>'); return; } S.hero.gold-=c; S.hero.satori += Math.max(1, Math.floor(Math.sqrt(c)*0.55)); addKarma(3); log(`<span class="good">布施</span>: -${fmt(c)}功徳 / 業 +3 / 悟り増`); spawnMantraFx('渇'); } },
          { label:'見なかったことにする', apply:()=>{ addKarma(-2); log('<span class="warn">無視</span>: 業 -2'); } },
        ]
      });

      events.push({
        key:'hungry_mui',
        realmKey:'hungry',
        goodBias:0.62,
        title:'無畏施 — 恐れを渡す',
        body:'飢えは腹だけに宿らない。\n恐れもまた欠乏の相だ。\n恐れを渡すか、蓄えるか。',
        foot:'',
        choices:[
          { label:'無畏施する（徳- / 盾+ / 業+）', accent:true, apply:()=>{ const c=260; if (S.hero.gold<c){ log('<span class="warn">功徳が足りません</span>'); return; } S.hero.gold-=c; S.run.entryShield = Math.max(num(S.run.entryShield,0), 2.2); S.run.entryShieldDR = Math.max(num(S.run.entryShieldDR,0), 0.60); S.hero.satori += 5; addKarma(3); log(`<span class="good">無畏施</span>: -${fmt(c)}功徳 / 盾強化 / 業 +3`); spawnMantraFx('施'); } },
          { label:'蓄える（功徳+ / 業-）', apply:()=>{ const g=Math.floor(200+Math.random()*260); S.hero.gold+=g; addKarma(-2); log(`<span class="gold">功徳</span> +${fmt(g)} / <span class="warn">業</span> -2`); } },
        ]
      });

      events.push({
        key:'hungry_kagami',
        realmKey:'hungry',
        goodBias:0.60,
        title:'空腹の鏡 — 穴を照らす',
        body:'鏡には腹ではなく、穴が映る。\n穴を埋めるか、穴を照らして歩くか。',
        foot:'',
        choices:[
          { label:'穴を照らす（悟り+ / 業+）', accent:true, apply:()=>{ S.hero.satori += 12; addKarma(2); log('<span class="good">照</span>: 欠乏を見失わずに済みました'); spawnMantraFx('渇'); } },
          { label:'穴を埋める（功徳++ / 業-）', apply:()=>{ const g=Math.floor(360+Math.random()*520); S.hero.gold+=g; addKarma(-3); log(`<span class="gold">功徳</span> +${fmt(g)} / <span class="warn">業</span> -3`); } },
        ]
      });
    }
    if (realmKey === 'hell'){
      events.push({
        key:'kasho',
        realmKey:'hell',
        goodBias:0.58,
        title:'焦熱の法門 — 苦を写す',
        body:'熱は外から来るのではない。\n反応として生まれ、業として残る。\n苦を避けず、苦の形を写して進め。',
        foot:'（【火】焦熱印の気配が濃い）',
        choices:[
          { label:'息を数える（忍辱）', accent:true, apply:()=>{ S.run.entryShield = Math.max(num(S.run.entryShield,0), 1.8); S.run.entryShieldDR = Math.max(num(S.run.entryShieldDR,0), 0.55); S.hero.satori += 5; addKarma(2); log('<span class="good">忍辱</span>: 次の入室盾が厚くなりました'); spawnMantraFx('火'); } },
          { label:'怒りに呑まれて急ぐ', apply:()=>{ addKarma(-3); log('<span class="warn">瞋</span>: 業 -3'); } },
        ]
      });

      events.push({
        key:'hell_ingou',
        realmKey:'hell',
        goodBias:0.54,
        title:'因果の火簡 — 因を引き受ける',
        body:'焼けた木札に、あなたの「因」が刻まれている。\n受け取るか、外に置くか。',
        foot:'',
        choices:[
          { label:'因を受け取る（功徳- / 悟り++ / 業+）', accent:true, apply:()=>{ const c=Math.min(S.hero.gold, 220); if (c>0) S.hero.gold-=c; S.hero.satori+=10; addKarma(3); log(`<span class="good">因果</span>: 受け取った <span class="gold">(-${fmt(c)}功徳)</span>`); spawnMantraFx('因'); } },
          { label:'責を外に置く（功徳+ / 業-）', apply:()=>{ const g=Math.floor(240+Math.random()*320); S.hero.gold+=g; addKarma(-3); log(`<span class="gold">功徳</span> +${fmt(g)} / <span class="warn">業</span> -3`); } },
        ]
      });

      events.push({
        key:'hell_reisui',
        realmKey:'hell',
        goodBias:0.56,
        title:'冷水の井 — 熱悩を冷ます',
        body:'井の底で、黒い水が静かに光る。\n熱悩を冷ますか、熱を抱えたまま歩くか。',
        foot:'',
        choices:[
          { label:'冷ます（盾+ / 業+）', accent:true, apply:()=>{ S.run.entryShield = Math.max(num(S.run.entryShield,0), 2.4); S.run.entryShieldDR = Math.max(num(S.run.entryShieldDR,0), 0.65); S.hero.satori += 6; addKarma(2); log('<span class="good">清涼</span>: 結界が整いました'); spawnMantraFx('冷'); } },
          { label:'熱を抱く（功徳+ / 業-）', apply:()=>{ const g=Math.floor(260+Math.random()*360); S.hero.gold+=g; addKarma(-2); log(`<span class="gold">功徳</span> +${fmt(g)} / <span class="warn">業</span> -2`); spawnMantraFx('火'); } },
        ]
      });
    }
    if (realmKey === 'animal'){
      events.push({
        key:'mondo',
        realmKey:'animal',
        goodBias:0.62,
        title:'問答 — 霧の中の一問',
        body:'問いは答えのためにあるのではない。\n霧の中で「問いを保つ」ことが、次の一歩になる。',
        foot:'（【霧】霧明印の気配が濃い）',
        choices:[
          { label:'問いを一つ残す（悟り+）', accent:true, apply:()=>{ S.hero.satori += 9; addKarma(2); log('<span class="good">問</span>: 悟りが増えました'); spawnMantraFx('霧'); } },
          { label:'考えずに進む', apply:()=>{ log('歩を進めました。'); } },
        ]
      });

      events.push({
        key:'animal_kansatsu',
        realmKey:'animal',
        goodBias:0.58,
        title:'観察 — 歩幅を知る',
        body:'霧は消えない。\nだが、歩幅は変えられる。\nいま、足元を確かめるか。',
        foot:'',
        choices:[
          { label:'歩幅を整える（盾+ / 悟り+ / 業+）', accent:true, apply:()=>{ S.run.entryShield = Math.max(num(S.run.entryShield,0), 2.0); S.run.entryShieldDR = Math.max(num(S.run.entryShieldDR,0), 0.58); S.hero.satori += 7; addKarma(2); log('<span class="good">観</span>: 身が整いました'); spawnMantraFx('観'); } },
          { label:'勢いで踏み込む（功徳+ / 業-）', apply:()=>{ const g=Math.floor(220+Math.random()*320); S.hero.gold+=g; addKarma(-2); log(`<span class="gold">功徳</span> +${fmt(g)} / <span class="warn">業</span> -2`); } },
        ]
      });

      events.push({
        key:'animal_koukan',
        realmKey:'animal',
        goodBias:0.55,
        title:'交換 — 言葉なき取引',
        body:'霧の市で、誰も言葉を使わない。\n功徳と修行は交換できるのか。',
        foot:'',
        choices:[
          { label:'功徳を行に換える（徳- / 行++ / 業+）', accent:true, apply:()=>{ const c=260; if (S.hero.gold<c){ log('<span class="warn">功徳が足りません</span>'); return; } S.hero.gold-=c; const xp = Math.floor(240 + Math.random()*260); grantExp(xp); addKarma(2); log(`<span class="good">交換</span>: -${fmt(c)}功徳 / 行 +${fmt(xp)} / 業 +2`); spawnMantraFx('霧'); } },
          { label:'換えない（悟り+）', apply:()=>{ S.hero.satori += 6; addKarma(1); log('換えず、歩を進めました。'); } },
        ]
      });
    }
    if (realmKey === 'asura'){
      events.push({
        key:'shikan',
        realmKey:'asura',
        goodBias:0.57,
        title:'止観 — 刃を内へ戻す',
        body:'争いの刃は、外に向けるほど増える。\nいま一度、刃を内へ戻せ。',
        foot:'（【争】争鏡印の気配が濃い）',
        choices:[
          { label:'止観する（業+ / 盾+）', accent:true, apply:()=>{ S.run.entryShield = Math.max(num(S.run.entryShield,0), 2.0); S.run.entryShieldDR = Math.max(num(S.run.entryShieldDR,0), 0.60); S.hero.satori += 6; addKarma(3); log('<span class="good">止観</span>: 身が整いました'); spawnMantraFx('争'); } },
          { label:'勝ちを求める（徳↑）', apply:()=>{ const g = Math.floor(180 + Math.random()*220); S.hero.gold += g; addKarma(-2); log(`<span class="gold">功徳</span> +${fmt(g)} / <span class="warn">業</span> -2`); } },
        ]
      });

      events.push({
        key:'asura_katou',
        realmKey:'asura',
        goodBias:0.56,
        title:'葛藤の札 — どちらの刃で歩くか',
        body:'勝つための刃と、負けないための盾。\n葛藤は札となって胸に貼り付く。',
        foot:'',
        choices:[
          { label:'盾を選ぶ（盾+ / 業+）', accent:true, apply:()=>{ S.run.entryShield = Math.max(num(S.run.entryShield,0), 2.6); S.run.entryShieldDR = Math.max(num(S.run.entryShieldDR,0), 0.66); S.hero.satori += 5; addKarma(2); log('<span class="good">忍</span>: 盾が厚くなりました'); spawnMantraFx('忍'); } },
          { label:'刃を選ぶ（功徳++ / 業-）', apply:()=>{ const g=Math.floor(320+Math.random()*420); S.hero.gold += g; addKarma(-3); log(`<span class="gold">功徳</span> +${fmt(g)} / <span class="warn">業</span> -3`); spawnMantraFx('争'); } },
        ]
      });

      events.push({
        key:'asura_hannya',
        realmKey:'asura',
        goodBias:0.60,
        title:'般若の影 — 争いを透かす',
        body:'影が言う。「相手が敵なのではない。敵の像が敵だ。」\n影に礼をするか、叩き切るか。',
        foot:'',
        choices:[
          { label:'礼をする（悟り++ / 業+）', accent:true, apply:()=>{ S.hero.satori += 13; addKarma(3); log('<span class="good">般若</span>: 像が薄くなりました'); spawnMantraFx('般'); } },
          { label:'叩き切る（功徳+ / 業-）', apply:()=>{ const g=Math.floor(240+Math.random()*320); S.hero.gold += g; addKarma(-2); log(`<span class="gold">功徳</span> +${fmt(g)} / <span class="warn">業</span> -2`); } },
        ]
      });
    }
    if (realmKey === 'human'){
      events.push({
        key:'seigan',
        realmKey:'human',
        goodBias:0.63,
        title:'誓願 — 無執着の稽古',
        body:'持つことは守りになる。\nだが持ちすぎれば足枷になる。\n「残す理由」と「手放す理由」を書き分けよ。',
        foot:'（自動布施は「残す閾」を決める誓いに相当する）',
        choices:[
          { label:'書き留める（悟り+）', accent:true, apply:()=>{ S.hero.satori += 10; addKarma(3); log('<span class="good">誓願</span>: 迷いが減りました'); spawnMantraFx('択'); } },
          { label:'読み捨てる', apply:()=>{ addKarma(1); log('そっと手放しました。'); } },
        ]
      });

      events.push({
        key:'human_en',
        realmKey:'human',
        goodBias:0.60,
        title:'縁の修復 — 切断の前に',
        body:'縁は見えない糸だ。\n切ってしまえば軽い。\nだが結び直す手は、重い。',
        foot:'',
        choices:[
          { label:'結び直す（徳- / 悟り+ / 業+）', accent:true, apply:()=>{ const c=240; if (S.hero.gold<c){ log('<span class="warn">功徳が足りません</span>'); return; } S.hero.gold-=c; S.hero.satori += 8; addKarma(3); log(`<span class="good">縁</span>: -${fmt(c)}功徳 / 悟り +8 / 業 +3`); spawnMantraFx('縁'); } },
          { label:'断つ（功徳+ / 業-）', apply:()=>{ const g=Math.floor(280+Math.random()*360); S.hero.gold+=g; addKarma(-3); log(`<span class="gold">功徳</span> +${fmt(g)} / <span class="warn">業</span> -3`); } },
        ]
      });

      events.push({
        key:'human_senkaku',
        realmKey:'human',
        goodBias:0.58,
        title:'選択の橋 — 置く/持つ',
        body:'橋の中ほどで、荷が急に重くなる。\nいま置くか、持つか。\n選ぶことが、世界を切り分ける。',
        foot:'',
        choices:[
          { label:'置く（悟り++ / 業+）', accent:true, apply:()=>{ S.hero.satori += 14; addKarma(2); log('<span class="good">択</span>: 身軽になりました'); spawnMantraFx('択'); } },
          { label:'持つ（功徳++ / 業-）', apply:()=>{ const g=Math.floor(360+Math.random()*520); S.hero.gold+=g; addKarma(-4); log(`<span class="gold">功徳</span> +${fmt(g)} / <span class="warn">業</span> -4`); } },
        ]
      });
    }
    if (realmKey === 'deva'){
      events.push({
        key:'gosui',
        realmKey:'deva',
        goodBias:0.52,
        title:'五衰の兆 — 無常の影',
        body:'満ちた瞬間、欠け始める。\n光は永遠を装うが、衰えは必ず来る。\nいま「無常」を見るか。',
        foot:'（【衰】五衰印の気配が濃い）',
        choices:[
          { label:'無常観（悟り++ / 業++）', accent:true, apply:()=>{ S.hero.satori += 14; addKarma(4); log('<span class="good">無常</span>: 光が影へと移りました'); spawnMantraFx('衰'); } },
          { label:'栄光に執着（徳++ / 業-）', apply:()=>{ const g = Math.floor(320 + Math.random()*420); S.hero.gold += g; addKarma(-4); log(`<span class="gold">功徳</span> +${fmt(g)} / <span class="warn">業</span> -4`); } },
        ]
      });

      events.push({
        key:'deva_hossin',
        realmKey:'deva',
        goodBias:0.62,
        title:'発心 — 光を捨てて灯す',
        body:'光は外にあると思うから眩しい。\n内に灯せば、眩しさは誓いになる。\nいま発心するか。',
        foot:'',
        choices:[
          { label:'供物を投じる（徳- / 悟り++ / 業+）', accent:true, apply:()=>{ const c=520; if (S.hero.gold<c){ log('<span class="warn">功徳が足りません</span>'); return; } S.hero.gold-=c; S.hero.satori += 20; addKarma(5); log(`<span class="good">発心</span>: -${fmt(c)}功徳 / 悟り +20 / 業 +5`); spawnMantraFx('発'); } },
          { label:'光に寄る（功徳+ / 業-）', apply:()=>{ const g=Math.floor(260+Math.random()*360); S.hero.gold+=g; addKarma(-3); log(`<span class="gold">功徳</span> +${fmt(g)} / <span class="warn">業</span> -3`); } },
        ]
      });

      events.push({
        key:'deva_en',
        realmKey:'deva',
        goodBias:0.48,
        title:'天の宴 — 放逸の香',
        body:'甘い香が漂う。\n放逸は毒ではない。\nただ、歩みを遅くする。',
        foot:'',
        choices:[
          { label:'席を離れる（悟り+ / 業+）', accent:true, apply:()=>{ S.hero.satori += 10; addKarma(3); log('<span class="good">離</span>: 香に呑まれずに済みました'); spawnMantraFx('衰'); } },
          { label:'杯を取る（徳+++ / 業---）', apply:()=>{ const g=Math.floor(520+Math.random()*760); S.hero.gold+=g; addKarma(-6); log(`<span class="gold">功徳</span> +${fmt(g)} / <span class="warn">業</span> -6`); spawnMantraFx('宴'); } },
        ]
      });
    }


    // 業の寄り（六道）× 傾き（善悪）で重み付けして選ぶ
    const wOf = (ev)=>{
      let w = num(ev.w, 1);
      if (ev && ev.key === "kanjo") w *= 999; // 灌頂は見逃さない
      const gb = clamp((ev.goodBias==null ? 0.5 : ev.goodBias), 0, 1);
      const align = 1 - Math.abs(gb - goodBias); // 1=一致, 0=真逆
      w *= (0.55 + 1.25*align);
      if (ev.realmKey && ev.realmKey === realmKey) w *= (1 + biasStrength*2.4);
      return Math.max(0.01, w);
    };
    const pool = events.map(ev => ({...ev, _w:wOf(ev)}));
    const pick = pickWeighted(pool, "_w") || pool[0];

    openEvent(pick);
    return true;
  }


  function showStoryInCodex(realmKey){
    try{
      if (!realmKey) return;
      ensureStoryFields();
      const st = STORY[realmKey];
      if (!st) return;

      const intros = (S.hero.codex.story && S.hero.codex.story.intros) ? S.hero.codex.story.intros : {};
      const seals  = (S.hero.codex.story && S.hero.codex.story.seals)  ? S.hero.codex.story.seals  : {};
      const hasIntro = !!intros[realmKey];
      const hasSeal  = !!seals[realmKey];

      const title = st.chap || (REALM_LABEL[realmKey]||realmKey);
      const tag = st.tagline ? ("— " + st.tagline) : "";
      const pro = hasIntro ? String(st.prologue||"") : "未記録（初めてこの章に入ると記されます）";
      const epi = hasSeal ? (("印: " + String(st.seal||"—")) + (st.epilogue ? ("\n" + String(st.epilogue)) : "")) : "未記録（根本を倒すと記されます）";

      const txt = "【序】\n" + pro + "\n\n【印】\n" + epi;

      const box = document.getElementById("codexStoryView");
      const tEl = document.getElementById("codexStoryTitle");
      const bEl = document.getElementById("codexStoryText");
      if (tEl) tEl.textContent = title + (tag ? (" " + tag) : "");
      if (bEl) bEl.textContent = txt;

      if (box){
        box.style.display = '';
        try{ box.scrollIntoView({behavior:'smooth', block:'start'}); }catch(_){}
      }
    }catch(_){}
  }

  function openCodex(){
    if (!els.codexOverlay) return;
    ensureStoryFields();
    ensureLibrary();
    const c = S.hero.codex;
    const realms = REALM_ORDER.filter(k => (c.realms||{})[k]);
    const realmTxt = realms.length ? realms.map(k=>REALM_LABEL[k]).join(' / ') : '未記録';

    const story = c.story || {};
    const intros = story.intros || {};
    const seals = story.seals || {};
    const storyRows = REALM_ORDER.map(k=>{
      const st = STORY[k] || {};
      const a = intros[k] ? '序' : '—';
      const b = seals[k] ? '印' : '—';
      const tag = st.tagline || '';
      return `<div style="display:flex; gap:10px; align-items:baseline; padding:4px 0; border-bottom:1px solid rgba(255,255,255,0.06);">
        <span class="pill">${a}</span>
        <span class="pill">${b}</span>
        <span style="min-width:64px">${escapeHtml(REALM_LABEL[k]||k)}</span>
        <span class="muted" style="font-size:11px">${escapeHtml(tag)}</span>
        <button class="small" data-story="${k}" style="margin-left:auto;">読む</button>
      </div>`;
    }).join('');

    const lastVerse = story.last || '';
    const lastRealmLabel = story.lastRealm ? (REALM_LABEL[story.lastRealm]||story.lastRealm) : '';

    // 文庫（物語/儀礼/偈/重要ログ）
    const lib = c.library || {};
    const docs = lib.docs || {};
    const order = Array.isArray(lib.order) ? lib.order : [];
    const fmtTS = (ts)=>{
      try{
        const d = new Date(num(ts, 0));
        if (!isFinite(d.getTime())) return '';
        return d.toLocaleString("ja-JP",{month:"2-digit",day:"2-digit",hour:"2-digit",minute:"2-digit"});
      }catch(_){ return ''; }
    };
    const libItems = order.map(k=>{
      const d = docs[k]; if (!d) return null;
      const kind = String(d.kind||'').trim();
      const titleRaw = String(d.title||'—').trim();
      const ts = num(d.ts, 0);
      const time = fmtTS(ts);
      const day = (()=>{ try{ const dd=new Date(ts); if(!isFinite(dd.getTime())) return ''; return dd.toLocaleDateString("ja-JP",{month:"2-digit",day:"2-digit"}); }catch(_){ return ''; } })();
      const realm = d.realmKey ? (REALM_LABEL[d.realmKey]||d.realmKey) : '';
      const bodyRaw = String(d.body||'');
      const footRaw = String(d.foot||'');
      const bodyHtml = escapeHtml(bodyRaw).replace(/\n/g,'<br>');
      const footHtml = escapeHtml(footRaw).replace(/\n/g,'<br>');
      const search = (kind+' '+titleRaw+' '+realm+' '+bodyRaw+' '+footRaw).toLowerCase();
      return { id:k, ts, day, time, kind, title:(titleRaw||'—'), realm, bodyHtml, footHtml, search };
    }).filter(Boolean);

    els.codexBody.innerHTML = `
      <div class="codexGrid">
        <div class="codexCard"><div class="k">六道の記録</div><div class="v">${escapeHtml(realmTxt)}</div><div class="p">階層により巡回。業により出現“寄り”が生じます。</div></div>
        <div class="codexCard"><div class="k">戦果</div><div class="v">撃破 ${fmt(c.kills||0)} / 根本 ${fmt(c.bosses||0)} / 重煩 ${fmt(c.elites||0)} / 六印欠片 ${fmt(c.uniques||0)}</div><div class="p">最大到達層: 第${fmt(c.maxFloor||1)}層</div></div>
        <div class="codexCard"><div class="k">修行</div><div class="v">真言 ${fmt(c.mantras||0)} / 悟り ${fmt(S.hero.satori||0)}</div><div class="p">真言は短時間加持（火力/報酬/苦減）。</div></div>
        <div class="codexCard"><div class="k">儀礼記録</div><div class="v">${fmt(Object.keys(c.events||{}).length)} 件</div><div class="p">阿字観・写経・結界など。</div></div>
        <div class="codexCard"><div class="k">六印（欠片）</div>
          <div class="v">${fmt(fragmentCount())}/6</div>
          <div class="p">${escapeHtml((()=>{ const fr=(story.fragments||{}); return REALM_ORDER.map(k=>`【${(STORY[k]||{}).glyph||"印"}】${(fr[k]||0)>0?"✓":"—"}`).join(" "); })())}</div>
          <div class="p">${escapeHtml((()=>{ const ed=String(story.ending||""); if(ed==="kongo") return "結願: 金剛界（調伏）"; if(ed==="taizo") return "結願: 胎蔵界（慈悲）"; if(hasAllSixFragments()) return "結願: 未（選択可）"; return "結願: —"; })())}</div>
          ${hasAllSixFragments() && String(story.ending||"")!=="kongo" && String(story.ending||"")!=="taizo" ? `<button id="btnKetsugan" class="accent" style="margin-top:6px;">結願を結ぶ</button>` : ``}
        </div>

      </div>

      <div class="codexGrid" style="margin-top:10px;">
        <div class="codexCard" style="grid-column:1/-1;">
          <div class="k">曼荼羅帳（章）</div>
          <div class="p">序=界門の記録 / 印=界の根本が一度ほどけた証。章は六道すべてに存在します。</div>
          <div style="margin-top:6px;">${storyRows || '<span class="muted">—</span>'}</div>
        </div>
        <div class="codexCard" style="grid-column:1/-1;">
          <div class="k">最終偈</div>
          <div class="v">${escapeHtml(lastVerse || '—')}</div>
          <div class="p">${escapeHtml(lastRealmLabel ? ('記された界: ' + lastRealmLabel) : '')}</div>
        </div>
      </div>

      <div class="codexGrid" style="margin-top:10px;">
        <div class="codexCard" style="grid-column:1/-1; display:none;" id="codexStoryView">
          <div class="k">章の本文</div>
          <div class="v" id="codexStoryTitle">—</div>
          <div class="p" id="codexStoryText">—</div>
        </div>
        <div class="codexCard" style="grid-column:1/-1;">
          <div class="k">文庫（出会った文章）</div>
          <div class="p">章・儀礼・偈・重要な出来事などを保存。検索・絞り込み・展開ができます。</div>

          <div class="codexCtrlRow">
            <input id="codexLibSearch" type="search" placeholder="検索（題名/本文）" autocomplete="off" />
            <select id="codexLibKind" aria-label="種別">
              <option value="all">すべて</option>
            </select>
            <select id="codexLibSort" aria-label="並び替え">
              <option value="new">新しい順</option>
              <option value="old">古い順</option>
            </select>
            <span class="count" id="codexLibCount">—</span>
          </div>

          <div class="libList" id="codexLibList"><div class="muted" style="padding:10px;">—</div></div>
          <div class="libActions"><button class="small" id="codexLibMore" type="button">もっと見る</button></div>
        </div>
      </div>
`;

    // 章本文を表示（読む）
    try{
      els.codexBody.querySelectorAll('button[data-story]').forEach(btn=>{
        btn.onclick = ()=>{ try{ showStoryInCodex(btn.dataset.story); }catch(_){} };
      });
    }catch(_){ }

    // 文庫（検索/絞り込み）
    try{ mountCodexLibrary(libItems); }catch(_){ }

    // 六印が揃っていれば「結願」を選べる
    try{
      const btn = document.getElementById("btnKetsugan");
      if (btn){
        btn.onclick = ()=>{
          try{ closeCodex(); }catch(_){}
          try{ openEndingChoice(); }catch(_){}
          save(); dirtyHUD = true;
        };
      }
    }catch(_){}

    els.codexOverlay.style.display = 'flex';
  }
  function closeCodex(){

    if (!els.codexOverlay) return;
    els.codexOverlay.style.display = 'none';
    save();
    dirtyHUD = true;
  }

  // --------------------
  // Codex Library UI
  // --------------------
  const codexLibState = { q:"", kind:"all", sort:"new", limit:60, openId:"" };

  function mountCodexLibrary(items){
    try{
      const elList = document.getElementById("codexLibList");
      const elQ    = document.getElementById("codexLibSearch");
      const elKind = document.getElementById("codexLibKind");
      const elSort = document.getElementById("codexLibSort");
      const elCnt  = document.getElementById("codexLibCount");
      const elMore = document.getElementById("codexLibMore");
      if (!elList || !elQ || !elKind || !elSort || !elCnt || !elMore) return;

      // 種別候補
      const kinds = Array.from(new Set((items||[]).map(x=>x && x.kind).filter(Boolean)));
      const pri = ["章","儀礼","偈","進行","戦闘","死亡","復活","宝函","自動布施","自動","報酬","システム","その他"];
      kinds.sort((a,b)=>{
        const ia = pri.indexOf(a); const ib = pri.indexOf(b);
        const pa = (ia<0?999:ia), pb = (ib<0?999:ib);
        if (pa!==pb) return pa-pb;
        try{ return a.localeCompare(b,'ja'); }catch(_){ return String(a).localeCompare(String(b)); }
      });

      const current = kinds.includes(codexLibState.kind) ? codexLibState.kind : "all";
      elKind.innerHTML = `<option value="all">すべて</option>` + kinds.map(k=>`<option value="${escapeHtml(k)}">${escapeHtml(k)}</option>`).join("");
      elKind.value = current;

      elSort.value = (codexLibState.sort==="old") ? "old" : "new";
      elQ.value = codexLibState.q || "";

      elMore.onclick = ()=>{
        codexLibState.limit = clamp(int0(codexLibState.limit, 60) + 60, 20, 420);
        renderCodexLibrary(items);
      };
      elQ.oninput = ()=>{
        codexLibState.q = String(elQ.value||"");
        codexLibState.limit = 60;
        renderCodexLibrary(items);
      };
      elKind.onchange = ()=>{
        codexLibState.kind = String(elKind.value||"all");
        codexLibState.limit = 60;
        codexLibState.openId = "";
        renderCodexLibrary(items);
      };
      elSort.onchange = ()=>{
        codexLibState.sort = (String(elSort.value)==="old") ? "old" : "new";
        codexLibState.limit = 60;
        codexLibState.openId = "";
        renderCodexLibrary(items);
      };

      renderCodexLibrary(items);
    }catch(_){}
  }

  function renderCodexLibrary(items){
    const elList = document.getElementById("codexLibList");
    const elCnt  = document.getElementById("codexLibCount");
    const elMore = document.getElementById("codexLibMore");
    if (!elList || !elCnt || !elMore) return;

    let arr = Array.isArray(items) ? items.slice() : [];
    const kind = String(codexLibState.kind||"all");
    if (kind !== "all") arr = arr.filter(it => it && it.kind === kind);

    const q = String(codexLibState.q||"").trim().toLowerCase();
    if (q) arr = arr.filter(it => String(it.search||"").includes(q));

    arr.sort((a,b)=>{
      const at = num(a && a.ts, 0), bt = num(b && b.ts, 0);
      return (codexLibState.sort==="old") ? (at-bt) : (bt-at);
    });

    const total = arr.length;
    const limit = clamp(int0(codexLibState.limit, 60), 20, 420);
    const shown = arr.slice(0, limit);

    let html = "";
    let lastDay = "";
    for (const it of shown){
      if (!it) continue;
      const day = String(it.day||"");
      if (day && day !== lastDay){
        html += `<div class="libDay">${escapeHtml(day)}</div>`;
        lastDay = day;
      }
      const pill = it.kind ? `<span class="pill">${escapeHtml(it.kind)}</span>` : "";
      const metaParts = [];
      if (it.realm) metaParts.push(it.realm);
      if (it.time) metaParts.push(it.time);
      const meta = metaParts.join(" / ");
      const open = (codexLibState.openId === it.id);
      html += `<div class="libItem" data-id="${escapeHtml(it.id)}">
        <button class="libHead" type="button" data-open="${escapeHtml(it.id)}">
          ${pill}
          <span class="libTitle">${escapeHtml(it.title||"—")}</span>
          <span class="libMeta">${escapeHtml(meta)}</span>
        </button>
        <div class="libBody" ${open ? "" : "hidden"}>
          <div class="libText">${it.bodyHtml || '<span class="muted">—</span>'}</div>
          ${it.footHtml ? `<div class="libFoot">${it.footHtml}</div>` : ``}
        </div>
      </div>`;
    }
    if (!html) html = `<div class="muted" style="padding:10px;">該当なし</div>`;
    elList.innerHTML = html;

    try{
      elList.querySelectorAll(".libHead").forEach(btn=>{
        btn.onclick = ()=>{
          const id = String(btn.dataset.open||"");
          codexLibState.openId = (codexLibState.openId === id) ? "" : id;
          renderCodexLibrary(items);
        };
      });
    }catch(_){}

    elCnt.textContent = `${fmt(total)}件（表示 ${fmt(Math.min(limit,total))}件）`;
    elMore.style.display = (total > limit) ? "inline-flex" : "none";
  }

  // --------------------
  // Events
  // --------------------
  els.btnExplore.addEventListener("click", () => {
    if (S.hero.dead) { log("調伏に至らず。復活の儀を行ってください。"); dirtyHUD=true; dirtyLog=true; return; }
    if (S.run.active) return;
    // v58: 初回開始時に名前を設定できる
    ensureHeroName();
    startExplore();
  });
  els.btnPause.addEventListener("click", () => pauseExplore());

if (els.btnChant) els.btnChant.addEventListener('click', () => castMantra());
if (els.btnCodex) els.btnCodex.addEventListener('click', () => openCodex());
if (els.btnCodexClose) els.btnCodexClose.addEventListener('click', () => closeCodex());
if (els.codexOverlay) els.codexOverlay.addEventListener('click', (ev)=>{ if (ev.target === els.codexOverlay) closeCodex(); });

if (els.btnEventClose) els.btnEventClose.addEventListener('click', () => closeEvent());
if (els.eventOverlay) els.eventOverlay.addEventListener('click', (ev)=>{ if (ev.target === els.eventOverlay) closeEvent(); });



// 鍵操作
window.addEventListener('keydown', (ev)=>{
  if (ev.key === 'm' || ev.key === 'M'){ if (els.btnChant) castMantra(); }
  if (ev.key === 'c' || ev.key === 'C'){ if (els.codexOverlay && els.codexOverlay.style.display==='flex') closeCodex(); else openCodex(); }
});

  // Log auto-scroll pinning: if user scrolls up, stop force-scrolling
  if (els.log){
    logPinned = true;
    els.log.addEventListener('scroll', ()=>{ logPinned = isLogPinned(els.log); }, {passive:true});
    els.log.addEventListener('wheel', ()=>{ logPinned = isLogPinned(els.log); }, {passive:true});
    els.log.addEventListener('touchstart', ()=>{ logPinned = isLogPinned(els.log); }, {passive:true});
  }


  if (els.btnBack) els.btnBack.addEventListener("click", () => prevRoom());
  if (els.btnNext) els.btnNext.addEventListener("click", () => nextRoom());
  if (els.tabs) els.tabs.addEventListener("click", (ev) => {
    const b = ev.target.closest("button[data-tab]");
    if (!b) return;
    S.ui = S.ui ?? { tab:"all" };
    S.ui.tab = b.dataset.tab || "all";
    save();
    dirtyInv = true;
    renderInventory();
  });

  els.btnSave.addEventListener("click", () => { save(); log("手動記録しました。"); dirtyLog=true; });
  els.btnReset.addEventListener("click", () => { if (confirm("全記録を輪廻します。よろしいですか？")) hardReset(); });

  if (els.lockWeapon) els.lockWeapon.addEventListener('click', () => toggleEquipLock('weapon'));
  if (els.lockArmor) els.lockArmor.addEventListener('click', () => toggleEquipLock('armor'));
  if (els.lockAcc) els.lockAcc.addEventListener('click', () => toggleEquipLock('accessory'));

    els.speedSel.addEventListener("change", () => {
    const v = Number(els.speedSel.value);
    const cur = Number.isFinite(S.run.speed) ? Number(S.run.speed) : 1;

    // Gate MAX until all six fragments are collected.
    if (v >= SPEED_MAX_LABEL && !isMaxSpeedUnlocked()){
      const fallback = Math.max(...SPEED_ALLOWED.filter(x => x < SPEED_MAX_LABEL));
      S.run.speed = fallback;
      els.speedSel.value = String(fallback);
      try{
        const n = Math.min(6, Math.max(0, fragmentCount()));
        log(`<span class="warn">迅行MAX</span>: 六印の欠片を6つ揃えると解放（現在 ${n}/6）`);
        dirtyLog = true;
      }catch(_){}
      // Keep the dropdown label in sync
      try{ syncSpeedSelUnlock(); }catch(_){}
    } else {
      S.run.speed = v;
    }

    if (!S.ui) S.ui = {};
    S.ui._userTouchedSpeed = 1;
    save();
    dirtyHUD = true;
  });
  els.autoSel.addEventListener("change", () => { S.run.auto = els.autoSel.value === "1"; save(); dirtyHUD=true; });
  if (els.fxSel){
    els.fxSel.addEventListener("change", () => {
      S.ui = S.ui ?? { tab:"all", preview:null, fx:1 };
      S.ui.fx = (els.fxSel.value === "0") ? 0 : 1;
      save();
      dirtyHUD = true;
      try { if (typeof BFX !== "undefined" && BFX && BFX.setEnabled) BFX.setEnabled(S.ui.fx !== 0); } catch(_){ }
      try { if (typeof BATTLE !== "undefined" && BATTLE && BATTLE.sync) BATTLE.sync(); } catch(_){ }
    });
  }

  function syncBulkLabels(force=false){
    const upN = clampBulk((els.upgBulkSel && els.upgBulkSel.value) ? els.upgBulkSel.value : (S.ui&&S.ui.upgBulk)||1);
    const gN  = clampBulk((els.gupgBulkSel && els.gupgBulkSel.value) ? els.gupgBulkSel.value : (S.ui&&S.ui.gupgBulk)||1);
    document.querySelectorAll("button[data-upg]").forEach(btn => {
      const key = btn.getAttribute("data-upg");
      btn.textContent = `${UPG_LABEL[key] || key} +${upN}`;
    });
    document.querySelectorAll("button[data-gupg]").forEach(btn => {
      if (!btn.dataset.baseText) btn.dataset.baseText = btn.textContent;
      btn.textContent = `${btn.dataset.baseText} ×${gN}`;
    });
  }

  if (els.upgBulkSel){
    els.upgBulkSel.addEventListener("change", () => {
      S.ui = S.ui ?? { tab:"all", preview:null, fx:1, upgBulk:1, gupgBulk:1 };
      S.ui.upgBulk = clampBulk(els.upgBulkSel.value);
      save();
      syncBulkLabels(true);
      dirtyHUD = true;
    });
  }
  if (els.gupgBulkSel){
    els.gupgBulkSel.addEventListener("change", () => {
      S.ui = S.ui ?? { tab:"all", preview:null, fx:1, upgBulk:1, gupgBulk:1 };
      S.ui.gupgBulk = clampBulk(els.gupgBulkSel.value);
      save();
      syncBulkLabels(true);
      dirtyHUD = true;
    });
  }

  // init labels once
  syncBulkLabels(true);

  els.search.addEventListener("input", () => { dirtyInv=true; });
  els.sortSel.addEventListener("change", () => { dirtyInv=true; });

  
  if (els.btnClearSearch){
    els.btnClearSearch.addEventListener("click", () => {
      if (!els.search) return;
      els.search.value = "";
      dirtyInv = true;
      try{ els.search.focus(); }catch(_){}
    });
  }
function saveAutoSellUI(){
    S.ui = S.ui ?? { tab:"all", preview:null, fx:1, upgBulk:1, gupgBulk:1 };
    if (els.autoSellOn) S.ui.autoSellOn = els.autoSellOn.checked ? 1 : 0;
    if (els.autoSellRarMax) S.ui.autoSellRarMax = String(els.autoSellRarMax.value || "common");
    if (els.autoSellUseEq) S.ui.autoSellUseEq = (els.autoSellUseEq.checked ? 1 : 0);
    if (els.autoSellEqPct){
      const v = clamp(Math.floor(Number(els.autoSellEqPct.value)||90), 1, 100);
      S.ui.autoSellEqPct = v;
      els.autoSellEqPct.value = String(v);
    }
    if (els.autoSellProtectUnique) S.ui.autoSellProtectUnique = els.autoSellProtectUnique.checked ? 1 : 0;
    save();
  }

  if (els.autoSellOn) els.autoSellOn.addEventListener("change", () => { saveAutoSellUI(); dirtyHUD=true; });
  if (els.autoSellRarMax) els.autoSellRarMax.addEventListener("change", () => { saveAutoSellUI(); dirtyHUD=true; });
  if (els.autoSellUseEq) els.autoSellUseEq.addEventListener("change", () => { saveAutoSellUI(); dirtyHUD=true; });
  if (els.autoSellEqPct) els.autoSellEqPct.addEventListener("change", () => { saveAutoSellUI(); dirtyHUD=true; });
  if (els.autoSellProtectUnique) els.autoSellProtectUnique.addEventListener("change", () => { saveAutoSellUI(); dirtyHUD=true; });
  els.btnSellAll.addEventListener("click", () => {
    if (!S.inv.length) return;
    if (confirm("法具庫を全布施します。よろしいですか？")) sellWhere(_ => true);
  });

  document.querySelectorAll("button[data-upg]").forEach(btn=>{
    btn.addEventListener("click", () => buyUpgradeN(btn.getAttribute("data-upg"), (els.upgBulkSel ? els.upgBulkSel.value : 1)));
  });
  document.querySelectorAll("button[data-gupg]").forEach(btn=>{
    btn.addEventListener("click", () => buyGuildN(btn.getAttribute("data-gupg"), (els.gupgBulkSel ? els.gupgBulkSel.value : 1)));
  });
  els.btnRevive.addEventListener("click", () => revive());
  els.btnOpenChest.addEventListener("click", () => openOfflineChest());

  // ✅ FIX: event delegation
  els.invList.addEventListener("click", (ev) => {
    const eqBtn = ev.target.closest("button[data-eq]");
    if (eqBtn){
      equip(eqBtn.getAttribute("data-eq"));
      return;
    }
    const sellBtn = ev.target.closest("button[data-sell]");
    if (sellBtn){
      sell(sellBtn.getAttribute("data-sell"));
      return;
    }
    const itemEl = ev.target.closest(".item[data-item]");
    if (itemEl){
      setPreview(itemEl.getAttribute("data-item"));
      return;
    }
  });

  window.addEventListener("beforeunload", () => save());

  // --------------------
  // Main loop: simulate fast, render slow (v4 fix)
  // --------------------
  function simLoop(){
    try{
      const t = now();
      lastSimFrame = t;
      const r = S.run;

      // v11: 値が壊れて表示/進行が止まるのを防ぐ
      sanitizeRuntime();
      const speed = Number.isFinite(r.speed) ? r.speed : 1;

      // 安定化: lastTick/_accが壊れても、dtがNaNになって止まらない
      const last = Number.isFinite(r.lastTick) ? r.lastTick : t;
      let dt = (t - last) / 1000;
      if (!Number.isFinite(dt) || dt < 0) dt = 0;
      dt = Math.min(dt, 0.5); // 頁復帰などの巨大dtを抑制
      r.lastTick = t;

      const isMaxSpeed = (speed >= SPEED_MAX_LABEL);
      const lowSpeedIos = (IS_IOS && !isMaxSpeed && speed <= 2);
      const simSpeed = effectiveSimSpeedScaled(speed);
      // --- iOS speed calibration ---
      // Some iPhone Safari environments throttle timers/RAF in a way that makes even 1× feel too slow.
      // We measure "actual sim progress vs expected" and apply a mild multiplier to keep speeds comparable to PC.
      if (IS_IOS && speed < SPEED_MAX_LABEL){
        r._iosSpeedScale = Number.isFinite(r._iosSpeedScale) ? r._iosSpeedScale : 1;
        r._iosCalT = Number.isFinite(r._iosCalT) ? r._iosCalT : t;
        r._iosCalSim = Number.isFinite(r._iosCalSim) ? r._iosCalSim : (Number.isFinite(r._roomTime) ? r._roomTime : 0);

        if ((t - r._iosCalT) >= 1800){
          const realS = (t - r._iosCalT) / 1000;
          const simNow = Number.isFinite(r._roomTime) ? r._roomTime : 0;
          const simDelta = simNow - r._iosCalSim;

          const expected = effectiveSimSpeed(speed) * realS; // base expectation (no scale)
          if (realS > 0.5 && expected > 0){
            const ratio = simDelta / expected; // <1 means we're slower than intended
            if (Number.isFinite(ratio) && ratio > 0){
              if (ratio < 0.85){
                const boost = clamp(1 / Math.max(0.10, ratio), 1, 6);
                r._iosSpeedScale = clamp(r._iosSpeedScale * boost, 1, 12);
              }else if (ratio > 1.20 && r._iosSpeedScale > 1.02){
                r._iosSpeedScale = clamp(r._iosSpeedScale * 0.92, 1, 12);
              }else{
                // gentle drift back to 1
                r._iosSpeedScale = r._iosSpeedScale + (1 - r._iosSpeedScale) * 0.05;
              }
            }
          }

          r._iosCalT = t;
          r._iosCalSim = simNow;
        }
      }


      // --- Adaptive step (especially for iPhone/iOS) ---
      // Slow devices may not be able to execute enough tick() calls per second at high speeds.
      // We enlarge the simulation step when backlog (acc) grows, so the selected speed feels consistent.
      const baseStep = isMaxSpeed ? (IS_IOS ? 0.60 : 0.20) : 0.05;
      let acc = (Number.isFinite(r._acc) ? r._acc : 0) + dt * simSpeed;

      // 積録が溜まりすぎると処理が重くなって『止まった』ように見えるため、一定以上は間引く
      const maxStepsPerFrame = isMaxSpeed ? (IS_IOS ? 36 : 60) : 220;

      // If backlog is high, increase step so we can catch up with fewer tick() calls.
      let step = baseStep;
      if (IS_IOS){
        const stepCap = isMaxSpeed ? 1.20 : 0.40; // keep non-MAX accuracy reasonable
        // Fewer desired steps at higher speeds to reduce CPU load on iPhone
        const desiredSteps =
          isMaxSpeed ? 18 :
          (speed >= 8 ? 18 : speed >= 4 ? 22 : 28);

        if (acc > baseStep * desiredSteps){
          step = clamp(acc / desiredSteps, baseStep, stepCap);
        }
      }

      const maxAcc = step * maxStepsPerFrame;
      if (!lowSpeedIos && acc > maxAcc){
        acc = maxAcc;
        if (!r._accDropLogged){
          try{ log(`<span class="warn">負荷対策</span>: 試算が追いつかないため、処理を間引きました（迅行を下げると安定します）`); } catch{}
          r._accDropLogged = true;
          dirtyLog = true;
        }
      }

      let guard = 0;
      const t0 = (typeof performance !== 'undefined' && performance.now) ? performance.now() : now();
      const budgetMs = lowSpeedIos ? 28 : (isMaxSpeed ? (IS_IOS ? 14 : 18) : 14);
      while (acc >= step && guard++ < maxStepsPerFrame){
        tick(step);
        acc -= step;
        const t1 = (typeof performance !== 'undefined' && performance.now) ? performance.now() : now();
        if ((t1 - t0) > budgetMs) break;
      }
      r._acc = acc;

      requestAnimationFrame(simLoop);
    } catch (e){
      try{ logImportant(`<span class="bad">例外</span>: ${String(e).slice(0, 120)}`); } catch{}
      S.run.active = false;
      dirtyHUD = true; dirtyLog = true;
      requestAnimationFrame(simLoop);
    }
  }

  // Render throttle
  setInterval(() => {
    try{
      const tNow = now();
      lastRenderFrame = tNow;

      // Always update the lightweight run mini.
      renderRunLocMini();

      // MAX speed: keep UI alive but throttle heavier renders.
      if (isSpeedMax()){
        const r = (S && S.run) ? S.run : null;
        if (r){
          // Stage keepalive (icons/animation) even when HUD is throttled.
          try{ if (typeof BATTLE !== "undefined" && BATTLE && BATTLE.syncLite) BATTLE.syncLite(); }catch(_){}

          // HUD throttle (bars / numbers): ~4-5fps
          r._maxHudT = Number.isFinite(r._maxHudT) ? r._maxHudT : 0;
          if (dirtyHUD && (tNow - r._maxHudT) >= 220){
            r._maxHudT = tNow;
            renderHUD();
            dirtyHUD = false;
            try{ if (typeof updateHUDSpritesLite === "function") updateHUDSpritesLite(); }catch(_){}
          }

          // Full UI throttle (log / inventory / compare): ~2fps
          r._maxUiT = Number.isFinite(r._maxUiT) ? r._maxUiT : 0;
          if (tNow - r._maxUiT < 520) return;
          r._maxUiT = tNow;
        }
      }

      // Full pass (normal, or throttled MAX)
      if (dirtyHUD){ renderHUD(); dirtyHUD = false; }
      if (dirtyLog){ renderLog(); dirtyLog = false; }
      if (S.ui && S.ui.preview) renderCompare();

      const invSig = inventorySignature();
      const q = (els.search.value || "").trim().toLowerCase();
      const s = els.sortSel.value;
      const isMax = isSpeedMax();
      const needInv = dirtyInv || (!isMax && invSig !== lastInvSig) || q !== lastQuery || s !== lastSort;
      if (needInv){
        lastInvSig = invSig; lastQuery = q; lastSort = s;
        renderInventory();
        dirtyInv = false;
        if (S.ui && S.ui.preview) renderCompare();
      } else {
        els.invCount.textContent = `${S.inv.length} 個`;
      }
    } catch(e){
      try{ logImportant(`<span class="bad">描画例外</span>: ${String(e).slice(0, 120)}`); } catch{}
    }
  }, (IS_IOS ? 220 : 140));

  // Offline apply once
  (function boot(){
    applyOffline();
    // iOS: default FX off (can be turned back on from UI) to keep MAX speed usable.
    try{
      S.ui = S.ui ?? { tab:"all", preview:null, fx:1 };
      if (IS_IOS && (S.ui.fx === undefined || S.ui.fx === null)) S.ui.fx = 0;
      if (IS_IOS && Number(S.ui.fx) === 0){
        try{ if (typeof BFX!=="undefined" && BFX && BFX.setEnabled) BFX.setEnabled(false); }catch(_){}
      }
    }catch(_){}

    ensureEnemy();
    try{ AURA.init(); }catch(_){ }
    try{ updateRealmFx(); }catch(_){ }
    try{ if (typeof SOUND!=="undefined" && SOUND) SOUND.stop(); }catch(_){ }
    logImportant(`<span class="good">起動</span>: 第十三版（密教拡張: 二曼荼羅/六道の音・粒子/五毒仕掛）`);
    save();
    dirtyHUD = true; dirtyInv = true; dirtyLog = true;
  })();


  // Watchdog: 何らかの理由で輪転/描画が止まった場合に自動復旧
  setInterval(() => {
    try{
      const t = now();
      // simLoopが止まっているっぽい
      if ((t - lastSimFrame) > 1500){
        requestAnimationFrame(simLoop);
      }
      // 描画が止まっているっぽい
      if ((t - lastRenderFrame) > 1500){
        dirtyHUD = true; dirtyInv = true; dirtyLog = true;
      }
    } catch(_){}
  }, 900);

  setInterval(save, 10000);
  requestAnimationFrame(simLoop);
})();
</script>


</body>
</html>
