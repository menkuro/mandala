<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>ÊõºËçºÁæÖËø∑ÂÆÆË®ò ‚Äî ÂÖ≠Âç∞Â∑°Á§ºÔºàÈáëÂâõÁïåÔºâ</title>
  
  <style>
    :root{
      --bg:#0b0f16; --panel:#0f1624; --panel2:#0c1220; --text:#e6edf3; --muted:#9aa8b7;
      --accent:#7dd3fc; --good:#22c55e; --warn:#f59e0b; --bad:#ef4444; --line:#1f2a3a;
      --shadow: 0 10px 30px rgba(0,0,0,.35);
      --glow: 0 0 0 1px rgba(125,211,252,.10), 0 18px 50px rgba(0,0,0,.35);
      --glass: rgba(9,14,22,.55);
      --glass2: rgba(15,22,36,.72);
      --shine: linear-gradient(135deg, rgba(125,211,252,.22), rgba(34,197,94,.10), rgba(251,191,36,.12));
    }
    *{box-sizing:border-box}
    body{
      margin:0;
      font-size:13px;
      line-height:1.25;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Hiragino Kaku Gothic ProN", "Yu Gothic", "Noto Sans JP", "Meiryo", sans-serif;
      background: radial-gradient(1200px 800px at 10% -10%, #1b2b55 0%, rgba(27,43,85,0) 60%),
                  radial-gradient(1000px 600px at 110% 10%, #143b30 0%, rgba(20,59,48,0) 60%),
                  repeating-linear-gradient(90deg, rgba(255,255,255,.03) 0 1px, rgba(255,255,255,0) 1px 12px),
                  repeating-linear-gradient(0deg, rgba(255,255,255,.02) 0 1px, rgba(255,255,255,0) 1px 14px),
                  var(--bg);
      color:var(--text);
    }
    header{
      position:sticky; top:0; z-index:10;
      background: rgba(11,15,22,.68);
      backdrop-filter: blur(10px);
      border-bottom:1px solid var(--line);
    }
    .wrap{max-width:1180px; margin:0 auto; padding:8px 10px 10px;}
    .topbar{display:flex; gap:8px; align-items:center; justify-content:space-between;}
    .brand{display:flex; flex-direction:column; line-height:1.15;}
    .brand b{font-size:14px; letter-spacing:.4px}
    .brand span{font-size:12px; color:var(--muted)}
    
    .locBadge{
      display:inline-flex; align-items:center; gap:8px;
      padding:6px 10px; border-radius:999px;
      border:1px solid #27364f;
      background: rgba(11,26,45,.45);
      color:var(--muted);
      font-weight:950; font-size:12px;
      white-space:nowrap;
    }
    .locBadge b{
      color:var(--text);
      display:inline-block;
      min-width:0;
      text-align:left;
      font-variant-numeric: tabular-nums;
    }
    @media  (max-width: 520px){
      .locBadge b{min-width:0; text-align:left;}
    }

    .tabs{
      display:flex; gap:6px; flex-wrap:wrap;
      background: rgba(7,10,16,.35);
      border:1px solid var(--line);
      padding:6px;
      border-radius:14px;
    }
    .tabBtn{
      padding:6px 10px;
      border-radius:14px;
      border:1px solid #223049;
      background: rgba(11,26,45,.35);
      color: var(--muted);
      font-weight:950;
      cursor:pointer;
      box-shadow:none;
    }
    .tabBtn.active{
      border-color:#2a4b6a;
      color:var(--text);
      background: rgba(20,50,80,.35);
    }
    .tag .safe{color:#86efac}
    /* Monster affix (‰ªòÂ∏ØÁâπÊÄß) tooltip */
    .modTag{
      text-decoration: underline dotted;
      text-underline-offset: 2px;
      cursor: help;
    }
    .controls{display:flex; gap:8px; flex-wrap:wrap; align-items:center; justify-content:flex-end;}
    button, select{
      background: linear-gradient(180deg, #141e2f, #0f1726);
      border:1px solid #223049;
      color:var(--text);
      padding:8px 10px;
      border-radius:14px;
      cursor:pointer;
      box-shadow: 0 6px 18px rgba(0,0,0,.25);
      font-weight:800;
      font-size:12px;
    }
    button{transition: transform .08s ease, border-color .15s ease, box-shadow .15s ease, background .15s ease}
    button:disabled{opacity:.45; cursor:not-allowed; filter:saturate(.6);}

    button:hover{border-color:#2f4366; box-shadow: var(--glow)}
    button:active{transform: translateY(1px)}
    button.small{padding:8px 10px; border-radius:10px; font-weight:900}
    button.lockBtn{padding:2px 6px; border-radius:999px; font-weight:950; font-size:11px; line-height:1; background:rgba(255,255,255,.02); box-shadow:none;}
    button.lockBtn.locked{border-color:#6b3b44; background:rgba(239,68,68,.08);}
    button.ghost{background:transparent; box-shadow:none}
    button.bad{border-color:#4a1f27}
    button.accent{border-color:#2a4b6a}
    select{padding:7px 10px}
    /* Select / option readability: improve dropdown contrast across OS/browsers */
    select{ color-scheme: dark; }
    select option, select optgroup{
      background-color:#0f1726;
      color: var(--text);
    }
    select:focus-visible{
      outline: 2px solid rgba(125,211,252,.35);
      outline-offset: 2px;
    }
    .grid{display:grid; grid-template-columns: 1.05fr .95fr; gap:10px; margin-top:10px;}
    @media (max-width: 980px){ .grid{grid-template-columns:1fr;} .controls{justify-content:flex-start} }

    .card{
      background: linear-gradient(180deg, rgba(15,22,36,.95), rgba(12,18,32,.92));
      border:1px solid var(--line);
      border-radius:16px;
      box-shadow: var(--shadow); position:relative;
      overflow:hidden;
    }
    .card h2{
      margin:0; padding:12px 14px;
      font-size:13px; letter-spacing:.3px;
      border-bottom:1px solid var(--line);
      display:flex; align-items:center; justify-content:space-between;
    }
    .card h2 span{color:var(--muted); font-weight:800; font-size:12px; min-width:0; max-width:100%; overflow:hidden; text-overflow:ellipsis; white-space:nowrap;}
    #runInfo{max-width: 60%; min-width:22ch; text-align:right; overflow:hidden; text-overflow:ellipsis; white-space:nowrap; font-variant-numeric: tabular-nums;}
    @media (max-width: 520px){ #runInfo{max-width:100%; min-width:0; text-align:left; white-space:normal;} }
    @media (max-width: 520px){ .card h2 span{white-space:normal; overflow:visible; text-overflow:clip;} }
    .card h2{gap:10px; flex-wrap:wrap;}
    .card .body{padding:10px 12px;}
    .row{display:flex; gap:10px; flex-wrap:wrap}
    .col{flex:1 1 260px}
    .split{display:grid; grid-template-columns: 1fr 1fr; gap:10px;}
    @media (max-width: 520px){ .split{grid-template-columns:1fr} }

    .statgrid{display:grid; grid-template-columns: repeat(2, minmax(0, 1fr)); gap:8px;}

    .statgrid.stack{grid-template-columns: 1fr;}
    .lvCompact .k{font-size:10px}
    .lvCompact .v{font-size:12px}
    .lvCompact .sub{font-size:10px}

    @media (max-width: 420px){ .statgrid{grid-template-columns:1fr} }
    .stat{
      background: rgba(9,14,22,.55);
      border:1px solid var(--line);
      border-radius:14px;
      padding:10px 10px;
    }
    .stat .k{font-size:11px; color:var(--muted)}
    .stat .v{font-size:clamp(12px, 2.7vw, 14px); font-weight:950; margin-top:2px; font-variant-numeric: tabular-nums;}
    .atkDefGrid{display:grid; grid-template-columns: 1fr 1fr; gap:8px; margin-top:6px;}
    @media (max-width: 520px){ .atkDefGrid{grid-template-columns:1fr;} }
    .bigStat{background: rgba(7,10,16,.25); border:1px solid rgba(31,42,58,.55); border-radius:14px; padding:10px;}
    .bigStat .k2{font-size:11px; color:var(--muted)}
    .bigStat .v2{margin-top:2px; font-weight:1000; font-size:clamp(14px, 3.5vw, 18px); font-variant-numeric: tabular-nums;}

    .stat, .enemybox, .slot{min-width:0;}
    .bar{height:10px; border-radius:999px; border:1px solid var(--line); background: rgba(0,0,0,.25); overflow:hidden;}
    .fill{height:100%; width:50%;}
    /* Large numbers can wrap without crushing the layout */
    .sub{display:flex; flex-wrap:wrap; align-items:flex-start; justify-content:space-between; gap:6px 10px; margin-top:6px; font-size:11px; color:var(--muted); font-variant-numeric: tabular-nums;}
    .sub span{min-width:0; flex:1 1 240px; white-space:normal; overflow-wrap:anywhere; word-break:break-word;}
    @media (max-width: 520px){ .sub span{flex-basis:100%;} }

    /* Enemy stats line: keep it on a single line (no accidental 2-line wrap) */
    .sub.oneLine{flex-wrap:nowrap; align-items:center;}
    .sub.oneLine span{
      flex:0 1 auto;
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
      overflow-wrap:normal;
      word-break:normal;
      flex-basis:auto !important;
    }
    .sub.oneLine span:first-child{flex:0 0 auto;}
    .sub.oneLine span:last-child{flex:1 1 auto; text-align:right;}

    .enemybox{
      background: rgba(9,14,22,.55);
      border:1px solid var(--line);
      border-radius:16px;
      padding:12px;
    }
    .enemyname{font-weight:950; font-size:14px}

    /* v33: È≠îÊÉÖÂ†±„ÅÆÈÖçÁΩÆÔºàÂ∑¶: ÁïåÁõ∏+ÂêçÂâç / Âè≥: ÂÆâÂÖ®„ÉªÂ§©È≠îÁ≠âÔºâ */
    .enemyTitle{display:flex; align-items:center; justify-content:space-between; gap:10px; flex-wrap:wrap;}
    .enemyLeft{display:flex; align-items:center; gap:10px; min-width:0; flex:1 1 auto;}
    .enemyText{min-width:0;}
    .enemyBiome{margin-bottom:2px;}
    .tag.mini{font-size:10px; padding:2px 7px;}
    .enemyFlags{display:flex; gap:6px; align-items:center; justify-content:flex-end; margin-left:auto;}

    /* v33: ÂäüÂæ≥Áõ∏/Ê≥ïÂÖ∑Â∫ß„ÇíÁ∏¶ÊñπÂêë„Å´Ë©∞„ÇÅ„Çã */
    .stat.tight{padding:8px 10px;}
    .stat.tight .atkDefGrid{margin-top:4px; gap:6px;}
    .stat.tight .bigStat{padding:8px; border-radius:14px;}
    .stat.tight .sub{margin-top:4px;}
    .equipSlots{gap:6px;}
    .equipSlots .slot{padding:6px;}
    .slot .v{margin-top:2px;}
    .tag{
      display:inline-flex; align-items:center; gap:6px;
      padding:3px 8px; border-radius:999px;
      background: rgba(12,26,42,.65);
      border:1px solid #223049;
      color:var(--muted);
      font-size:11px; font-weight:900;
    }
    .tag b{color:var(--text)}
    /* UI stability: keep adjacent tags from shifting when numbers grow */
    #roomText, #floorText{
      display:inline-block;
      min-width:7ch;
      text-align:right;
      font-variant-numeric: tabular-nums;
    }

    .tag .elite{color:#fbbf24}
    .tag .boss{color:#fb7185}

    .log{
      height:280px; overflow:auto;
      overflow-anchor: none;
      overscroll-behavior: contain;
      scrollbar-gutter: stable;
      background: rgba(7,10,16,.55);
      border:1px solid var(--line);
      border-radius:16px;
      padding:10px;
      font-size:12px;
      line-height:1.35;
    }
    .log .t{color:var(--muted); font-size:10px; margin-right:6px}
    .log .good{color:#86efac}
    .log .bad{color:#fda4af}
    .log .rare{color:#c4b5fd}
    .log .warn{color:#fbbf24}
    .log .gold{color:#fbbf24}

    .log .k{font-weight:900; letter-spacing:.02em}
    .log .indent{display:inline-block; margin-left:12px}
    .log .sep{display:block; margin:4px 0; color:rgba(148,163,184,.55)}

    /* --- Log readability upgrade --- */
    .log{ font-variant-numeric: tabular-nums; }
    .log .entry{
      display:flex;
      gap:8px;
      align-items:flex-start;
      transition: transform .46s cubic-bezier(.15,.85,.2,1), opacity .46s ease, background .30s ease, box-shadow .30s ease;
      padding:8px 10px;
      border-radius:14px;
      margin:3px 0;
      background: rgba(255,255,255,.02);
      border:1px solid rgba(148,163,184,.10);
    }
    .log .entry:nth-child(2n){ background: rgba(255,255,255,.03); }
    .log .entry.new{
      opacity:0;
      transform: translateY(18px);
      box-shadow: 0 10px 22px rgba(0,0,0,.25);
    }
    .log .time{
      flex:0 0 auto;
      color: rgba(148,163,184,.85);
      font-size:10px;
      line-height:1.4;
      min-width:44px;
      text-align:right;
      margin-top:1px;
    }
    .log .badge{
      flex:0 0 auto;
      display:inline-flex;
      align-items:center;
      gap:6px;
      padding:2px 8px;
      border-radius:999px;
      font-size:10px;
      font-weight:800;
      letter-spacing:.04em;
      line-height:1.6;
      border:1px solid rgba(148,163,184,.18);
      background: rgba(15,22,36,.65);
      color: rgba(226,232,240,.92);
      white-space:nowrap;
      user-select:none;
    }
    .log .badge .ico{ font-size:11px; opacity:.95; }
    .log .msg{
      flex:1 1 auto;
      min-width:0;
      word-break:break-word;
    }

    /* left accent by kind */
    .log .kind-combat{ border-left:3px solid rgba(125,211,252,.55); }
    .log .kind-sell{ border-left:3px solid rgba(251,191,36,.65); }
    .log .kind-chest{ border-left:3px solid rgba(196,181,253,.65); }
    .log .kind-empower{ border-left:3px solid rgba(34,197,94,.55); }
    .log .kind-mantra{ border-left:3px solid rgba(147,197,253,.60); }
    .log .kind-purify{ border-left:3px solid rgba(248,113,113,.60); }
    .log .kind-realm{ border-left:3px solid rgba(167,243,208,.55); }
    .log .kind-seal{ border-left:3px solid rgba(216,180,254,.65); }
    .log .kind-reward{ border-left:3px solid rgba(250,204,21,.45); }
    .log .kind-system{ border-left:3px solid rgba(148,163,184,.35); }

    /* severity tint */
    .log .sev-good{ box-shadow: inset 0 0 0 999px rgba(34,197,94,.03); }
    .log .sev-warn{ box-shadow: inset 0 0 0 999px rgba(245,158,11,.03); }
    .log .sev-bad{  box-shadow: inset 0 0 0 999px rgba(239,68,68,.03); }
    .log .sev-rare{ box-shadow: inset 0 0 0 999px rgba(196,181,253,.03); }

    /* compress inline spans inside msg */
    .log .msg .k{ font-weight:900; }
    .log .msg .indent{ margin-left:10px; }
    .hr{height:1px; background:var(--line); margin:8px 0;}

    .invTop{
  display:grid;
  grid-template-columns: 1fr;
  gap:8px;
  align-items:center;
}
@media (min-width: 860px){
  .invTop{grid-template-columns: auto 1fr; align-items:start;}
}
.invTabsWrap{min-width:0}
.invTools{
  min-width:0;
  display:flex;
  gap:8px;
  flex-wrap:wrap;
  align-items:center;
  justify-content:flex-end;
}
.searchWrap{
  position:relative;
  flex:1 1 280px;
  max-width:520px;
  min-width:220px;
}
.searchWrap input{
  width:100%;
  flex:1 1 auto;
  padding-left:30px;
  padding-right:34px;
}
.searchIcon{
  position:absolute;
  left:10px;
  top:50%;
  transform: translateY(-50%);
  color: var(--muted);
  font-weight:950;
    font-size:12px;
  line-height:1;
opacity:.9;
  pointer-events:none;
  user-select:none;
}
.iconBtn{
  position:absolute;
  right:8px;
  top:50%;
  transform: translateY(-50%);
  padding:4px 8px;
  border-radius:999px;
  font-weight:950;
  font-size:11px;
  line-height:1;
  background: rgba(255,255,255,.02);
  box-shadow:none;
  opacity:.0;
  pointer-events:none;
}
.searchWrap input:not(:placeholder-shown) ~ .iconBtn{
  opacity:1;
  pointer-events:auto;
}
.invFilters{
  margin-top:6px;
  padding:6px;
  border-radius:12px;
  border:1px solid rgba(31,42,58,.85);
  background: rgba(7,10,16,.35);
  display:flex;
  gap:6px;
  align-items:center;
  flex-wrap:nowrap;
  overflow-x:auto;
  overflow-y:hidden;
  white-space:nowrap;
  scrollbar-width:thin;
  -webkit-overflow-scrolling:touch;
}
.invFilters .filterGroup{display:flex; gap:6px; align-items:center}
.invFilters .fLabel{color:var(--muted); font-size:11px; font-weight:900}
.invFilters select{
  padding:5px 9px;
  border-radius:999px;
  font-size:11.5px;
}
.invFilters input[type="number"]{
  width:64px;
  background: rgba(9,14,22,.55);
  border:1px solid var(--line);
  color:var(--text);
  padding:5px 9px;
  border-radius:999px;
  outline:none;
  font-weight:900;
  font-variant-numeric: tabular-nums;
}
.checkPill{
  display:inline-flex;
  align-items:center;
  gap:6px;
  padding:5px 9px;
  border-radius:999px;
  border:1px solid #27364f;
  background: rgba(11,26,45,.45);
  color:var(--muted);
  font-weight:900;
  font-size:11.5px;
  user-select:none;
}
.checkPill span{white-space:nowrap}
.checkPill input{accent-color: var(--accent); transform: translateY(1px);}

    input[type="text"]{
      background: rgba(9,14,22,.55);
      border:1px solid var(--line);
      color:var(--text);
      padding:8px 10px;
      border-radius:14px;
      outline:none;
      flex:1 1 180px;
    }

    /* Search box: reserve space for icon + clear button (avoid overlap) */
    .searchWrap input[type="text"]{
      padding-left:36px;
      padding-right:40px;
    }
    .list{margin-top:8px; display:flex; flex-direction:column; gap:6px; max-height:560px; overflow:auto; padding-right:2px;}

    /* Scrollbars */
    .log::-webkit-scrollbar, .list::-webkit-scrollbar{width:10px; height:10px}
    .log::-webkit-scrollbar-thumb, .list::-webkit-scrollbar-thumb{background: rgba(148,163,184,.25); border-radius:999px; border:2px solid rgba(7,10,16,.35)}
    .log::-webkit-scrollbar-track, .list::-webkit-scrollbar-track{background: rgba(7,10,16,.15); border-radius:999px}

    /* Inventory items */
    .item{
  position:relative;
  background: linear-gradient(180deg, rgba(9,14,22,.62), rgba(9,14,22,.46));
  border:1px solid var(--line);
  border-radius:16px;
  padding:10px 10px 10px 22px;
  display:grid;
  grid-template-columns: 1fr auto;
  gap:10px;
  align-items:center;
  justify-content:space-between;
  transition: transform .12s ease, box-shadow .15s ease, border-color .15s ease, background .15s ease;
}
    .item::before{content:""; position:absolute; left:10px; top:8px; bottom:8px; width:4px; border-radius:999px; opacity:.92; background: rgba(203,213,225,.55)}
    .item:hover{transform: translateY(-1px); border-color:#2a4b6a; box-shadow: var(--glow)}
    .item.selected{border-color:#2a4b6a; box-shadow: 0 0 0 1px rgba(125,211,252,.22), var(--shadow), 0 0 24px rgba(125,211,252,.08)}
    .item.rar-common::before{background: linear-gradient(180deg, rgba(203,213,225,.65), rgba(148,163,184,.35))}
    .item.rar-uncommon::before{background: linear-gradient(180deg, rgba(134,239,172,.75), rgba(34,197,94,.30))}
    .item.rar-rare::before{background: linear-gradient(180deg, rgba(147,197,253,.75), rgba(125,211,252,.30))}
    .item.rar-epic::before{background: linear-gradient(180deg, rgba(196,181,253,.80), rgba(167,139,250,.30))}
    .item.rar-legendary::before{background: linear-gradient(180deg, rgba(251,191,36,.85), rgba(245,158,11,.35))}
    .item.rar-unique::before{background: linear-gradient(180deg, rgba(251,113,133,.85), rgba(239,68,68,.35))}

    .item .left{min-width:0; display:flex; gap:10px; align-items:flex-start}
    .itText{min-width:0; flex:1}

    /* Inventory stat pills (horizontal, balanced) */
    .istat{margin-top:4px; display:grid; grid-template-columns: repeat(auto-fit, minmax(92px, 1fr)); gap:4px;}
    .istat .sp{
      display:block;
      font-size:10.5px;
      line-height:1.2;
      padding:2px 8px;
      border-radius:999px;
      border:1px solid #27364f;
      background: rgba(11,26,45,.45);
      color: var(--muted);
      font-weight:900;
      font-variant-numeric: tabular-nums;
      white-space:nowrap; overflow:hidden; text-overflow:ellipsis;
      text-align:center;
    }

    .istat .sp.capDead{
      opacity:.38;
      filter:saturate(.65);
    }
    .istat .sp .maxTag{
      display:inline-block;
      margin-left:6px;
      padding:1px 6px;
      border-radius:999px;
      border:1px solid rgba(245,158,11,.45);
      background: rgba(245,158,11,.12);
      color: var(--warn);
      font-size:10px;
      font-weight:1000;
      letter-spacing:.02em;
      vertical-align:baseline;
    }

    /* Pixel sprites (no external assets) */
    .enemyTitle{display:flex; align-items:center; justify-content:space-between; gap:10px; flex-wrap:wrap;}
    /* Pixel art readability: keep CSS sizes as integer multiples of the 16x16 canvas */
    .pxSprite{width:32px; height:32px; image-rendering: auto; border:1px solid var(--line); border-radius:14px; background: rgba(0,0,0,.18); box-shadow: inset 0 0 0 1px rgba(255,255,255,.03)}
    .pxHero{width:32px; height:32px; image-rendering:auto}
    .pxStage{image-rendering:auto}
    .pxEnemy{width:32px; height:32px}
    .pxMini{width:32px; height:32px; border-radius:12px}
    .itemIcon{width:32px; height:32px; border-radius:12px}
    .vIcon{display:flex; align-items:center; gap:10px; min-width:0}
    .vIcon span{min-width:0; overflow:hidden; text-overflow:ellipsis; white-space:nowrap}
    .slot .v.vIcon{white-space:nowrap; overflow:hidden; text-overflow:ellipsis}
    .pxSprite.rar-common{border-color: rgba(148,163,184,.35)}
    .pxSprite.rar-uncommon{border-color: rgba(34,197,94,.35)}
    .pxSprite.rar-rare{border-color: rgba(125,211,252,.35)}
    .pxSprite.rar-epic{border-color: rgba(167,139,250,.38)}
    .pxSprite.rar-legendary{border-color: rgba(245,158,11,.45)}
    .pxSprite.rar-unique{border-color: rgba(239,68,68,.45)}
    .iname{
  font-weight:950;
  font-size:13px;
  display:grid;
  grid-template-columns: auto 1fr auto auto;
  gap:6px 8px;
  align-items:center;
  min-width:0;
}
.inameName{
  min-width:0;
  white-space:nowrap;
  overflow:hidden;
  text-overflow:ellipsis;
}
@media (max-width: 640px){
  .iname{grid-template-columns:auto 1fr; }
  .iname .pill{justify-self:start;}
}
    .idesc{color:var(--muted); font-size:11px; margin-top:4px; white-space:pre-line;}
    .item .actions{
  display:flex;
  flex-direction:column;
  gap:6px;
  align-items:stretch;
  justify-content:flex-start;
  min-width:92px;
}
.item .actions button{width:100%; justify-content:center;}
@media (max-width: 560px){
  .item{grid-template-columns:1fr;}
  .item .actions{flex-direction:row; justify-content:flex-end; min-width:0;}
  .item .actions button{width:auto;}
}
    /* Rarity label: smaller, pill style */
    .rar{font-weight:950; font-size:10px; line-height:1; display:inline-flex; align-items:center; padding:2px 8px; border-radius:999px; border:1px solid #27364f; background: rgba(11,26,45,.55);}
    .rar.common{color:#cbd5e1}
    .rar.uncommon{color:#86efac}
    .rar.rare{color:#93c5fd}
    .rar.epic{color:#c4b5fd}
    .rar.legendary{color:#fbbf24; text-shadow: 0 0 14px rgba(251,191,36,.18)}
    .rar.unique{color:#fb7185; text-shadow: 0 0 14px rgba(251,113,133,.18)}

    .pill{
      font-size:10px; font-weight:950;
      padding:2px 8px; border-radius:999px;
      border:1px solid #27364f;
      background: rgba(11,26,45,.6);
      color: var(--muted);
      font-variant-numeric: tabular-nums;
    }
    .equipSlots{display:flex; flex-direction:column; gap:5px;}
    .equipSlots .slot{padding:6px;}
    .equipSlots .vIcon{align-items:flex-start;}
    .equipSlots .vIcon span{flex:1; min-width:0; white-space:normal; overflow:visible; text-overflow:clip; overflow-wrap:anywhere;}
    .equipSlots .slot .v{white-space:normal; overflow:visible; text-overflow:clip; line-height:1.25;}
.slotHead{display:flex; align-items:center; justify-content:space-between; gap:8px; flex-wrap:wrap;}
    .slotHead .k{margin:0;}
    .slotHead .pill{white-space:nowrap;}

    .slot{
      background: rgba(9,14,22,.55);
      border:1px solid var(--line);
      border-radius:14px;
      padding:6px;
    }
    .slot .k{font-size:11px; color:var(--muted)}
    .slot .v{margin-top:2px; font-weight:950; font-size:12px; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;}
    .footerNote{color:var(--muted); font-size:11px; margin-top:10px; line-height:1.4;}
    .warnBox{
      background: rgba(24,16,6,.45);
      border:1px solid rgba(245,158,11,.25);
      border-radius:14px;
      padding:10px;
      color: var(--muted);
      font-size:11px;
      line-height:1.35;
    }
  
    .goodTxt{color:#86efac}
    .badTxt{color:#fda4af}
    .mutedTxt{color:var(--muted)}.cmpBox{white-space:pre-line; color:var(--muted); font-size:11px; line-height:1.35}
    .cmpTitleLine{display:flex; gap:8px; flex-wrap:wrap; align-items:center; margin-top:6px}
    .miniHr{height:1px; background:var(--line); margin:8px 0;}
    .modalOverlay{
      position:fixed; inset:0; background: rgba(0,0,0,.55);
      display:none; align-items:center; justify-content:center;
      padding:16px; z-index:100;
    }
    .modal{
      width:min(880px, 96vw);
      background: linear-gradient(180deg, rgba(15,22,36,.98), rgba(12,18,32,.96));
      border:1px solid var(--line);
      border-radius:16px;
      box-shadow: var(--shadow); position:relative;
      overflow:hidden;
    }
    .modal h3{
      margin:0; padding:12px 14px;
      font-size:13px; letter-spacing:.3px;
      border-bottom:1px solid var(--line);
      display:flex; justify-content:space-between; align-items:center;
    }
    .modal .content{padding:14px; color:var(--muted); font-size:12px; line-height:1.45}
    .kbd{display:inline-flex; align-items:center; padding:2px 8px; border-radius:10px; border:1px solid #223049; background: rgba(11,26,45,.5); color:var(--text); font-weight:950; font-size:11px}

  
    /* Scrollbars */
    *{scrollbar-color:#2a3a55 rgba(0,0,0,0); scrollbar-width:thin}
    *::-webkit-scrollbar{width:10px; height:10px}
    *::-webkit-scrollbar-thumb{background: linear-gradient(180deg, rgba(125,211,252,.25), rgba(251,191,36,.18)); border:1px solid rgba(42,75,106,.55); border-radius:999px}
    *::-webkit-scrollbar-track{background: rgba(0,0,0,0)}

    /* Bars */
    #expBar{background: linear-gradient(90deg, rgba(125,211,252,.85), rgba(167,139,250,.85))}
    #hpBar{background: linear-gradient(90deg, rgba(34,197,94,.85), rgba(125,211,252,.85))}
    #enemyHpBar{background: linear-gradient(90deg, rgba(251,191,36,.85), rgba(251,113,133,.75))}
    .fill{transition: width .18s ease-out}


    /* v13: battle stage (dot sprites + animation) */
    /* v24: battle viewport height ~1/2 (numbers widening etc. shouldn't shift layout) */
    .battleViewport{position:relative; width:100%; aspect-ratio: 32 / 8; border-radius:16px; overflow:hidden;
      border:1px solid rgba(31,42,58,.95);
      background: linear-gradient(135deg, rgba(125,211,252,.10), rgba(34,197,94,.06), rgba(245,158,11,.08));
      box-shadow: 0 10px 28px rgba(0,0,0,.35);
    }
    .battleViewport .battleStage{position:absolute; inset:0; margin:0; border:none; border-radius:0; padding:10px 12px;}
    @media (max-width: 520px){ .battleViewport .battleStage{padding:8px 10px;} }

    /* v64: Ë™ø‰ºèÊºîÂá∫„ÇíÂªÉ„Åó„ÄÅË®ò„ÅÆ„Åø„ÇíË°®Á§∫ÔºàÊà¶Èóò„Ç¢„Éã„É°„Éº„Ç∑„Éß„É≥ÁÑ°„ÅóÔºâ */
    .battleViewport.logOnly{ aspect-ratio:auto; height: clamp(230px, 26vh, 360px); }
    .battleViewport.logOnly .battleLog{
      position:absolute;
      left:10px; right:10px; top:10px; bottom:10px;
      height:auto !important;
      max-height:none !important;
      z-index:1;
      background: rgba(7,10,16,.62);
    }
    .battleViewport.logOnly #battleStage{ display:none !important; }

    /* Death UI remains on top of the log */

    /* Death UI: show revive button on top of battle animation */
    .deathOverlay{
      position:absolute; inset:0;
      z-index:30;
      display:none;
      align-items:center;
      justify-content:center;
      padding:14px;
      background: rgba(0,0,0,.55);
      backdrop-filter: blur(2px);
    }
    .deathPanel{
      width:min(420px, 92%);
      background: linear-gradient(180deg, rgba(15,22,36,.98), rgba(12,18,32,.94));
      border:1px solid rgba(42,75,106,.70);
      border-radius:18px;
      box-shadow: var(--shadow);
      padding:14px 14px 12px;
      text-align:center;
    }
    .deathTitle{
      font-weight:950;
      letter-spacing:.5px;
      font-size:14px;
      margin-bottom:8px;
    }
    .deathPanel #deathNote{
      display:block;
      margin:0 0 10px;
    }
    .deathPanel button{
      padding:10px 16px;
      border-radius:14px;
      font-weight:950;
      font-size:13px;
    }
    .deathHint{
      margin-top:10px;
      color:var(--muted);
      font-size:11px;
      line-height:1.35;
    }


    /* v27: keep stage sprites crisp (integer scaling) + make enemy ~2x hero */
    :root{ --stageSize:64px; }
    @media (max-width: 520px){ :root{ --stageSize:48px; } }
    .pxStage{width:var(--stageSize); height:var(--stageSize); border-radius:16px; box-shadow: 0 8px 18px rgba(0,0,0,.35)}
    .battleStage .actor.enemy .pxStage{width:calc(var(--stageSize) * 2); height:calc(var(--stageSize) * 2); border-radius:18px}
    /* È≠îÂç∞„ÅØÈ°å„Å´„ÇÇË°®Á§∫ÔºàË™ø‰ºèÊò†ÂÉè„ÅØ‰∏äÈÉ®„Å´ÁßªÂãïÔºâ */
    .enemyTitle .pxEnemy{display:block}

    .battleStage{position:relative; display:flex; justify-content:space-between; align-items:flex-end; gap:14px;
      padding:10px 12px; margin-top:10px;
      border:1px solid rgba(31,42,58,.95);
      border-radius:16px;
      background: linear-gradient(135deg, rgba(125,211,252,.10), rgba(34,197,94,.06), rgba(245,158,11,.08));
      overflow:hidden;
    }
    .battleStage:before{content:""; position:absolute; inset:-2px;
      background:
        radial-gradient(200px 140px at 20% 30%, rgba(125,211,252,.22), transparent 60%),
        radial-gradient(220px 160px at 80% 60%, rgba(167,139,250,.20), transparent 62%),
        radial-gradient(260px 200px at 50% 110%, rgba(34,197,94,.12), transparent 60%);
      opacity:.7; pointer-events:none;
    }
    .battleStage .actor{position:relative; z-index:1; display:flex; align-items:flex-end}
    .battleStage .actor.dead{filter: grayscale(.85) brightness(.72); opacity:.8}

    .battleStage.running .actor.hero{animation: heroIdle 1.35s ease-in-out infinite}
    .battleStage.running .actor.enemy{animation: enemyIdle 1.55s ease-in-out infinite}

    .battleStage .actor.atk{animation: atkLunge .22s ease-out 1}
    .battleStage .actor.hit{animation: hitShake .22s ease-out 1; filter: brightness(1.25) saturate(1.25)}

    @keyframes heroIdle{0%,100%{transform:translateY(0)}50%{transform:translateY(-2px)}}
    @keyframes enemyIdle{0%,100%{transform:translateY(0)}50%{transform:translateY(-1px)}}
    @keyframes atkLunge{0%{transform:translate(0,0) scale(1)}55%{transform:translate(10px,-2px) scale(1.03)}100%{transform:translate(0,0) scale(1)}}
    @keyframes hitShake{0%{transform:translate(0,0)}25%{transform:translate(-2px,0)}55%{transform:translate(2px,0)}100%{transform:translate(0,0)}}

    .fxLayer{position:absolute; inset:0; z-index:2; pointer-events:none}
    /* v14: pixel FX (slash / spark / crit) */
    canvas.fxSprite{position:absolute; width:56px; height:56px; image-rendering: pixelated;
      border:none; border-radius:0; background: transparent; box-shadow:none;
      transform: translate(-50%,-50%);
      filter: drop-shadow(0 10px 14px rgba(0,0,0,.35));
      opacity:0;
      will-change: transform, opacity;
    }
    canvas.fxSlash{mix-blend-mode:screen; animation: fxSlash .24s ease-out forwards}
    canvas.fxClaw{mix-blend-mode:screen; animation: fxClaw .24s ease-out forwards}
    canvas.fxSpark{mix-blend-mode:screen; animation: fxSpark .22s ease-out forwards}
    canvas.fxCrit{mix-blend-mode:screen; animation: fxCrit .34s ease-out forwards}

    @keyframes fxSlash{
      0%{opacity:0; transform:translate(-50%,-50%) scale(.70) rotate(-22deg)}
      35%{opacity:1}
      100%{opacity:0; transform:translate(-50%,-50%) scale(1.18) rotate(12deg)}
    }
    @keyframes fxClaw{
      0%{opacity:0; transform:translate(-50%,-50%) scale(.72) rotate(18deg)}
      35%{opacity:1}
      100%{opacity:0; transform:translate(-50%,-50%) scale(1.16) rotate(-10deg)}
    }
    @keyframes fxSpark{
      0%{opacity:0; transform:translate(-50%,-50%) scale(.45) rotate(0deg)}
      25%{opacity:1; transform:translate(-50%,-50%) scale(1.08) rotate(0deg)}
      100%{opacity:0; transform:translate(-50%,-50%) scale(1.35) rotate(0deg)}
    }
    @keyframes fxCrit{
      0%{opacity:0; transform:translate(-50%,-50%) scale(.55) rotate(0deg)}
      20%{opacity:1; transform:translate(-50%,-50%) scale(1.05) rotate(6deg)}
      100%{opacity:0; transform:translate(-50%,-50%) scale(1.75) rotate(22deg)}
    }
    .floatDmg{position:absolute; font-weight:950; font-size:13px;
      transform: translate(-50%,-50%);
      text-shadow: 0 2px 0 rgba(0,0,0,.45), 0 0 12px rgba(0,0,0,.35);
      animation: floatUp .65s ease-out forwards;
      white-space:nowrap;
    }
    .floatDmg.crit{font-size:15px; filter: drop-shadow(0 0 10px rgba(245,158,11,.35))}
    

    @keyframes floatUp{0%{opacity:0; transform:translate(-50%,-30%)}15%{opacity:1}100%{opacity:0; transform:translate(-50%,-120%)}}

    /* v30: bombastic battle FX (camera / fullscreen canvas / flash) */
    .battleViewport .battleStage{
      --camX: 0px; --camY: 0px; --camZ: 1; --dash: 120px;
      transform: translate3d(var(--camX), var(--camY), 0) scale(var(--camZ));
      transform-origin: 50% 70%;
      will-change: transform;
    }
    .battleViewport .battleStage{display:block; margin:0;}
    .battleViewport .battleStage .actor{position:absolute; bottom:10px; z-index:2; display:flex; align-items:flex-end}
    .battleViewport .battleStage .actor.hero{left:28%;}
    .battleViewport .battleStage .actor.enemy{right:24%;}
    @media (max-width: 520px){
      .battleViewport .battleStage .actor.hero{left:24%;}
      .battleViewport .battleStage .actor.enemy{right:20%;}
    }

    .battleFxFull{position:absolute; inset:0; width:100%; height:100%; z-index:3; pointer-events:none}
    .battleFlash{position:absolute; inset:-10%; z-index:5; pointer-events:none; opacity:0;
      background:
        radial-gradient(280px 160px at 50% 60%, hsla(var(--flashHue,190), 100%, 70%, .70), rgba(255,255,255,0) 65%),
        radial-gradient(520px 260px at 50% 60%, hsla(calc(var(--flashHue,190) + 40), 100%, 70%, .22), rgba(255,255,255,0) 70%);
      mix-blend-mode: screen;
    }
    .battleFlash.on{animation: battleFlash .20s ease-out forwards}
    @keyframes battleFlash{0%{opacity:0}18%{opacity:1}100%{opacity:0}}

    .fxLayer{z-index:4}
    .battleStage.hitstop .actor{animation-play-state:paused !important}
    .battleStage.noAnim .actor{animation:none !important; transition:none !important;}
    .battleStage.noAnim .battleFxFull{display:none !important;}
    .battleStage.noAnim .battleFlash{display:none !important;}
    .battleStage.noAnim canvas.fxSprite{display:none !important;}

    /* stronger dash / hit */
    .battleStage .actor.hero.atk{animation: heroDash .30s cubic-bezier(.12,.88,.18,1) 1}
    .battleStage .actor.enemy.atk{animation: enemyDash .30s cubic-bezier(.12,.88,.18,1) 1}
    @keyframes heroDash{0%{transform:translate3d(0,0,0) scale(1)}35%{transform:translate3d(var(--dash),-7px,0) scale(1.07)}100%{transform:translate3d(0,0,0) scale(1)}}
    @keyframes enemyDash{0%{transform:translate3d(0,0,0) scale(1)}35%{transform:translate3d(calc(var(--dash) * -1),-5px,0) scale(1.04)}100%{transform:translate3d(0,0,0) scale(1)}}

    .battleStage .actor.hit{animation: hitShake2 .28s ease-out 1; filter: brightness(1.15) saturate(1.15)}
    @keyframes hitShake2{
      0%{transform:translate3d(0,0,0)}
      18%{transform:translate3d(-6px,0,0) rotate(-1deg)}
      42%{transform:translate3d(7px,-2px,0) rotate(1deg)}
      70%{transform:translate3d(-4px,1px,0) rotate(-.5deg)}
      100%{transform:translate3d(0,0,0)}
    }

    /* make small FX sprites & numbers read stronger */
    canvas.fxSprite{width:84px; height:84px; filter: drop-shadow(0 10px 14px rgba(0,0,0,.38));}
    canvas.fxCrit{animation: fxCrit .42s ease-out forwards}
    .floatDmg{font-size:14px}
    .floatDmg.crit{font-size:18px}

    /* v13: ‰ΩôÁôΩ„ÇíÂ∞ë„ÅóË©∞„ÇÅ„Çã */

    .row{gap:8px}
    .enemybox{padding:10px}

    /* v26: È†≠Êõ∏„ÅÆÊìç‰ΩúÁæ§„ÇíÁ∞°Áï•Âåñ */
    header .wrap{padding:8px 10px 10px;}
    header .brand b{font-size:15px; letter-spacing:.6px}
    header .controls{gap:6px}
    header .controls button,
    header .controls select{
      padding:8px 10px;
      border-radius:10px;
      font-size:11px;
      box-shadow:none;
    }
    header .controls button.small{padding:5px 7px}
    header .controls .tag{font-size:10px; padding:2px 6px}
    header .locBadge{padding:4px 8px; font-size:11px}

    /* v33: È†≠Êõ∏„ÅØÈöéÂ±§/ÈÉ®Â±ã„ÇíË°®Á§∫„Åõ„Åö„ÄÅ‰Ωç/ÁµåÈ®ì/Èáë„Å†„Åë„ÇíÁ∞°Áï•Ë°®Á§∫ */
    header .topbar{align-items:flex-start}
    header .locPanel{display:flex; flex-direction:column; align-items:flex-end; gap:4px; min-width:160px}
    header .locBadge{padding:4px 8px; font-size:10px}
    header .locBadge b{min-width:unset; text-align:right; font-variant-numeric: tabular-nums}
    header .locBadge b.statLine{display:flex; gap:10px; flex-wrap:nowrap; justify-content:flex-end; align-items:center}
    header .locBadge b.statLine span{white-space:nowrap; display:inline-block; text-align:right; overflow:hidden; text-overflow:ellipsis; max-width: 22ch}
    header #lvExp{min-width:6ch}
    header #expText{min-width:16ch}
    header #goldText{min-width:10ch}
    @media (max-width: 520px){ header #expText{min-width:14ch} header #goldText{min-width:9ch} }
    header .bar.headerBar{height:6px; width:160px; max-width:40vw}
    @media (max-width: 520px){ header .locPanel{min-width:unset} header .bar.headerBar{width:140px} }

    /* v35: Ë°åËÄÖÊû†„Å´ÂäüÂæ≥Áõ∏„ÇíÂÜÖÂåÖ */
    .heroCombat{margin-top:8px}
    .atkDefGrid.compact{gap:8px; margin-top:2px}
    .atkDefGrid.compact .k2{font-size:10px}
    .atkDefGrid.compact .v2{font-size:15px; line-height:1.05}
    .sub.combatSub{margin-top:4px; font-size:11px; opacity:.95}
    @media (max-width: 520px){
      .atkDefGrid.compact .v2{font-size:14px}
      .sub.combatSub{font-size:10px}
    }

    /* v26: Ë°åËÄÖÊû†ÂÜÖ„ÅÆ‰Ωç/Ë°å„ÇíÂ∞è„Åï„Åè */
    .sub.subTiny{font-size:10px; margin-top:2px}
    .bar.barSlim{height:8px}



    /* v40: ÁîªÈù¢ÂÖ®‰Ωì„ÇíÁ∏¶ÊñπÂêë„Å´Â∞ë„ÅóÂúßÁ∏ÆÔºà‰ΩôÁôΩ„ÇíÂâä„Å£„Å¶Â∑ªÂèñÈáè„ÇíÊ∏õ„Çâ„ÅôÔºâ */
    header .wrap{padding:6px 10px 6px;}
    .wrap{padding:6px 10px 8px;}
    .grid{gap:8px; margin-top:8px;}
    .row{gap:8px;}
    .card h2{padding:10px 12px;}
    .card .body{padding:8px 10px;}

    button, select{padding:6px 9px; border-radius:11px;}
    button.small{padding:5px 8px;}
    input[type="text"]{padding:6px 9px;}

    .stat{padding:8px 10px;}
    .enemybox{padding:10px;}
    .bigStat{padding:8px;}
    .heroCombat{margin-top:6px;}

    .hr{margin:6px 0;}

    .log{height:205px; padding:8px;}
    .list{max-height:520px;}

    .battleViewport .battleStage{padding:8px 10px;}
    @media (max-width: 520px){ .battleViewport .battleStage{padding:7px 8px;} }
    .battleStage{padding:8px 10px; margin-top:8px;}

    body{line-height:1.20;}
    /* v60: Ë°åËÄÖÊÉÖÂ†±ÈÖçÁΩÆÔºàÂêçÂâç+‰Ωç/ExpÂêåÂàó / Ê∞ó„ÅØÊ®ôÂè≥„Å´Êï∞ÂÄ§ / ÊÆã„Çä1Ë°åÔºâ */
    .heroHeader{display:flex; align-items:center; gap:10px;}
    .heroHeadText{min-width:0; flex:1 1 auto;}

    .heroNameRow{display:flex; align-items:center; gap:10px; min-width:0;}
    .heroName{font-weight:1000; font-size:14px; letter-spacing:.2px; white-space:nowrap; overflow:hidden; text-overflow:ellipsis; min-width:0;}
    .heroNameSide{display:flex; align-items:center; gap:10px; flex:0 0 auto; font-size:11px; color:var(--text); opacity:.82; font-variant-numeric: tabular-nums; white-space:nowrap;}
    .heroNameSide span{white-space:nowrap;}

    .heroExpBar{margin-top:5px;}

    .heroHpBlock{margin-top:8px;}
    .heroHpBlock .hpRow{display:flex; justify-content:space-between; align-items:center; font-variant-numeric: tabular-nums;}
    .heroHpBlock .hpLabel{font-weight:950; font-size:12px; color:var(--muted); letter-spacing:.2px;}
    .heroHpBlock .hpVal{font-weight:1000; font-size:12px; color:var(--text);}

    .heroMetaOneLine{
      margin-top:8px;
      display:flex;
      gap:8px;
      row-gap:6px;
      flex-wrap:wrap;
      align-items:center;
      overflow:visible;
      padding-bottom:0;
      font-size:10.5px;
      color:var(--text); opacity:.88;
      white-space:normal;
      font-variant-numeric: tabular-nums;
    }
    .heroMetaOneLine span{
      flex:0 0 auto;
      white-space:nowrap;
      padding:2px 6px;
      border:1px solid var(--line);
      border-radius:999px;
      background: linear-gradient(180deg, rgba(125,211,252,.06), rgba(0,0,0,0));
    }
    .heroMetaOneLine #luckText{flex:0 0 auto; white-space:nowrap; overflow:hidden; text-overflow:ellipsis; line-height:1.1;}
    .heroMetaOneLine b{color:inherit; font-weight:1000;}

    /* v61: ÈáçË¶Å„Å™Êï∞ÂÄ§„ÇíÂ§™Â≠óÔºàÂ≠óÂ§ß„ÅØ„Åù„ÅÆ„Åæ„ÅæÔºâ */
    #lvExp, #expText, #hpText, #goldText,
    #karmaText, #satoriText,
    #critText, #dpsText, #spdText, #luckText,
    #enemyHpText, #enemyStatsText,
    #upgText, #upgCostText, #gupgText, #gupgCostText,
    #invCount{font-weight:1000;}

    .heroMetaOneLine::-webkit-scrollbar{height:6px;}
    .heroMetaOneLine::-webkit-scrollbar-thumb{background:rgba(154,168,183,.25); border-radius:999px;}
    .heroMetaOneLine::-webkit-scrollbar-track{background:rgba(0,0,0,.15); border-radius:999px;}
    @media (max-width: 520px){ .heroMetaOneLine{font-size:9.8px; gap:8px;} }

    /* v41: Ê≥ïÂÖ∑Â∫ß„Çí„Åï„Çâ„Å´Á∏¶ÂúßÁ∏Æ */
    .equipSlots{gap:4px;}
    .equipSlots .slot{padding:4px;}
    .equipSlots .slotHead{gap:6px;}
    .equipSlots .slot .v{margin-top:1px; line-height:1.15;}

    /* v46: ÂÖ≠Âç∞„ÅÆÊ¨†Áâá‰ªò‰∏éÊúÄÂ§ß8 / Ëá™ÂãïÂä†ÊåÅ„ÅÆÁ∏Å60ÈÅéÂ§ßË©ï‰æ°ÊäëÂà∂ */
    .equipSlots .eqPerf{
      margin-top:2px;
      font-size:10px;
      line-height:1.15;
      color:var(--muted);
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
      font-variant-numeric: tabular-nums;
    }
    @media (max-width: 520px){ .equipSlots .eqPerf{font-size:9.5px;} }



/* ---- ÂØÜÊïôÊã°ÂºµÔºöÊõºËçºÁæÖ / ÁúüË®Ä / Ê•≠„ÉªÊÇü„Çä ---- */
body:before{
  content:"";
  position:fixed; inset:-25vmax;
  background:
    radial-gradient(circle at 20% 10%, rgba(245,158,11,.10), rgba(0,0,0,0) 45%),
    radial-gradient(circle at 80% 35%, rgba(167,139,250,.10), rgba(0,0,0,0) 55%),
    radial-gradient(circle at 40% 90%, rgba(125,211,252,.09), rgba(0,0,0,0) 50%),
    repeating-conic-gradient(from 0deg, rgba(255,255,255,.03) 0 7deg, rgba(0,0,0,0) 7deg 14deg);
  filter: blur(0.5px);
  opacity: .55;
  pointer-events:none;
  z-index:-1;
  animation: mandalaSpin 140s linear infinite;
}
@keyframes mandalaSpin{ from{transform:rotate(0deg)} to{transform:rotate(360deg)} }

.battleViewport:before{
  content:"";
  position:absolute; inset:-30%;
  background:
    radial-gradient(circle at 50% 55%, rgba(255,255,255,.06), rgba(0,0,0,0) 45%),
    repeating-conic-gradient(from 0deg, rgba(245,158,11,.07) 0 8deg, rgba(0,0,0,0) 8deg 16deg);
  opacity:.55;
  transform-origin:center;
  pointer-events:none;
  animation: mandalaSpin 70s linear infinite;
}
.battleStage{ position:relative; }

.mantraPulse{
  position:absolute; left:50%; top:50%; transform:translate(-50%,-50%);
  width:min(520px, 120%); aspect-ratio:1/1;
  border-radius:999px;
  border:1px solid rgba(245,158,11,.45);
  box-shadow: 0 0 0 0 rgba(245,158,11,.30), 0 0 60px rgba(167,139,250,.15);
  opacity:0;
  animation: mantraPulse 1.05s ease-out forwards;
  pointer-events:none;
}
@keyframes mantraPulse{
  0%{opacity:0; transform:translate(-50%,-50%) scale(.72)}
  15%{opacity:.85}
  100%{opacity:0; transform:translate(-50%,-50%) scale(1.12)}
}
.seedGlyph{
  position:absolute; left:50%; top:44%; transform:translate(-50%,-50%);
  font-weight:950;
  letter-spacing:.08em;
  text-shadow: 0 10px 30px rgba(0,0,0,.55);
  opacity:0;
  animation: seedGlyph 1.05s ease-out forwards;
  pointer-events:none;
  user-select:none;
}
@keyframes seedGlyph{
  0%{opacity:0; transform:translate(-50%,-50%) scale(.92)}
  18%{opacity:.95}
  100%{opacity:0; transform:translate(-50%,-50%) scale(1.06)}
}

.pathGrid{display:grid; grid-template-columns:repeat(4, minmax(0,1fr)); gap:8px;}
@media (max-width: 520px){ .pathGrid{grid-template-columns:repeat(2, minmax(0,1fr));} }

#karmaText, #satoriText{font-variant-numeric: tabular-nums;}
#karmaText{color: rgba(251,113,133,.95);}
#satoriText{color: rgba(245,158,11,.95);}

#btnChant.ready{ box-shadow: 0 0 0 1px rgba(245,158,11,.25), 0 0 18px rgba(245,158,11,.18); }
#btnChant.cooldown{ opacity:.65; }

.codexGrid{display:grid; grid-template-columns:repeat(2, minmax(0,1fr)); gap:10px; margin-top:10px;}
@media (max-width: 720px){ .codexGrid{grid-template-columns:1fr;} }
.codexCard{background: rgba(9,14,22,.45); border:1px solid var(--line); border-radius:14px; padding:10px;}
.codexCard .k{font-size:11px; color:var(--muted)}
.codexCard .v{margin-top:4px; font-weight:950; font-size:12px; color:var(--text)}
.codexCard .p{margin-top:6px; font-size:11px; color:var(--muted); white-space:pre-line; line-height:1.45}


/* --- ÂØÜÊïôÊºîÂá∫ÔºöÊõºËçºÁæÖÔºàCSSÔºâ --- */
.battleStage::before{
  content:"";
  position:absolute;
  inset:-90px;
  border-radius:999px;
  background:
    radial-gradient(circle at 50% 50%, rgba(245,158,11,.10) 0%, rgba(245,158,11,0) 42%),
    radial-gradient(circle at 50% 50%, rgba(167,139,250,.10) 0%, rgba(167,139,250,0) 58%),
    repeating-conic-gradient(from 0deg,
      rgba(167,139,250,.22) 0 10deg,
      rgba(56,189,248,.12) 10deg 20deg,
      rgba(245,158,11,.16) 20deg 30deg,
      rgba(167,139,250,.18) 30deg 40deg
    );
  mask: radial-gradient(circle at 50% 50%, rgba(0,0,0,.0) 0 22%, rgba(0,0,0,1) 30%, rgba(0,0,0,1) 68%, rgba(0,0,0,.0) 78%);
  opacity:.16;
  pointer-events:none;
  z-index:0;
  animation: mandalaSpin 120s linear infinite;
}
.battleStage .actor,
.battleStage #battleFx,
.battleStage #battleFxFull,
.battleStage #battleFlash,
.battleStage canvas{ position:relative; z-index:1; }

html[data-realm="hell"] .battleStage::before{ opacity:.17; filter:saturate(1.15) hue-rotate(-10deg); }
html[data-realm="hungry"] .battleStage::before{ opacity:.16; filter:saturate(1.05) hue-rotate(8deg); }
html[data-realm="animal"] .battleStage::before{ opacity:.15; filter:saturate(0.95) hue-rotate(20deg); }
html[data-realm="asura"] .battleStage::before{ opacity:.18; filter:saturate(1.25) hue-rotate(-18deg); }
html[data-realm="human"] .battleStage::before{ opacity:.14; filter:saturate(0.90) hue-rotate(0deg); }
html[data-realm="deva"] .battleStage::before{ opacity:.16; filter:saturate(1.05) hue-rotate(30deg); }



  /* --- Realm ambience (particles + tint) --- */
  :root{ --realmHue: 210; --realmHue2: 180; }
  body:after{
    content:"";
    position:fixed; inset:-18vh -18vw;
    background:
      radial-gradient(900px 620px at 18% 12%, hsla(var(--realmHue), 70%, 45%, 0.14) 0%, transparent 62%),
      radial-gradient(980px 680px at 82% 28%, hsla(var(--realmHue2), 70%, 40%, 0.10) 0%, transparent 66%);
    mix-blend-mode: screen;
    pointer-events:none;
    z-index:-1;
  }
  #auraCanvas{
    position:fixed; inset:0;
    width:100vw; height:100vh;
    pointer-events:none;
    z-index:0;
    opacity:0.82;
  }
  header, main, .modal{ position:relative; z-index:1; }

  /* ‰∫åÊõºËçºÁæÖ„ÅÆ‚ÄúÊ±∫ÂÆö„Å•„Åë‚ÄùÊºîÂá∫ÔºöËÉåÊôØÊñáÊßòÂ∑ÆÂàÜ */
  html[data-mandala="kongo"] .battleStage::after{
    content:"";
    position:absolute; inset:-10px;
    background:
      repeating-conic-gradient(from 10deg, rgba(255,255,255,0.10) 0 7deg, rgba(0,0,0,0) 7deg 15deg),
      radial-gradient(600px 420px at 50% 40%, rgba(255,255,255,0.10), transparent 60%);
    opacity:0.10;
    mix-blend-mode: overlay;
    pointer-events:none;
  }
  html[data-mandala="taizo"] .battleStage::after{
    content:"";
    position:absolute; inset:-10px;
    background:
      repeating-radial-gradient(circle at 50% 50%, rgba(255,255,255,0.09) 0 2px, rgba(0,0,0,0) 2px 10px),
      radial-gradient(620px 440px at 50% 45%, rgba(255,255,255,0.08), transparent 65%);
    opacity:0.11;
    mix-blend-mode: overlay;
    pointer-events:none;
  }


    /* Ê≥ïÂÖ∑Â∫´‰∏ãÔºöË°åÊåÅ„ÉªÂç∞Â•ëÔºàÊ∞∏Á∂öÔºâ„ÇíÊï¥Âàó */
    .invBottomLabel{
      color:var(--muted);
      font-size:11px;
      letter-spacing:.12em;
      text-transform:none;
      margin-top:2px;
      opacity:.95;
    }
    /* split „ÇíÊ≥ïÂÖ∑Â∫´Áî®„Å´ÊúÄÈÅ©ÂåñÔºà‰∏≠ÈñìÂπÖ„ÅßÁ™ÆÂ±à„Å´„Å™„Çâ„Å™„ÅÑÔºâ */
    .invSubGrid{ grid-template-columns: 1fr; }
    @media (min-width: 920px){ .invSubGrid{ grid-template-columns: 1fr 1fr; } }
    .invSubGrid .stat{ margin-top:0 !important; }
    .invSubGrid .warnBox{ margin-top:8px; }

    /* Ê≥ïÂÖ∑Â∫´‰∏ãÔºöÊ®™Èï∑„ÅÆÊû†„ÇíÁ∏¶Á©ç„Åø */
    .invWideStack{
      display:flex;
      flex-direction:column;
      gap:10px;
    }
    .invWideStack .stat{ margin-top:0 !important; }
    
    /* FINAL OVERRIDE: keep search text clear of icons even under compact padding rules */
    .searchWrap input[type="text"]{
      padding-left: 36px;
      padding-right: 40px;
    }
</style>
</head>
<body>
  <canvas id="auraCanvas" aria-hidden="true"></canvas>
<header>
  <div class="wrap">
    <div class="topbar">
      <div class="brand">
        <b>ÊõºËçºÁæÖËø∑ÂÆÆË®ò ‚Äî ÂÖ≠Âç∞Â∑°Á§º</b>
      </div>
      <div class="controls">
        <button id="btnExplore" class="accent">‚ñ∂ Â∑°Á§ºÈñãÂßã</button>
        <button id="btnPause" class="ghost">‚è∏ ‰ºëË°å</button>
        <label class="tag">ËøÖË°å
          <select id="speedSel">
            <option value="1" selected>1ÂÄç</option>
            <option value="2">2ÂÄç</option>
            <option value="4">4ÂÄç</option>
            <option value="8">8ÂÄç</option>
<option value="64" disabled>MAXÔºàÂÖ≠Âç∞ 0/6Ôºâ</option>
</select>
        </label>
        <label class="tag">Ëá™Âãï
          <select id="autoSel">
            <option value="0">Ê≠¢</option>
            <option value="1" selected>È°ï</option>
          </select>
        </label>
        <button id="btnChant" class="accent">üïâ ÁúüË®Ä</button>
        <button id="btnCodex" class="ghost">ü™∑ ÊõºËçºÁæÖÂ∏≥</button>
<button id="btnSave" class="ghost">üíæ Ë®òÈå≤</button>
        <button id="btnReset" class="ghost">üóë Ëº™Âªª</button>
      </div>
    </div>
  </div>
</header>

<main class="wrap">
  <div class="grid">

    <section class="card">
      <h2>‰øÆË°å <span id="runInfo">‚Äî</span></h2>
      <div class="body">
        <div class="battleViewport logOnly" aria-label="Ë™ø‰ºèË®ò">
<div class="log battleLog" id="log" aria-label="Ë™ø‰ºèË®ò"></div>
                <div class="battleStage wide" id="battleStage" aria-label="Ë™ø‰ºè„ÅÆÁÇπÁµµË°®Á§∫" hidden>
                  <div class="actor hero" id="heroActor">
                    <canvas id="heroStageSprite" class="pxSprite pxStage" width="64" height="64" aria-label="Ë°åËÄÖ(Ë™ø‰ºè)"></canvas>
                  </div>
                  <div class="actor enemy" id="enemyActor">
                    <canvas id="enemyStageSprite" class="pxSprite pxStage" width="64" height="64" aria-label="È≠î(Ë™ø‰ºè)"></canvas>
                  </div>
                  
                  <canvas id="battleFxFull" class="battleFxFull" width="1" height="1" aria-hidden="true"></canvas>
                  <div id="battleFlash" class="battleFlash" aria-hidden="true"></div>
                  <div class="fxLayer" id="battleFx" aria-hidden="true"></div>
                </div>
          <div class="deathOverlay" id="deathOverlay" style="display:none;" aria-label="Ë™ø‰ºè‰∏çËÉΩÂºèÊ¨°Á¨¨">
            <div class="deathPanel">
              <div class="deathTitle">Ë™ø‰ºè‰∏çËÉΩ</div>
              <div class="footerNote" id="deathNote" style="display:none;"></div>
              <button id="btnRevive" class="bad">üíÄ Âæ©Ê¥ª</button>
</div>
          </div>
        </div>

        <div class="row">
          <div class="col">
            <div class="statgrid stack">

<div class="stat">
                <div class="k">Ë°åËÄÖ„ÅÆÊÉÖÂ†±</div>
                <div class="hr"></div>

                <div class="heroHeader">
                  <canvas id="heroSprite" class="pxSprite pxHero" width="64" height="64" aria-label="Ë°åËÄÖ"></canvas>
                  <div class="heroHeadText">
                    <div class="heroNameRow">
                      <div class="heroName" id="heroName">‚Äî</div>
                      <div class="heroNameSide">
                        <span id="lvExp">‚Äî</span>
                        <span id="expText">‚Äî</span>
                      </div>
                    </div>
                    <div class="bar barSlim heroExpBar"><div class="fill" id="expBar"></div></div>
                  </div>
                </div>

                <div class="heroHpBlock">
                  <div class="hpRow"><span class="hpLabel">ÂëΩ</span><span class="hpVal" id="hpText">‚Äî</span></div>
                  <div class="bar"><div class="fill" id="hpBar"></div></div>
                </div>

                <div class="heroMetaOneLine" aria-label="Ë°åËÄÖÂäüÂæ≥Áõ∏Ë©≥Á¥∞">
                  <span id="goldText">‚Äî</span>
                  <span>Êñ≠ <b id="atkVal">‚Äî</b></span>
                  <span>Êàí <b id="defVal">‚Äî</b></span>
                  <span id="critText">‚Äî</span>
                  <span id="dpsText">‚Äî</span>
                  <span id="spdText">‚Äî</span>
                  <span id="luckText">‚Äî</span>
                  <span id="karmaText">‚Äî</span>
                  <span id="satoriText">‚Äî</span>
                </div>
              </div>
<div class="enemybox">
                <div class="enemyTitle">
                  <div class="enemyLeft">
                    <canvas id="enemySprite" class="pxSprite pxEnemy" width="64" height="64" aria-label="È≠î"></canvas>
                    <div class="enemyText">
                      <div class="enemyBiome"><span class="tag mini">ÂÖ≠ÈÅì <b id="biomeText">‚Äî</b></span></div>
                      <div class="enemyname" id="enemyName">‚Äî</div>
                    </div>
                  </div>
                  <div class="enemyFlags">
                    <span class="tag" id="safeTag" style="display:none;"><b class="safe">ÂÆâÂÖ®</b> <span id="safeText">‚Äî</span></span>
                    <span class="tag" id="eliteTag" style="display:none;"><b class="elite">È≠îËªç</b></span>
                    <span class="tag" id="bossTag" style="display:none;"><b class="boss">Â§©È≠î</b></span>
                  </div>
                </div>
                <div style="margin-top:10px;">
                  <div class="k" style="color:var(--muted); font-size:11px;">È≠îÂëΩ</div>
                  <div class="bar"><div class="fill" id="enemyHpBar"></div></div>
                  <div class="sub oneLine"><span id="enemyHpText">‚Äî</span><span id="enemyStatsText">‚Äî</span></div>
                </div>
              </div>

<div class="stat tight">
                    <div class="k">Ê≥ïÂÖ∑Â∫ß</div>
                    <div class="equipSlots">
                      <div class="slot">
                        <div class="slotHead">
                          <div class="k">Ê≠¶Âô®</div>
                          <button class="lockBtn" id="lockWeapon" title="Ëá™ÂãïÂä†ÊåÅ„ÇíÂ∞ÅÂç∞">üîì</button>
                          <span class="rar common" id="eqWeaponRar">‚Äî</span>
                          <span class="pill" id="eqWeapon‰Ωç">‚Äî</span>
                        </div>
                        <div class="v vIcon"><canvas id="eqWeaponIcon" class="pxSprite pxMini" width="64" height="64" aria-label="Ê≠¶Âô®"></canvas><span id="eqWeapon">‚Äî</span></div>
                        <div class="eqPerf" id="eqWeaponPerf">‚Äî</div>
                      </div>
                      <div class="slot">
                        <div class="slotHead">
                          <div class="k">Èò≤ÂÖ∑</div>
                          <button class="lockBtn" id="lockArmor" title="Ëá™ÂãïÂä†ÊåÅ„ÇíÂ∞ÅÂç∞">üîì</button>
                          <span class="rar common" id="eqArmorRar">‚Äî</span>
                          <span class="pill" id="eqArmor‰Ωç">‚Äî</span>
                        </div>
                        <div class="v vIcon"><canvas id="eqArmorIcon" class="pxSprite pxMini" width="64" height="64" aria-label="Èò≤ÂÖ∑"></canvas><span id="eqArmor">‚Äî</span></div>
                        <div class="eqPerf" id="eqArmorPerf">‚Äî</div>
                      </div>
                      <div class="slot">
                        <div class="slotHead">
                          <div class="k">ÁìîÁèû</div>
                          <button class="lockBtn" id="lockAcc" title="Ëá™ÂãïÂä†ÊåÅ„ÇíÂ∞ÅÂç∞">üîì</button>
                          <span class="rar common" id="eqAccRar">‚Äî</span>
                          <span class="pill" id="eqAcc‰Ωç">‚Äî</span>
                        </div>
                        <div class="v vIcon"><canvas id="eqAccIcon" class="pxSprite pxMini" width="64" height="64" aria-label="ÁìîÁèû"></canvas><span id="eqAcc">‚Äî</span></div>
                        <div class="eqPerf" id="eqAccPerf">‚Äî</div>
                      </div>
                    </div>
                  </div>
</div>



<div class="hr"></div>

<div class="stat" style="margin-top:10px;">
  <div class="k">Ë≠∑Êë©ÔºàÊµÑÂåñÔºâ</div>
  <div class="sub" style="margin-top:6px;">ÊÇ™Ê•≠„ÅÆÂÅè„Çä„ÇíÁÑº„ÅçÊ∏Ö„ÇÅ„Åæ„ÅôÔºàÊ•≠„Çí0ÊñπÂêë„Å∏ÂØÑ„Åõ„Åæ„ÅôÔºâ„ÄÇ</div>
  <div style="display:flex; gap:8px; flex-wrap:wrap; margin-top:8px;">
    <button class="small accent" id="btnPurify">üî• Ë≠∑Êë©</button>
  </div>
  <div class="sub" style="margin-top:8px;">
    <span id="purifyText">‚Äî</span>
  </div>
</div>

          </div>
        </div>

      </div>
    </section>

    <section class="card">
      <h2>Ê≥ïÂÖ∑Â∫´ <span id="invCount">‚Äî</span></h2>
      <div class="body">
        
        <div class="invTop">
          <div class="invTabsWrap">
            <div class="tabs" id="tabs">
              <button class="tabBtn active" data-tab="all">„Åô„Åπ„Å¶</button>
              <button class="tabBtn" data-tab="weapon">Ê≠¶Âô®</button>
              <button class="tabBtn" data-tab="armor">Èò≤ÂÖ∑</button>
              <button class="tabBtn" data-tab="accessory">ÁìîÁèû</button>
            </div>
          </div>

          <div class="invTools">
            <div class="searchWrap" role="search">
              <span class="searchIcon" aria-hidden="true">üîç</span>
              <input id="search" type="text" placeholder="Ê§úÁ¥¢Ôºà‰æãÔºöÊ≥ïÂÖ∑Âêç / Âá°ÂìÅ / Èò≤ÂÖ∑ / ‰ΩìÂäõ / ÈôçÈ≠îÔºâ" />
              <button id="btnClearSearch" class="iconBtn" type="button" title="Ê§úÁ¥¢„ÇíÊ∂à„Åô">√ó</button>
            </div>

            <select id="sortSel" title="‰∏¶„Å≥Êõø„Åà">
              <option value="rar">ÂÆùÊ†º</option>
              <option value="ilv" selected>Ê≥ïÂÖ∑‰Ωç</option>
              <option value="slot">Â∫ß</option>
              <option value="power">Âº∑„Åï</option>
            </select>
<button id="btnSellAll" class="small bad">üßπ ÂÖ®Â∏ÉÊñΩ</button>
          </div>
        </div>

        <div class="invFilters" aria-label="Â∏ÉÊñΩ„Éï„Ç£„É´„Çø">
          <label class="checkPill">
            <input type="checkbox" id="autoSellOn"> <span>Ëá™ÂãïÂ∏ÉÊñΩ</span>
          </label>

          <div class="filterGroup">
            <span class="fLabel">ÂÆùÊ†º‰∏äÈôê</span>
            <select id="autoSellRarMax" title="ÊåáÂÆöÂÆùÊ†º‰ª•‰∏ãÔºàÂá°ÂìÅ„ÄúÔºâ„ÇíÂç≥Â∏ÉÊñΩ">
              <option value="none">„Å™„Åó</option>
              <option value="common" selected>Âá°ÂìÅ„ÅÆ„Åø</option>
              <option value="uncommon">ÂñÑÂìÅ„Åæ„Åß</option>
              <option value="rare">Â¶ôÂìÅ„Åæ„Åß</option>
              <option value="epic">ÁßòÂÆù„Åæ„Åß</option>
              <option value="legendary">ËÅñÂÆù„Åæ„Åß</option>
              <option value="unique">ÂÖ≠Âç∞„ÅÆÊ¨†Áâá„Åæ„Åß</option>
            </select>
          </div>

          <label class="checkPill" title="Âä†ÊåÅ‰∏≠„Çà„ÇäÂº±„ÅÑÂä†ÊåÅ„ÇíÂç≥Â∏ÉÊñΩÔºàÂä†ÊåÅ„ÅåÁ©∫„ÅÆÂ∫ß„ÅØÂ£≤„Çâ„Å™„ÅÑÔºâ">
            <input type="checkbox" id="autoSellUseEq"> <span>Âä†ÊåÅÊØî</span>
          </label>

          <div class="filterGroup pct" title="Âä†ÊåÅÊØî„ÅÆÈñæÂÄ§Ôºà%Ôºâ">
            <span class="fLabel">&lt;</span>
            <input id="autoSellEqPct" type="number" min="1" max="100" step="1" value="90" />
            <span class="fLabel">%</span>
          </div>

          <label class="checkPill" title="‰ΩúÂãï‰∏≠„ÄÅÂÖ≠Âç∞„ÅÆÊ¨†Áâá„ÅØËá™ÂãïÂ∏ÉÊñΩ„Åó„Åæ„Åõ„ÇìÔºàÊúÄÂ§ßÂÆùÊ†º„Å´ÂÖ≠Âç∞„ÅÆÊ¨†Áâá„ÇíÈÅ∏„Çì„Å†Â†¥Âêà„ÇíÈô§„ÅèÔºâ">
            <input type="checkbox" id="autoSellProtectUnique" checked> <span>ÂÖ≠Âç∞„ÅÆÊ¨†Áâá‰øùË≠∑</span>
          </label>
        </div>
<div class="list" id="invList"></div>
        <div class="hr"></div>
        <div class="invBottomLabel">Ë°åÊåÅ„Éª‰ºΩËóçÔºàÂäüÂæ≥Ôºâ</div>
        <div class="invWideStack" style="margin-top:8px;">
<div class="stat">
                  <div class="k">Ë°åÊåÅÂº∑ÂåñÔºàÂäüÂæ≥Ôºâ</div>
                  <div class="sub" style="margin-top:6px; display:flex; gap:8px; align-items:center; flex-wrap:wrap;">
                    <span style="color:var(--muted); font-size:11px;">‰∏ÄÊã¨Ë≥ºÂÖ•</span>
                    <select id="upgBulkSel">
                      <option value="1" selected>√ó1</option>
                      <option value="10">√ó10</option>
                      <option value="100">√ó100</option>
                      <option value="1000">√ó1000</option>
                      <option value="10000">√ó10000</option>
                    </select>
                  </div>
                  <div style="display:flex; gap:8px; flex-wrap:wrap; margin-top:8px;">
                    <button class="small" data-upg="str">Á≤æÈÄ≤ +1</button>
                    <button class="small" data-upg="vit">ÂøçËæ± +1</button>
                    <button class="small" data-upg="def">ÊåÅÊàí +1</button>
                    <button class="small" data-upg="luck">Á∏Å +1</button>
                  </div>
                  <div class="sub" style="margin-top:8px;">
                    <span id="upgText">‚Äî</span>
                    <span id="upgCostText">‚Äî</span>
                  </div>
                </div>





        </div>
        <div class="hr"></div>
        <div class="stat" style="margin-top:10px;">
          <div class="k">Ë®òÔºà‰∏äÈÉ®Ôºâ</div>
<div class="sub" style="margin-top:8px;">
            <span id="offlineNote">‚Äî</span>
            <button id="btnOpenChest" class="small" style="display:none;">üéÅ Êú™Êé•Á∂öÂÆùÂáΩ„ÇíÈñã„Åè</button>
          </div>
        </div>

      </div>
    </section>

  </div>



<div class="modalOverlay" id="eventOverlay" role="dialog" aria-modal="true" aria-label="ÂØÜÊïôÂÑÄÁ§º">
  <div class="modal">
    <h3><span id="eventTitle">‚Äî</span><button id="btnEventClose" class="ghost">√ó</button></h3>
    <div class="content">
      <div id="eventBody" style="white-space:pre-line;">‚Äî</div>
      <div class="miniHr"></div>
      <div id="eventChoices" style="display:flex; gap:8px; flex-wrap:wrap;"></div>
      <div class="footerNote" id="eventFoot">‚Äî</div>
    </div>
  </div>
</div>


<div class="modalOverlay" id="codexOverlay" role="dialog" aria-modal="true" aria-label="ÊõºËçºÁæÖÂ∏≥">
  <div class="modal">
    <h3><span>ü™∑ ÊõºËçºÁæÖÂ∏≥</span><button id="btnCodexClose" class="ghost">√ó</button></h3>
    <div class="content">
      <div id="codexBody">‚Äî</div>
    </div>
  </div>
</div>

</main>

<script>
(() => {
  "use strict";

  let S = null;

  // --------------------
  // Utils
  // --------------------
  const clamp = (v, a, b) => (Number.isFinite(v) ? Math.max(a, Math.min(b, v)) : a);
  const num = (v, fallback=0) => {
    const n = Number(v);
    return Number.isFinite(n) ? n : fallback;
  };
  const int0 = (v, fallback=0) => {
    const n = Math.floor(num(v, fallback));
    return Number.isFinite(n) ? n : fallback;
  };
  const safeDiv = (a,b,fallback=0) => {
    a = num(a, 0);
    b = num(b, 0);
    if (!Number.isFinite(a) || !Number.isFinite(b) || b===0) return fallback;
    const r = a/b;
    return Number.isFinite(r) ? r : fallback;
  };
  const rand = (a, b) => Math.random() * (b - a) + a;
  const randi = (a, b) => Math.floor(rand(a, b + 1));
  const choice = (arr) => arr[randi(0, arr.length - 1)];
  const now = () => Date.now();
  // Device hint: iOS Safari is much slower, so we auto-throttle some effects.
  const IS_IOS = (() => {
    try{
      const ua = navigator.userAgent || "";
      const isAppleTouch = (navigator.platform === "MacIntel" && navigator.maxTouchPoints > 1);
      return /iP(hone|ad|od)/.test(ua) || isAppleTouch;
    }catch(_){ return false; }
  })();


// --------------------
// Simulation speed + Log pace sync
//   - UI shows: 1√ó / 2√ó / ... / MAX
//   - "pace" is a normalized multiplier used by BOTH:
//       * simulation advance rate
//       * log pump rate (cards per second)
//   - This keeps logs and game progression in sync at every speed.
// --------------------
const SPEED_MAX_LABEL = 64;     // MAX label value (lighter than old 256)
const SPEED_ALLOWED = [1, 2, 4, 8, SPEED_MAX_LABEL];

const SPEED_SIM_BASE = 0.05;   // base internal sim speed at pace=1 (1√ó)
const SPEED_PACE_MAX  = 240;     // cap (prevents overload at high speeds)
// NOTE: user requested faster MAX; raised from 30->240

function speedPace(label){
  const sp = Number.isFinite(label) ? Number(label) : (S && S.run ? Number(S.run.speed) : 1);
  const s = (Number.isFinite(sp) && sp > 0) ? sp : 1;

  // Sync logs and simulation. MAX is capped so it won't overload the game.
  if (s >= SPEED_MAX_LABEL) return SPEED_PACE_MAX; // MAX (capped)
  return Math.min(s, SPEED_PACE_MAX);
}


function effectiveSimSpeed(label){
  const pace = speedPace(label);
  return clamp(pace * SPEED_SIM_BASE, 0.01, SPEED_PACE_MAX * SPEED_SIM_BASE);
}
  function effectiveSimSpeedScaled(label){
  const base = effectiveSimSpeed(label);
  try{
    if (IS_IOS && typeof S !== "undefined" && S && S.run){
      const k = Number(S.run._iosSpeedScale);
      if (Number.isFinite(k) && k > 0) return base * k;
    }
  }catch(_){}
  return base;
}

const pct = (x) => `${Math.round(x * 100)}%`;
  const safeUUID = () => {
    try { return crypto.randomUUID(); }
    catch { return "id-" + Math.random().toString(16).slice(2) + "-" + Date.now().toString(16); }
  };

  // Compact number formatting (keeps UI readable even when values explode)
  function fmt(n){
    if (!Number.isFinite(n)) return "‚àû";
    const sign = n < 0 ? "-" : "";
    const a = Math.abs(n);
    const UNITS = [
      { v: 1e21, s: "Z" },
      { v: 1e18, s: "E" },
      { v: 1e15, s: "Qa" },
      { v: 1e12, s: "T" },
      { v: 1e9,  s: "B" },
      { v: 1e6,  s: "M" },
      { v: 1e3,  s: "K" },
    ];
    for (const u of UNITS){
      if (a >= u.v){
        const x = a / u.v;
        const d = x >= 100 ? 0 : x >= 10 ? 1 : 2;
        return sign + x.toFixed(d) + u.s;
      }
    }
    return sign + Math.round(a).toLocaleString("ja-JP");
  }

  // --------------------
  // Content (Biomes / Mods / Items)
  // --------------------

const BIOMES = [
  { key:"hell",      name:"Ëã¶Ë´¶ÁïåÔºàÂú∞ÁçÑÈÅìÔºâ", enemy:["ÁûãÊÅö","ÊÖ¢","Ëº™Âªª","Ê•≠Êûú„ÉªÁï∞ÁÜü","Ëã¶Ëã¶","ÁÖ©ÁÜ±","ÁÖ©ÊÇ©","Ê•≠ÁÅ´"], boss:["Ê•≠Èöú","ÁûãÊÅöÈöèÁú†","Âõ†Êûú„ÅÆÊ≥ï","ÂπªÂåñ"], mult:{hp:1.08, atk:1.10, def:1.02}, loot:{gold:1.12, xp:1.10} },
  { key:"hungry",    name:"ÈõÜË´¶ÁïåÔºàÈ§ìÈ¨ºÈÅìÔºâ", enemy:["Ê∏áÊÑõ","Ê¨≤ÊÑõ","Ë≤™Ê¨≤","ÊüìÊÑõ","‰∏çÊµÑË≤™","Ë≤™Áó¥","Ê¨≤Ë≤™Ëìã","Âü∑Âèñ"], boss:["Ê¨≤Âèñ","Ë¶ãÂèñ","ÊàëË™ûÂèñ","ÊàíÁ¶ÅÂèñ"], mult:{hp:1.00, atk:1.06, def:0.98}, loot:{gold:1.22, xp:1.02} },
  { key:"animal",    name:"ÁÑ°ÊòéÁïåÔºàÁïúÁîüÈÅìÔºâ", enemy:["ÁÑ°Êòé","Áó¥","Â¶ÑÊÉ≥","ÈÇ™Ë¶ã","Êï£‰π±","ÊÑöÁó¥","ÊúâË∫´Ë¶ã","ÁÑ°ÊòéÁ∏ÅË≠ò"], boss:["Ê†πÊú¨ÁÑ°Êòé","ÈöèÁú†","Âõ†ÊûúÈ°õÂÄí","ÂπªÂåñ"], mult:{hp:1.04, atk:1.02, def:1.00}, loot:{gold:1.05, xp:1.05} },
  { key:"asura",     name:"ÁûãÊÖ¢ÁïåÔºà‰øÆÁæÖÈÅìÔºâ", enemy:["ÈóòË´ç","ÁûãÊÅö","ÂÆ≥","ÊÄ®ÊÅ®","ÊÜç","Âøø","Â¢ó‰∏äÊÖ¢","Â´â"], boss:["ÈóòË´çÈöèÁú†","ÁûãÁÅ´","ÂâõÂº∑ÊàëÊÖ¢","ÂπªÂåñ"], mult:{hp:1.06, atk:1.12, def:1.03}, loot:{gold:1.08, xp:1.14} },
  { key:"human",     name:"ÂàÜÂà•ÁïåÔºà‰∫∫ÈñìÈÅìÔºâ", enemy:["ÊàëÂü∑","Âü∑Âèñ","ÂàÜÂà•","Ë≤™Ê¨≤","‰∫îËòä","Ê≠ªÁïè","Áñë","È°õÂÄí"], boss:["ÊµÑÈ°õÂÄí","Â∏∏È°õÂÄí","ÊàëÈ°õÂÄí","Ê•ΩÈ°õÂÄí"], mult:{hp:1.00, atk:1.00, def:1.00}, loot:{gold:1.00, xp:1.00} },
  { key:"deva",      name:"ÊúâÈ†ÇÁïåÔºàÂ§©ÈÅìÔºâ",   enemy:["ÊîæÈÄ∏","ÊÜç","ÊéâÊåô","ÁÑ°Ëâ≤ÁïåÊÑõ","ÊúâÊÑõ","Â§©‰∫∫‰∫îË°∞","ÊúâÈ†Ç","ÁÑ°Â∏∏"], boss:["ÊúâÈ†ÇÊÖ¢","Ëâ≤ÁïåÊÑõ","Ê•≠Êûú","ÂπªÂåñ"], mult:{hp:1.10, atk:1.06, def:1.06}, loot:{gold:1.10, xp:1.24} },
];

const MON_MODS = [
  // Êó¢Â≠ò
  { key:"armored",     name:"Ë£ÖÁî≤",   w:18, mult:{hp:1.05, atk:1.00, def:1.25} },
  { key:"frenzied",    name:"ÁãÇ‰π±",   w:16, mult:{hp:1.00, atk:1.18, def:0.95} },
  { key:"titanic",     name:"Â∑®Ë∫Ø",   w:12, mult:{hp:1.35, atk:1.00, def:1.00} },
  { key:"hexed",       name:"Âë™Ë©õ",   w:10, mult:{hp:1.00, atk:1.08, def:1.10} },
  { key:"volatile",    name:"Êö¥Ëµ∞",   w:10, mult:{hp:0.85, atk:1.30, def:0.90} },
  { key:"vampiric",    name:"Âê∏Ë°Ä",   w: 8, mult:{hp:1.08, atk:1.05, def:1.00}, enemyLs:0.03 },
  { key:"swift",       name:"‰øäÊïè",   w:10, mult:{hp:0.95, atk:1.10, def:0.95}, swift:0.12 },
  { key:"unyielding",  name:"‰∏çÂ±à",   w: 8, mult:{hp:1.20, atk:0.98, def:1.18} },
  { key:"spiteful",    name:"ÊÄ®Âóü",   w: 6, mult:{hp:1.00, atk:1.06, def:1.02}, enemySpite:0.04 },
  { key:"mystic",      name:"Á•ûÁßò",   w: 6, mult:{hp:1.00, atk:1.00, def:1.00}, mysticLoot:0.15 },

  // ‰∫îÊØíÔºàÁÖ©ÊÇ©Ôºâ‰ªòÂ∏ØÔºöÂØÜÊïô„Çâ„Åó„Åï„Çí‚ÄúÊ±∫ÂÆö„Å•„Åë„Çã‚ÄùÈöúË¶ÜÊºîÂá∫„ÅÆÊ†π
  { key:"greed",       name:"Ë≤™Ôºà„Å®„ÇìÔºâ", w:11, mult:{hp:1.10, atk:1.06, def:1.00}, goldMul:1.28, karmaKill:-2 },
  { key:"anger",       name:"ÁûãÔºà„Åó„ÇìÔºâ", w:11, mult:{hp:1.00, atk:1.18, def:0.98}, xpMul:1.10, karmaKill:-2, swift:0.06 },
  { key:"ignorance",   name:"Áó¥Ôºà„Å°Ôºâ",   w:10, mult:{hp:1.15, atk:1.00, def:1.10}, karmaKill:-1, mysticLoot:0.05 },
  { key:"pride",       name:"ÊÖ¢Ôºà„Åæ„ÇìÔºâ", w: 8, mult:{hp:1.22, atk:1.06, def:1.12}, karmaKill:-2 },
  { key:"envy",        name:"Â´âÔºà„Åó„Å§Ôºâ", w: 8, mult:{hp:1.00, atk:1.10, def:1.02}, goldMul:0.92, xpMul:1.06, karmaKill:-1 },
];


  // --------------------
  // Monster Mod (‰ªòÂ∏ØÁâπÊÄß) tooltips
  // --------------------
  const MOD_BY_NAME = (() => {
    const m = {};
    try{ (MON_MODS||[]).forEach(x => { if (x && x.name) m[x.name] = x; }); }catch(_){}
    return m;
  })();

  function modExplain(name){
    const n = String(name ?? "");
    const m = MOD_BY_NAME[n];
    if (!m) return n;

    const lines = [];
    const mult = [];
    const mm = m.mult || {};
    const hp = Number(mm.hp ?? 1);
    const atk = Number(mm.atk ?? 1);
    const def = Number(mm.def ?? 1);
    if (hp !== 1) mult.push(`HP√ó${hp}`);
    if (atk !== 1) mult.push(`ÈôçÈ≠î√ó${atk}`);
    if (def !== 1) mult.push(`ÊåÅÊàí√ó${def}`);
    if (mult.length) lines.push(mult.join(" / "));

    // Special behaviors (must match game logic)
    if (m.key === "vampiric"){
      lines.push(`Âê∏Ë°Ä: ÂèóËã¶„ÅÆ${Math.round((Number(m.enemyLs ?? 0.03))*100)}%„ÇíÂõûÂæ©`);
    }
    if (m.key === "swift"){
      lines.push(`ËøÖË°å: Ë°åÂãïÈñìÈöî-${Math.round((Number(m.swift ?? 0.12))*100)}%ÔºàÊâãÊï∞‚ÜëÔºâ`);
    }
    if (m.key === "spiteful"){
      lines.push(`ÊÄ®Âóü: 20%„ÅßËøΩÊíÉÔºàÂèóËã¶√ó${Math.round((Number(m.enemySpite ?? 0.04))*100)}%Ôºâ`);
    }
    if (m.key === "mystic"){
      lines.push(`Á•ûÁßò: Êéà‰∏é„ÅÆÂ∏åÂ∞ëÂ∫¶Ë£úÊ≠£ +${Number(m.mysticLoot ?? 0.15)}`);
    }

    // Five poisons (‰∫îÊØí)
    if (m.key === "greed"){
      lines.push(`Ë≤™: ÂäüÂæ≥√ó${Number(m.goldMul ?? 1.28)} / Âä†ÊåÅ+1(È´òÁ¢∫Áéá) / ÊíÉÁ†¥ÂäüÂæ≥+12%`);
      lines.push(`Ê•≠: ÊíÉÁ†¥ÊôÇ ${Number(m.karmaKill ?? 0)}ÔºàË≤†Ëç∑„ÅåÂ¢ó„Åà„ÇãÔºâ`);
    }
    if (m.key === "anger"){
      lines.push(`Áûã: Ë°å√ó${Number(m.xpMul ?? 1.10)} / Âè©„Åã„Çå„Çã„Åª„Å©ÈôçÈ≠î‚ÜëÔºàÊÄí„ÇäËìÑÁ©çÔºâ`);
      lines.push(`ÂâØ‰ΩúÁî®: ÂèóËã¶„ÅßÊ•≠„ÅåÂÇæ„Åç„ÇÑ„Åô„ÅÑ`);
      lines.push(`Ê•≠: ÊíÉÁ†¥ÊôÇ ${Number(m.karmaKill ?? 0)}`);
    }
    if (m.key === "ignorance"){
      lines.push(`Áó¥: ÊÖßÁúºÔºà‰ºöÂøÉÔºâ„ÇíÁÑ°ÂäπÂåñÔºàÊÖßÁúºÂ∞ÅÂç∞Ôºâ`);
      lines.push(`Á•ûÁßò: Êéà‰∏é„ÅÆÂ∏åÂ∞ëÂ∫¶Ë£úÊ≠£ +${Number(m.mysticLoot ?? 0.05)}`);
      lines.push(`Ê•≠: ÊíÉÁ†¥ÊôÇ ${Number(m.karmaKill ?? 0)}`);
    }
    if (m.key === "pride"){
      lines.push(`ÊÖ¢: ËøîÊ•≠Ôºà‰∏é„ÉÄ„É°10% / Â§©È≠î14%Ôºâ‚ÄªËá¥Ê≠ª„Åó„Å™„ÅÑÔºàÂëΩ1„ÅßÊ≠¢„Åæ„ÇãÔºâ`);
      lines.push(`Ëã¶Ê∏õ: DR„ÅØÂçäÂàÜ„Å†„ÅëÂäπ„Åè`);
      lines.push(`Ê•≠: ÊíÉÁ†¥ÊôÇ ${Number(m.karmaKill ?? 0)}`);
    }
    if (m.key === "envy"){
      lines.push(`Â´â: Ë¢´Âºæ„ÅßÂäüÂæ≥„ÇíÂê∏„ÅÜÔºàÁ¢∫ÁéáÔºâ`);
      lines.push(`Ë°å√ó${Number(m.xpMul ?? 1.06)} / ÂäüÂæ≥√ó${Number(m.goldMul ?? 0.92)}`);
      lines.push(`Ê•≠: ÊíÉÁ†¥ÊôÇ ${Number(m.karmaKill ?? 0)}`);
    }

    const body = lines.filter(Boolean).join("\n");
    return body ? `${m.name}\n${body}` : m.name;
  }

  function escAttr(s){
    return String(s ?? "")
      .replace(/&/g, "&amp;")
      .replace(/</g, "&lt;")
      .replace(/>/g, "&gt;")
      .replace(/"/g, "&quot;");
  }
  function modSpan(name){
    const n = String(name ?? "");
    const tip = escAttr(modExplain(n));
    return `<span class="modTag" title="${tip}">${n}</span>`;
  }
  function modsHtml(mods){
    return (mods || []).map(modSpan).join("„ÄÅ");
  }
  function modsTitle(mods){
    if (!mods || !mods.length) return "";
    return "ÁâπÊÄß:\n" + mods.map(n => modExplain(n)).join("\n\n");
  }


function biomeForFloor(floor){
  // ÂÖ≠ÈÅì„ÅØÊ∑±Â∫¶„ÅßÂ∑°Âõû„Åó„Å§„Å§„ÄÅÊ•≠„Åß‚ÄúÂØÑ„Çä‚Äù„ÅåÁîü„Åò„Çã
  const base = Math.floor((floor-1)/14) % BIOMES.length;
  const karma = clampKarma(num((S && S.hero && S.hero.karma) || 0, 0));
  const k = clamp(karma / 108, -1, 1); // -1..1
  const shift = Math.round(k * 2); // ÊÇ™Ê•≠‚ÜíÂú∞ÁçÑÂØÑ„Çä / ÂñÑÊ•≠‚ÜíÂ§©ÈÅìÂØÑ„Çä
  const idx = clamp(base + shift, 0, BIOMES.length-1);
  return BIOMES[idx];
}


function karmaPullTag(k){
  const karma = clampKarma(num(k, 0));
  const kN = clamp(karma / 108, -1, 1);
  const shift = Math.round(kN * 2); // -2..2
  if (shift >= 2) return "„ÄàÂ§©ÂÅè„Äâ";
  if (shift === 1) return "„ÄàÂ§©ÂØÑ„Äâ";
  if (shift === -1) return "„ÄàÁçÑÂØÑ„Äâ";
  if (shift <= -2) return "„ÄàÁçÑÂÅè„Äâ";
  return "";
}


  const pickWeighted = (items, weightKey="w") => {
    const sum = items.reduce((s,it)=>s + it[weightKey], 0);
    let r = Math.random()*sum;
    for (const it of items){
      r -= it[weightKey];
      if (r <= 0) return it;
    }
    return items[items.length-1];
  };

  const RAR = [
    { key:"common",    name:"Âá°ÂìÅ",    w: 70, mult:1.00, aff:0, sell: 1.0 },
    { key:"uncommon",  name:"ÂñÑÂìÅ",  w: 20, mult:1.08, aff:1, sell: 1.5 },
    { key:"rare",      name:"Â¶ôÂìÅ",      w:  8, mult:1.20, aff:2, sell: 2.3 },
    { key:"epic",      name:"ÁßòÂÆù",      w:  1.6, mult:1.38, aff:3, sell: 3.7 },
    { key:"legendary", name:"ËÅñÂÆù", w:  0.35, mult:1.70, aff:4, sell: 6.5 },
    { key:"unique",    name:"ÂÖ≠Âç∞„ÅÆÊ¨†Áâá",    w:  0.05, mult:2.05, aff:5, sell: 12.0 },
  ];
  const SLOT_ORDER = ["weapon","armor","accessory"];
  const RAR_RANK = { common:0, uncommon:1, rare:2, epic:3, legendary:4, unique:5 };

  const SLOT_NAME = { weapon:"Ê≠¶Âô®", armor:"Èò≤ÂÖ∑", accessory:"ÁìîÁèû" };

  const UPG_LABEL = { str:"Á≤æÈÄ≤", vit:"ÂøçËæ±", def:"ÊåÅÊàí", luck:"Á∏Å" };
  const GUILD_LABEL = { forge:"ÈáëÂâõÁÇâ", bounty:"ÂãßÈÄ≤ÊâÄ", library:"ËîµÁµåÈñ£", shrine:"ÈÅìÂ†¥" };
const GUILD_CAP = { forge:120, bounty:100, library:100, shrine:60 }; // „Åì„Çå‰ª•‰∏ä„ÅØÂäπÊûú„ÅåÈ†≠Êâì„Å°
function guildCap(which){ return (GUILD_CAP && Number.isFinite(GUILD_CAP[which])) ? GUILD_CAP[which] : Infinity; }


// --------------------
// ÂØÜÊïôÊã°ÂºµÔºöÊ•≠„ÉªÊÇü„Çä„ÉªË≠∑Êë©„ÉªÁúüË®Ä
// --------------------
const REALM_ORDER = ["hell","hungry","animal","asura","human","deva"]; // ÂÖ≠ÈÅì„ÅÆ‰∏¶„Å≥
const REALM_LABEL = { hell:"Âú∞ÁçÑÈÅì", hungry:"È§ìÈ¨ºÈÅì", animal:"ÁïúÁîüÈÅì", asura:"‰øÆÁæÖÈÅì", human:"‰∫∫ÈñìÈÅì", deva:"Â§©ÈÅì" };

// --------------------
// „Çπ„Éà„Éº„É™„ÉºÔºöÊõºËçºÁæÖÂ∏≥ÔºàÂÖ≠ÈÅìÁ´†Ôºâ
// --------------------
const STORY = {
  hell: {
    chapNo: 1,
    chap: "Á¨¨‰∏ÄÁ´† Ëã¶Ë´¶ÁïåÔºàÂú∞ÁçÑÈÅìÔºâ",
    tagline: "ÊÄí„Çä„Åå‰∏ñÁïå„ÇíÁÑº„Åè„ÄÇ",
    prologue: "ÈñÄ„ÅØÁÜ±„ÇíË®ÄËëâ„Å´Â§â„Åà„ÄÅ„ÅÇ„Å™„Åü„ÅÆËàå„ÇíÁÑº„Åè„ÄÇ\n„Åì„Åì„Åß„ÅØ„ÄéÁóõ„Åø„Äè„ÅåÁµå„Å®„Å™„Çä„ÄÅ„ÄéÊÄí„Çä„Äè„ÅåÁ≠Ü„Å®„Å™„Çã„ÄÇ\nËã¶„ÇíÈÅø„Åë„Åö„ÄÅËã¶„ÅÆÂΩ¢„ÇíÂÜô„Åó„Å¶ÈÄ≤„ÇÅ„ÄÇ",
    whisper: "ÁÑº„ÅëË∑°„Å´ÊÆã„Çã„ÅÆ„ÅØ„ÄÅÊÄí„Çä„Åß„ÅØ„Å™„ÅèÂõ†Êûú„ÄÇ",
    seal: "ÁÑ¶ÁÜ±Âç∞",
    epilogue: "ÁÑº„ÅëË∑°„Å´ÊÆã„Çã„ÅÆ„ÅØ„ÄÅÊÄí„Çä„Åß„ÅØ„Å™„ÅèÂõ†Êûú„ÄÇ",
    glyph: "ÁÅ´",
  },
  hungry: {
    chapNo: 2,
    chap: "Á¨¨‰∫åÁ´† ÈõÜË´¶ÁïåÔºàÈ§ìÈ¨ºÈÅìÔºâ",
    tagline: "Ê¨†‰πè„ÅØÂô®„Åß„ÅØ„Å™„ÅèÁ©¥„Å†„ÄÇ",
    prologue: "Ê¨†‰πè„ÅØÂô®„Åß„ÅØ„Å™„Åè„ÄÅÁ©¥„Å†„ÄÇ\nÊ∫Ä„Åü„Åó„Å¶„ÇÇÊ∫Ä„Å°„Å™„ÅÑÁ©¥„Å´„ÄÅÂêç„Çí‰ªò„Åë„Çã„ÄÇ\nÊ∏áÊÑõ„ÇíË¶ã„Å¶„ÄÅÂ∏ÉÊñΩ„ÇíÂ≠¶„Åπ„ÄÇ",
    whisper: "Á©¥„ÇíÂ°û„Åå„Åö„ÄÅÁ©¥„ÇíÁÖß„Çâ„Åó„Åü„ÄÇ",
    seal: "Ê∏áÊÑõÂç∞",
    epilogue: "Á©¥„ÇíÂ°û„Åå„Åö„ÄÅÁ©¥„ÇíÁÖß„Çâ„Åó„Åü„ÄÇ",
    glyph: "Ê∏á",
  },
  animal: {
    chapNo: 3,
    chap: "Á¨¨‰∏âÁ´† ÁÑ°ÊòéÁïåÔºàÁïúÁîüÈÅìÔºâ",
    tagline: "Èúß„ÅÆ‰∏≠„Åß„ÅØ„ÄÅÁêÜ„Åå„Åª„Å©„Åë„Çã„ÄÇ",
    prologue: "Èúß„ÅÆÂ••„Åß„ÄÅÁêÜ„ÅØËº™ÈÉ≠„ÇíÂ§±„ÅÜ„ÄÇ\nÁÑ°Êòé„ÅØÊïµ„Åß„ÅØ„Å™„Åè„ÄÅÂâçÊèê„Å†„ÄÇ\nÂïè„ÅÑ„Çí‰∏Ä„Å§ÊÆã„Åó„Å¶ÈÄ≤„ÇÅ„ÄÇ",
    whisper: "Èúß„ÅØÊ∂à„Åà„Å™„ÅÑ„ÄÇ„Åü„Å†„ÄÅÊ≠©ÂπÖ„ÅåÂ§â„Çè„Çã„ÄÇ",
    seal: "ÈúßÊòéÂç∞",
    epilogue: "Èúß„ÅØÊ∂à„Åà„Å™„ÅÑ„ÄÇ„Åü„Å†„ÄÅÊ≠©ÂπÖ„ÅåÂ§â„Çè„Çã„ÄÇ",
    glyph: "Èúß",
  },
  asura: {
    chapNo: 4,
    chap: "Á¨¨ÂõõÁ´† ÁûãÊÖ¢ÁïåÔºà‰øÆÁæÖÈÅìÔºâ",
    tagline: "ÂãùÊïó„ÅØÈè°„Åß„ÄÅÂàÉ„ÅØÂÜÖ„Å´„ÅÇ„Çã„ÄÇ",
    prologue: "Âãù„Å°Ë≤†„Åë„ÅØÂâ£„Åß„ÅØ„Å™„Åè„ÄÅÈè°„Å†„ÄÇ\nÈè°„Å´Êò†„Çã„ÅÆ„ÅØ‰ªñËÄÖ„Åß„ÅØ„Å™„Åè„ÄÅÂ∑±„ÅÆÊÖ¢„ÄÇ\nÊÄí„Çä„ÇíÁÜ±„Å´„ÄÅË™ì„ÅÑ„ÇíÂàÉ„Å´„ÄÇ",
    whisper: "ÂàÉ„ÅØÂ§ñ„Åß„ÅØ„Å™„ÅèÂÜÖ„Å∏Âêë„ÅÑ„Åü„ÄÇ",
    seal: "‰∫âÈè°Âç∞",
    epilogue: "ÂàÉ„ÅØÂ§ñ„Åß„ÅØ„Å™„ÅèÂÜÖ„Å∏Âêë„ÅÑ„Åü„ÄÇ",
    glyph: "‰∫â",
  },
  human: {
    chapNo: 5,
    chap: "Á¨¨‰∫îÁ´† ÂàÜÂà•ÁïåÔºà‰∫∫ÈñìÈÅìÔºâ",
    tagline: "ÈÅ∏„Å∂„Åì„Å®„ÅØ„ÄÅÂàá„ÇäÂàÜ„Åë„Çã„Åì„Å®„ÄÇ",
    prologue: "ÂàÜÂà•„ÅØÊ©ã„Å´„ÇÇÊ™ª„Å´„ÇÇ„Å™„Çã„ÄÇ\n„ÅÇ„Å™„Åü„ÅØ„ÄéÈÅ∏„Å∂„Äè„Åì„Å®„Åß‰∏ñÁïå„ÇíÂàá„ÇäÂàÜ„Åë„Çã„ÄÇ\nÈÅ∏„Çì„Å†Âæå„Å´„ÄÅÊç®„Å¶„Çâ„Çå„Çã„Åã„ÄÇ",
    whisper: "Á≠î„Åà„ÅØÁµêË´ñ„Åß„ÅØ„Å™„Åè„ÄÅÊâãÊîæ„Åó„Å†„Å£„Åü„ÄÇ",
    seal: "ÂàÜÂà•Âç∞",
    epilogue: "Á≠î„Åà„ÅØÁµêË´ñ„Åß„ÅØ„Å™„Åè„ÄÅÊâãÊîæ„Åó„Å†„Å£„Åü„ÄÇ",
    glyph: "Êäû",
  },
  deva: {
    chapNo: 6,
    chap: "Á¨¨ÂÖ≠Á´† ÊúâÈ†ÇÁïåÔºàÂ§©ÈÅìÔºâ",
    tagline: "Ê∫Ä„Å°„ÅüÁû¨Èñì„ÄÅÁµÇ„Çè„Çä„ÅåÂßã„Åæ„Çã„ÄÇ",
    prologue: "ÂÖâ„ÅØÊ∞∏ÈÅ†„ÇíÂÅΩË£Ö„Åô„Çã„ÄÇ\nÊ∫Ä„Å°Ë∂≥„Çä„ÅüÁû¨Èñì„ÄÅÁµÇ„Çè„Çä„ÅåÂßã„Åæ„Çã„ÄÇ\nÁÑ°Â∏∏„ÇíË¶ã„Çà„ÄÇ",
    whisper: "ÂÖâ„ÅØË°∞„Åà„Çã„ÄÇ„Å†„Åã„Çâ„Åì„Åù„ÄÅË™ì„ÅÑ„ÅØÊòé„Çã„ÅÑ„ÄÇ",
    seal: "‰∫îË°∞Âç∞",
    epilogue: "ÂÖâ„ÅØË°∞„Åà„Çã„ÄÇ„Å†„Åã„Çâ„Åì„Åù„ÄÅË™ì„ÅÑ„ÅØÊòé„Çã„ÅÑ„ÄÇ",
    glyph: "Ë°∞",
  },
};

function ensureStoryFields(){
  ensureMikkyoFields();
  const c = S.hero.codex;
  c.story = c.story || { intros:{}, seals:{}, fragments:{}, ending:"", last:"", lastRealm:"" };
  c.story.intros = c.story.intros || {};
  c.story.seals = c.story.seals || {};
  c.story.fragments = c.story.fragments || {};
  c.story.ending = String(c.story.ending || "");
  c.story.last = String(c.story.last || "");
  c.story.lastRealm = String(c.story.lastRealm || "");
}

function setLastVerse(realmKey, text){
  ensureStoryFields();
  S.hero.codex.story.last = String(text || "");
  S.hero.codex.story.lastRealm = String(realmKey || "");
}

function maybeRealmPrologue(realmKey, realmName){
  try{
    ensureStoryFields();
    if (!realmKey) return false;
    if (S.hero.codex.story.intros && S.hero.codex.story.intros[realmKey]) return false;
    const st = STORY[realmKey];
    if (!st) return false;

    const ev = {
      key: "realm_intro_" + realmKey,
      title: st.chap,
      body: st.prologue,
      foot: "ÊõºËçºÁæÖÂ∏≥„Å´Ë®ò„Åï„Çå„Çã„ÄÇ",
      choices: [
        { label:"ÂêàÊéå„Åó„Å¶ÈÄ≤„ÇÄ", accent:true, apply: ()=>{
          ensureStoryFields();
          S.hero.codex.story.intros[realmKey] = 1;
          const line = st.whisper || st.tagline || "";
          if (line) { setLastVerse(realmKey, line); try{ log(`<span class="muted">${escapeHtml(line)}</span>`); }catch(_){ } }
          S.hero.satori += 2;
          addKarma(1);
        } }
      ]
    };
    openEvent(ev);
    return true;
  }catch(_){}
  return false;
}

function storyBossSeal(realmKey){
  try{
    ensureStoryFields();
    if (!realmKey) return;
    const st = STORY[realmKey];
    if (!st) return;
    const seals = S.hero.codex.story.seals || (S.hero.codex.story.seals = {});
    if (seals[realmKey]) return;

    seals[realmKey] = 1;

    const gain = 8;
    S.hero.satori += gain;
    addKarma(4);

    log(`<span class="rare">Âç∞</span>: ${escapeHtml(st.seal)}ÔºàÊÇü„Çä +${fmt(gain)} / Ê•≠ +4Ôºâ`);
    if (st.epilogue) log(`<span class="muted">${escapeHtml(st.epilogue)}</span>`);
    try{ spawnMantraFx(st.glyph || "‡•ê"); }catch(_){}

    setLastVerse(realmKey, st.epilogue || st.seal || "");
    dirtyLog = true;
  }catch(_){}
}

// --- ÂÖ≠Âç∞„ÅÆÊ¨†ÁâáÔºà„É¶„Éã„Éº„ÇØÔºùÊ¨†ÁâáÔºâ/ ÁµêÈ°òÔºà„Ç®„É≥„Éá„Ç£„É≥„Ç∞ÂàÜÂ≤êÔºâ ---
function hasAllSixFragments(){
  ensureStoryFields();
  const fr = (S.hero.codex.story && S.hero.codex.story.fragments) ? S.hero.codex.story.fragments : {};
  return REALM_ORDER.every(k => (fr[k]||0) > 0);
}
function fragmentCount(){
  ensureStoryFields();
  const fr = (S.hero.codex.story && S.hero.codex.story.fragments) ? S.hero.codex.story.fragments : {};
  let n = 0;
  for (const k of REALM_ORDER) if ((fr[k]||0) > 0) n++;
  return n;
}
function applySealToUnique(it, realmKey){
  try{
    ensureStoryFields();
    realmKey = realmKey || biomeForFloor(S.run.floor).key;
    const st = STORY[realmKey] || {};
    const seal = st.seal || "ÂÖ≠Âç∞";
    const glyph = st.glyph || "Âç∞";
    const rlabel = REALM_LABEL[realmKey] || realmKey;

    it.sealRealm = realmKey;
    it.sealName  = seal;
    it.sealGlyph = glyph;

    // Ë°®Ë®òÔºö‰∏ÄÊñáÂ≠óÔºàÊ¨†Áâá„ÅÆÊº¢Â≠óÔºâ„ÇíÂÖàÈ†≠„Å´ÊçÆ„Åà„Çã
    const baseName = String(it.name || "Ê≥ïÂÖ∑");
    it.name = `„Äê${glyph}„Äë${seal}„ÅÆÊ¨†Áâá„Éª${baseName}`;

    const lore = `ÂÖ≠Âç∞„ÅÆÊ¨†ÁâáÔºö${seal}Ôºà${rlabel}Ôºâ\nÊõºËçºÁæÖÂ∏≥„Å´Âàª„Åæ„Çå„ÅüÂç∞„Åå„ÄÅÊ≥ïÂÖ∑„Å®„Åó„Å¶ÁµêÊô∂„Åó„Åü„ÇÇ„ÅÆ„ÄÇ\nÂÖ≠„Å§ÊèÉ„Åà„Å∞„ÄåÁµêÈ°ò„Äç„ÅÆÈñÄ„ÅåÈñã„Åè„ÄÇ`;
    const old = String(it.desc || "").trim();
    it.desc = (lore + (old ? `\n‚Äî\n${old}` : "")).trim();
  }catch(_){}
}
function grantSealFragment(realmKey){
  try{
    ensureStoryFields();
    realmKey = realmKey || biomeForFloor(S.run.floor).key;
    const st = STORY[realmKey] || {};
    const seal = st.seal || (REALM_LABEL[realmKey]||realmKey);
    const glyph = st.glyph || "Âç∞";

    const story = S.hero.codex.story;
    story.fragments = story.fragments || {};
    const before = Math.floor(num(story.fragments[realmKey], 0));
    story.fragments[realmKey] = before + 1;

    if (before === 0){
      // ÂàùÂõûÁç≤ÂæóÔºöË®òÈå≤„Å®„Åó„Å¶ÊÆã„Åó„ÄÅÁµêÈ°ò„Å´Ëøë„Å•„Åè
      const gain = 10;
      S.hero.satori += gain;
      addKarma(3);
      log(`<span class="rare">ÂÖ≠Âç∞</span>: „Äê${escapeHtml(glyph)}„Äë${escapeHtml(seal)}„ÅÆÊ¨†ÁâáÔºàÊÇü„Çä +${fmt(gain)} / Ê•≠ +3Ôºâ`);
      if (st.whisper) { setLastVerse(realmKey, st.whisper); try{ log(`<span class="muted">${escapeHtml(st.whisper)}</span>`); }catch(_){ } }
      try{ spawnMantraFx(glyph); }catch(_){}

      // Unlock MAX speed when all six fragments are collected.
      try{
        if (hasAllSixFragments() && !story._maxSpeedUnlocked){
          story._maxSpeedUnlocked = 1;
          log('<span class="rare">ËøÖË°å</span>: MAX„ÅåËß£Êîæ„Åï„Çå„ÅüÔºÅ');
          dirtyLog = true;
          dirtyHUD = true;
        }
      }catch(_){}
      try{ syncSpeedSelUnlock(); }catch(_){}

      maybeUnlockEnding();
    } else {
      // ÈáçË§á„ÅØÂäüÂæ≥„Å∏ÈÇÑÂÖÉÔºàË®òÈå≤„ÅØÂ¢ó„Åà„Çã„Åå„ÄÅÁ´†ÈÄ≤Ë°å„ÅØÂàùÂõû„Å†„ÅëÔºâ
      const g = Math.round(260 + Math.random()*340);
      S.hero.gold += g;
      log(`<span class="muted">ÂÖ≠Âç∞</span>: ÈáçË§á„ÅÆÊ¨†Áâá ‚Üí <span class="gold">ÂäüÂæ≥ +${fmt(g)}</span>`);
    }
  }catch(_){}
}
function openEndingChoice(){
  ensureStoryFields();
  if (!hasAllSixFragments()) return false;
  const story = S.hero.codex.story;
  const ending = String(story.ending||"");
  if (ending === "kongo" || ending === "taizo") return false;

  const ev = {
    key:"ketsugan",
    title:"ÁµêÈ°ò ‚Äî ÂÖ≠Âç∞ÈÇÑÂÖÉ",
    body:"ÂÖ≠„Å§„ÅÆÊ¨†Áâá„ÅåÊèÉ„ÅÑ„ÄÅÂç∞„ÅØÂÜç„Å≥Ëº™„Å®„Å™„Å£„Åü„ÄÇ\n„Åì„Åì„Åã„ÇâÂÖà„ÄÅ„ÅÇ„Å™„Åü„ÅØ„Å©„ÅÆÊõºËçºÁæÖ„Å´Áµê„Å∂„Åã„ÄÇ\nÁµêÈ°ò„ÅØ‰ª•Âæå„ÅÆÂ∑°Á§º„Å´„ÄÅÊ∞∏Á∂ö„ÅÆÂä†ÊåÅ„Å®„Åó„Å¶ÊÆã„Çã„ÄÇ",
    foot:"Ôºà‰øùÁïô„Åó„ÅüÂ†¥Âêà„ÄÅÊõºËçºÁæÖÂ∏≥„Åã„Çâ„ÅÑ„Å§„Åß„ÇÇÁµê„Åπ„ÇãÔºâ",
    choices:[
      { label:"üî± ÈáëÂâõÁïå„Å´Áµê„Å∂ÔºàË™ø‰ºè„ÅÆÁµêÈ°òÔºâ", accent:true, apply:()=>{
        story.ending = "kongo";
        setLastVerse("deva", "ÂàÉ„ÅØÊñ≠„Å§„Åü„ÇÅ„Åß„ÅØ„Å™„Åè„ÄÅËø∑„ÅÑ„ÇíÁ∏´„ÅÑÁïô„ÇÅ„Çã„Åü„ÇÅ„Å´ÂÖâ„Å£„Åü„ÄÇ");
        S.hero.satori += 30; addKarma(8);
        log('<span class="rare">ÁµêÈ°ò</span>: ÈáëÂâõÁïåÔºàË™ø‰ºèÔºâ');
      }},
      { label:"üå∏ ËÉéËîµÁïå„Å´Áµê„Å∂ÔºàÊÖàÊÇ≤„ÅÆÁµêÈ°òÔºâ", apply:()=>{
        story.ending = "taizo";
        setLastVerse("human", "ÂÆà„Çä„ÅØÂõ≤„ÅÜ„Åü„ÇÅ„Åß„ÅØ„Å™„Åè„ÄÅÈñã„Åè„Åü„ÇÅ„Å´Èùô„Åã„Å´Â∫É„Åå„Å£„Åü„ÄÇ");
        S.hero.satori += 30; addKarma(8);
        log('<span class="rare">ÁµêÈ°ò</span>: ËÉéËîµÁïåÔºàÊÖàÊÇ≤Ôºâ');
      }},
      { label:"‰øùÁïôÔºà„Åæ„Å†Ê≠©„ÅèÔºâ", apply:()=>{
        story.ending = "pending";
        log('<span class="muted">ÁµêÈ°ò</span>: ‰øùÁïôÔºàÊõºËçºÁæÖÂ∏≥„Åã„ÇâÈÅ∏ÊäûÂèØÔºâ');
      }},
    ]
  };
  openEvent(ev);
  return true;
}
function maybeUnlockEnding(){
  try{
    ensureStoryFields();
    const story = S.hero.codex.story;
    const ending = String(story.ending||"");
    if (ending === "kongo" || ending === "taizo") return false;
    if (!hasAllSixFragments()) return false;
    return openEndingChoice();
  }catch(_){}
  return false;
}



const PATH_KEYS = []; // ÂÖ´Ê≠£ÈÅìÔºàÂç∞Â•ë‰øÆË°åÔºâ„ÅØÂâäÈô§


function clampKarma(x){
  x = Math.floor(num(x, 0));
  return clamp(x, -108, 108);
}
function addKarma(delta){
  if (!S || !S.hero) return;
  const before = clampKarma(S.hero.karma || 0);
  const after = clampKarma(before + Math.floor(num(delta, 0)));
  S.hero.karma = after;
  return { before, after };
}

function ensureMikkyoFields(){
  // Ê•≠„ÉªÊÇü„Çä„ÉªÁúüË®Ä„ÉªË≠∑Êë©„ÅÆ„ÅøÁ∂≠ÊåÅÔºàÂõûÂêë/ÂÖ´Ê≠£ÈÅì„ÅØÂâäÈô§Ôºâ
  S.hero.karma = clampKarma(num(S.hero.karma, 0));
  S.hero.satori = Math.max(0, Math.floor(num(S.hero.satori, 0)));

  // Êóß„Çª„Éº„Éñ‰∫íÊèõ: S.hero.path / codex.dedicates „ÅåÊÆã„Å£„Å¶„ÅÑ„Å¶„ÇÇÁÑ°Ë¶ñ„Åô„Çã

  S.hero.codex = S.hero.codex || { realms:{}, events:{}, bosses:0, elites:0, uniques:0, mantras:0, purifies:0, kills:0, maxFloor:1 };
  S.hero.codex.realms = S.hero.codex.realms || {};
  S.hero.codex.events = S.hero.codex.events || {};
  S.hero.codex.bosses = Math.max(0, Math.floor(num(S.hero.codex.bosses, 0)));
  S.hero.codex.elites = Math.max(0, Math.floor(num(S.hero.codex.elites, 0)));
  S.hero.codex.uniques = Math.max(0, Math.floor(num(S.hero.codex.uniques, 0)));
  S.hero.codex.mantras = Math.max(0, Math.floor(num(S.hero.codex.mantras, 0)));
  S.hero.codex.purifies = Math.max(0, Math.floor(num(S.hero.codex.purifies, 0)));
  S.hero.codex.kills = Math.max(0, Math.floor(num(S.hero.codex.kills, 0)));
  S.hero.codex.maxFloor = Math.max(1, Math.floor(num(S.hero.codex.maxFloor, 1)));
  // ÊõºËçºÁæÖÂ∏≥Ôºà„Çπ„Éà„Éº„É™„ÉºÔºâ
  S.hero.codex.story = S.hero.codex.story || { intros:{}, seals:{}, last:"", lastRealm:"" };
  S.hero.codex.story.intros = S.hero.codex.story.intros || {};
  S.hero.codex.story.seals = S.hero.codex.story.seals || {};
  S.hero.codex.story.last = String(S.hero.codex.story.last || "");
  S.hero.codex.story.lastRealm = String(S.hero.codex.story.lastRealm || "");


  S.run.mantraUntil = num(S.run.mantraUntil, 0);
  S.run.mantraCdUntil = num(S.run.mantraCdUntil, 0);
  S.run._eventLock = num(S.run._eventLock, 0);
  S.run._resumeAfterEvent = (Number(S.run._resumeAfterEvent) === 1) ? 1 : 0;
}



  const WEAPONS = [
    { base:"Ëà¨Ëã•Ââ£",      stat:{ atk: 8, crit:0.02, spd:0.00 }},
    { base:"Â§ßËà¨Ëã•Ââ£",    stat:{ atk:12, crit:0.01, spd:-0.05 }},
    { base:"Á∏ÅËµ∑ËìÆËèØÂâ£", stat:{ atk: 8, crit:0.05, spd: 0.03 }},
    { base:"Êñ≠ÊÉëÊñß",      stat:{ atk:10, crit:0.00, spd:-0.03 }},
    { base:"‰∏≠ÈÅìÊßç",      stat:{ atk: 9, crit:0.01, spd:-0.01 }},
    { base:"Á©∫ÊÄßËñôÂàÄ", stat:{ atk:11, crit:0.01, spd:-0.03 }},
    { base:"Êñ≠Ëº™ÂªªÈéå",      stat:{ atk:10, crit:0.02, spd:-0.02, execute:0.02 }},
    { base:"Âõ†Á∏ÅÁè†Èéö", stat:{ atk:10, crit:0.01, spd:-0.01, shred:0.02 }},
    { base:"ÁÑ°ÊàëÁü≠Ââ£",    stat:{ atk: 7, crit:0.04, spd: 0.06 }},
    { base:"ÊÖàÊÇ≤ËìÆÂºì",      stat:{ atk: 8, crit:0.02, spd: 0.03 }},
    { base:"Á†¥ÈÇ™Âº©", stat:{ atk: 9, crit:0.03, spd: 0.00 }},
    { base:"Ë°åËÑöÈå´Êùñ",      stat:{ atk: 7, crit:0.01, spd: 0.02 }},
    { base:"‰∏âÂØÜÂä†ÊåÅÈå´Êùñ",  stat:{ atk: 7, crit:0.03, spd: 0.02 }},
    { base:"ÈòøÈ†ºËÄ∂ÈôÄÁæÖÂ∞ºÂ∑ª",  stat:{ atk: 6, crit:0.03, spd: 0.04 }},
    { base:"Ê•≠Êñ≠Êßå", stat:{ atk:11, crit:0.00, spd:-0.06 }},
    { base:"‰∫îËòäÊ£ç",  stat:{ atk: 9, crit:0.01, spd:-0.04, lifesteal:0.01 }},
    { base:"Á®ÆÂ≠êÈÄ£Áè†Á†≤",  stat:{ atk: 7, crit:0.02, spd: 0.07 }},
    { base:"‰∏çÂãïÊô∫Ââ£",      stat:{ atk: 9, crit:0.03, spd: 0.02 }},
  ];
  const ARMORS = [
    { base:"‰∫îËòäÊ≥ïË°£", stat:{ hp: 24, def: 3, spd: 0.02 }},
    { base:"Á∏ÅËµ∑ÈéñË°£",  stat:{ hp: 34, def: 4, spd: 0.00 }},
    { base:"ÈáëÂâõÁ∏ÅËµ∑ÈéñË°£", stat:{ hp: 42, def: 6, spd: 0.01 }},
    { base:"‰∏≠ÈÅìÊùøË°£", stat:{ hp: 48, def: 7, spd:-0.03 }},
    { base:"ÈáëÂâõ‰∏≠ÈÅìÊùøË°£",   stat:{ hp: 58, def: 9, spd:-0.04 }},
    { base:"ÁÑ°Â∏∏È±óË°£", stat:{ hp: 40, def: 5, spd:-0.01 }},
    { base:"‰ªèÊÄßÈæçÈ±óÊ≥ïË°£", stat:{ hp: 55, def: 8, crit:0.01 }},
    { base:"Ëè©Ëñ©Ë¢àË£ü",       stat:{ hp: 22, def: 2, crit:0.01 }},
    { base:"Á¶ÖÂÆöÊ≥ïË°£",         stat:{ hp: 26, def: 2, crit:0.03 }},
    { base:"Á©∫Ë¶≥Èö†ÂØÜË°£",       stat:{ hp: 28, def: 3, spd: 0.05, crit:0.01 }},
    { base:"ÊÖàÊÇ≤Â§ñÂ•ó",       stat:{ hp: 30, def: 3, crit:0.02 }},
    { base:"Á©∫ÊÄßÁµêÁïåÂ§ñÂ•ó",  stat:{ hp: 36, def: 4, dr:0.01, spd: 0.02 }},
  ];
  const ACCS = [
    { base:"‰∏âÂ≠¶ÊàíÁí∞",       stat:{ crit:0.02 }},
    { base:"Á∏ÅËµ∑Ë≠∑Á¨¶",  stat:{ hp: 14, def:1 }},
    { base:"Ê≠£ÂøµÁ¨¶",     stat:{ atk: 3, spd:0.02 }},
    { base:"Á©∫ÊÄßÈúäÁ¨¶",  stat:{ luck:2 }},
    { base:"Âõ†Á∏ÅÂøµÁè†ËÖïËº™", stat:{ def:2, spd:0.02 }},
    { base:"ÂõûÂêë‰Ω©Á¨¶",  stat:{ hp: 10, crit:0.01, luck:1 }},
    { base:"ÁÑ°ÊàëËÄ≥Ëº™",  stat:{ crit:0.02, spd:0.02 }},
    { base:"Ëè©Ëñ©Ë≠∑ËÖïËº™",       stat:{ def:3, hp: 6 }},
    { base:"„É†„Éâ„É©„ÉºÂç∞Á´†",       stat:{ luck:3, goldBonus:0.02 }},
    { base:"Â¶ÇÊù•ËîµÂÆùÁè†",       stat:{ atk:2, crit:0.01, dmgMult:0.01 }},
    { base:"Áô∫È°òÁè†",     stat:{ hp: 12, regen:0.002 }},
    { base:"ÊúâÊôÇËº™",     stat:{ spd:0.04, xpBonus:0.02 }},
  ];
  const AFFIX = [
    { key:"atk",  name:"ÈôçÈ≠î+",      apply:(v,ilv)=>({ atk: v + 2 + Math.floor(ilv/7) }),     w:18 },
    { key:"def",  name:"ÊåÅÊàí+",      apply:(v,ilv)=>({ def: v + 2 + Math.floor(ilv/9) }),     w:15 },
    { key:"hp",   name:"ÂëΩ+",       apply:(v,ilv)=>({ hp: v + 12 + Math.floor(ilv*1.9) }),   w:16 },
    { key:"crit", name:"Á†¥È≠î+",     apply:(v,ilv)=>({ crit: v + 0.010 + ilv*0.0007 }),       w:10 },
    { key:"spd",  name:"ËøÖË°å+",      apply:(v,ilv)=>({ spd: v + 0.010 + ilv*0.0006 }),        w:10 },
    { key:"luck", name:"Á∏Å+",     apply:(v,ilv)=>({ luck: v + 1 + Math.floor(ilv/12) }),   w:9  },
    { key:"lifesteal", name:"ÈÇÑÂëΩ",  apply:(v,ilv)=>({ lifesteal: Math.max(v, 0.010 + ilv*0.00035) }), w:7 },
    { key:"thorns",    name:"ËøîÊ•≠",  apply:(v,ilv)=>({ thorns: Math.max(v, 0.015 + ilv*0.00040) }),    w:5 },
    { key:"regen",     name:"ÊÅØÁÅΩ",  apply:(v,ilv)=>({ regen: Math.max(v, 0.003 + ilv*0.00005) }),      w:7 },
    { key:"goldBonus", name:"ÂäüÂæ≥+",apply:(v,ilv)=>({ goldBonus: (v||0) + 0.03 + ilv*0.0002 }),         w:7 },
    { key:"xpBonus",   name:"Ë°å+", apply:(v,ilv)=>({ xpBonus: (v||0) + 0.03 + ilv*0.0002 }),           w:7 },
    { key:"dmgMult",   name:"Â®ÅÂÖâ+",apply:(v,ilv)=>({ dmgMult: (v||0) + 0.02 + ilv*0.00015 }),        w:5 },
    { key:"dr",        name:"Ëã¶Ê∏õ+",apply:(v,ilv)=>({ dr: (v||0) + 0.01 + ilv*0.00010 }),             w:5 },
    { key:"execute",   name:"Êñ≠Ê•≠",  apply:(v,ilv)=>({ execute: Math.max(v||0, 0.02 + ilv*0.00010) }),   w:3 },
    { key:"shred",     name:"Á†¥Èöú",  apply:(v,ilv)=>({ shred: Math.max(v||0, 0.03 + ilv*0.00012) }),     w:4 },
  ];

  // 30 Unique items (same as v3)
  const UNIQUES = [
    { name:"ÁûãÁÅ´Ëª¢Êô∫„ÅÆÁâô", slot:"weapon", fixed:{ atk: 28, crit:0.06, spd:0.04, lifesteal:0.05, dmgMult:0.05 }, desc:"Ë°Ä„ÅÆËñîËñá„ÅåÂàª„ÇÄ‰∏ÄÊíÉ„ÄÇÈÇÑÂëΩ+Â®ÅÂÖâ„ÄÇ" },
    { name:"‰πùÈáçÊàíÂ£áÂüé", slot:"armor", fixed:{ hp: 140, def: 18, thorns:0.10, dr:0.05 }, desc:"ËøîÊ•≠„Å®Ëã¶Ê∏õ„ÄÇËÄê‰πÖ„ÅÆÊ†∏„ÄÇ" },
    { name:"Á∏ÅËµ∑„ÅÆÁΩ≤Âêç", slot:"accessory", fixed:{ crit:0.08, spd:0.05, luck:6, xpBonus:0.08 }, desc:"Á∏Å„Å®ÊàêÈï∑„ÄÇ" },
    { name:"ÁÑ°Êòé„ÅÆÈáëÂ∫ä", slot:"weapon", fixed:{ atk: 34, spd:-0.02, shred:0.10, dmgMult:0.04 }, desc:"Á†¥Èöú„ÅßÁ°¨„ÅÑÈ≠î„ÇíÂ¥©„Åô„ÄÇ" },
    { name:"ÊúàËº™Á¶ÖË°£", slot:"armor", fixed:{ hp: 110, def: 10, regen:0.010, xpBonus:0.06 }, desc:"ÊÅØÁÅΩ„Å®ÁµåÈ®ì„ÄÇ" },
    { name:"ÂäüÂæ≥„ÅÆË™ìÈ°ò", slot:"accessory", fixed:{ goldBonus:0.15, luck:5, def:4 }, desc:"Ë≤°Âæ≥ÁìîÁèû„ÄÇ" },
    { name:"Ê≠£Á≤æÈÄ≤„ÅÆÈáù", slot:"weapon", fixed:{ atk: 24, crit:0.10, spd:0.08, execute:0.06 }, desc:"È´òÈÄüÊñ≠Ê•≠„ÄÇ" },
    { name:"ÁÖßË¶ã„ÅÆË≠∑„Çä", slot:"armor", fixed:{ hp: 120, def: 14, dr:0.06, thorns:0.06 }, desc:"Ëã¶Ê∏õ„Å®ËøîÊ•≠„ÄÇ" },
    { name:"Á®ÆÂ≠êÊÇâÊõáÊú≠", slot:"accessory", fixed:{ luck:8, dmgMult:0.03, xpBonus:0.05, goldBonus:0.05 }, desc:"ÂÖ®ÈÉ®Áõõ„ÇäÁ≥ªÔºàËñÑ„ÇÅÔºâ„ÄÇ" },
    { name:"ÁÑ°Â∏∏„ÅÆÁéãÂÜ†", slot:"accessory", fixed:{ def:6, crit:0.04, lifesteal:0.03, dr:0.03 }, desc:"Ê≠ªÂú∞„ÅßÂº∑„ÅÑ„ÄÇ" },
    { name:"Á©∫Ë£Ç„Åç", slot:"weapon", fixed:{ atk: 30, spd:0.03, goldBonus:0.08, xpBonus:0.08 }, desc:"Âë®ÂõûÂäπÁéá„ÄÇ" },
    { name:"ÈòøÈ†ºËÄ∂„ÅÆÁõüÁ¥Ñ", slot:"armor", fixed:{ hp: 130, def: 16, shred:0.05, dr:0.04 }, desc:"Á°¨„ÅÑÈ≠î„Åª„Å©Âº∑„ÅÑ„ÄÇ" },
    { name:"ÂàπÈÇ£„ÅÆÈúúÂàÉ", slot:"weapon", fixed:{ atk: 26, crit:0.05, spd:0.03, dr:0.02 }, desc:"ÂÜ∑Ê∞ó„ÅÆÂàÉ„ÄÇ" },
    { name:"Ê≠£Âøµ„ÅÆÊè°„Çä", slot:"weapon", fixed:{ atk: 32, spd:-0.01, thorns:0.04, def:6 }, desc:"Êè°„Çä„ÅåÁ°¨„ÅÑ„ÄÇ" },
    { name:"Âõ†Á∏Å„ÅÆÁ≥∏", slot:"armor", fixed:{ hp: 100, def: 9, crit:0.04, regen:0.008 }, desc:"Êú™Êù•„ÇíË¶ã„ÇãÂ∏É„ÄÇ" },
    { name:"‰∫îËòä„ÅÆÊÆª", slot:"armor", fixed:{ hp: 160, def: 12, dr:0.04 }, desc:"ÂëΩÁâπÂåñ„ÄÇ" },
    { name:"ÂÖ´Ê≠£ÈÅì„ÅÆËøÖËº™", slot:"accessory", fixed:{ crit:0.06, xpBonus:0.06, dmgMult:0.03 }, desc:"ÊàêÈï∑Ë™ø‰ºèÂäõ„ÄÇ" },
    { name:"ÂäüÂæ≥„ÅÆÂç∞", slot:"accessory", fixed:{ goldBonus:0.18, luck:3 }, desc:"ÈáëÁ≠ñÂÖ®ÊåØ„Çä„ÄÇ" },
    { name:"ÂπªÂÆùÂå£„ÅÆÂæÆÁ¨ë", slot:"accessory", fixed:{ luck:7, goldBonus:0.07, xpBonus:0.07 }, desc:"ÁúüÂÅΩ‰∏çÊòé„ÄÇ" },
    { name:"Âõ†Êûú„ÅÆÂøÉËáì", slot:"accessory", fixed:{ def:5, spd:0.05, regen:0.006 }, desc:"ÂõûËª¢Êï∞„Åå‰∏ä„Åå„Çã„ÄÇ" },
    { name:"ÂøµÊ≠ª„ÅÆÈéÆÈ≠ÇÊ≠å", slot:"weapon", fixed:{ atk: 27, lifesteal:0.06, execute:0.03 }, desc:"Êöó„ÅÑ„Åª„Å©Âê∏„ÅÜ„ÄÇ" },
    { name:"ÊÖàÂÖâ„ÅÆÂÆà„Çä", slot:"armor", fixed:{ hp: 115, def: 13, dr:0.05 }, desc:"ÂÆâÂÆö„ÄÇ" },
    { name:"Ëã¶Ë´¶„ÅÆÂ•ëÁ¥Ñ", slot:"accessory", fixed:{ thorns:0.10, def:4, hp:40 }, desc:"ËøîÊ•≠„ÅßÂâä„Çã„ÄÇ" },
    { name:"ÈÅìËº™ÔºàÊ≠£ÈÅìÔºâ", slot:"accessory", fixed:{ spd:0.08, crit:0.03, luck:3 }, desc:"ËøÖË°åÁâπÂåñ„ÄÇ" },
    { name:"Ê•≠Â†±„ÅÆÂè∞Â∏≥", slot:"accessory", fixed:{ xpBonus:0.16, luck:4 }, desc:"ÁµåÈ®ìÊõ∏„ÄÇ" },
    { name:"Â∏ÉÊñΩ„ÅÆÈõ®", slot:"weapon", fixed:{ atk: 22, goldBonus:0.20, spd:0.02 }, desc:"Èáë„ÅåÈôç„Çã„ÄÇ" },
    { name:"ÁÅ∞Ááº„ÅÆÊàíËÉ∏", slot:"armor", fixed:{ hp: 125, def: 15, thorns:0.05 }, desc:"ÁÜ±„ÅÑÈéß„ÄÇ" },
    { name:"Á©∫ÊÄß„ÅÆÁ°ùÂ≠ê", slot:"weapon", fixed:{ atk: 25, crit:0.12, volatile:1 }, desc:"Â∞ñ„Çä„Åô„ÅéÔºàÊºîÂá∫Áî®Ôºâ„ÄÇ" },
    { name:"ÊàíË≠∑„ÅÆÁµê„Å≥", slot:"accessory", fixed:{ dr:0.07, def:6 }, desc:"Ëã¶Ê∏õ„ÄÇ" },
    { name:"Ê•≠Áéã„ÅÆÁ¨¶", slot:"accessory", fixed:{ execute:0.08, crit:0.04 }, desc:"‰ªïÁïô„ÇÅ„Çã„ÄÇ" },
    { name:"Á¶ÖÂÆö„ÅÆÂ§ñÂ•ó", slot:"armor", fixed:{ hp: 105, def: 11, spd:0.03, dr:0.02 }, desc:"Èùô„Åã„Å™Â§ñÂ•ó„ÄÇ" },
    { name:"Á•ñÂ∏´„ÅÆÈáëÂâõÊßç", slot:"weapon", fixed:{ atk: 29, shred:0.08, spd:0.01 }, desc:"Á†¥ÈöúÊßç„ÄÇ" },
    { name:"Á†¥ÈÇ™Èõ∑Âº©", slot:"weapon", fixed:{ atk: 27, crit:0.08, spd:0.05, dmgMult:0.03 }, desc:"Èõ∑„ÅÆÈÄ£Â∞Ñ„ÄÇ" },
    { name:"‰ªèÊÄßÁ´úÈ±óÈéß", slot:"armor", fixed:{ hp: 150, def: 17, dr:0.03, crit:0.02 }, desc:"È±ó„ÅåÂºæ„Åè„ÄÇ" },
    { name:"ÁÑ°Â∏∏„ÅÆÁ†ÇÊôÇË®à", slot:"accessory", fixed:{ spd:0.10, xpBonus:0.10, luck:2 }, desc:"ÊôÇÈñì„Åå‰º∏„Å≥„Çã„ÄÇ" },
    { name:"Êñ≠Ëº™Âªª„ÅÆÊ∑±Ê∑µÈéå", slot:"weapon", fixed:{ atk: 31, execute:0.08, lifesteal:0.04, crit:0.04 }, desc:"Âàà„ÇäÂèñ„Çã„ÄÇ" },
    { name:"Á∏ÅËµ∑È¢®Á¥ãËìÆËèØÂâ£", slot:"weapon", fixed:{ atk: 23, crit:0.14, spd:0.10 }, desc:"Âà∫Á™Å„ÅßËàû„ÅÜ„ÄÇ" },
    { name:"Áéã‰æØ„ÅÆ‰∏âÂ≠¶ÊàíÁí∞", slot:"accessory", fixed:{ crit:0.07, luck:8, goldBonus:0.05 }, desc:"Á∏Å„Å®ÂØå„ÄÇ" },
    { name:"ÊòüÂñ∞„ÅÑ„ÅÆÂ¶ÇÊù•ËîµÂÆùÁè†", slot:"accessory", fixed:{ dmgMult:0.06, atk: 4, crit:0.03 }, desc:"Ë™ø‰ºèÂäõÁâπÂåñ„ÄÇ" },
    { name:"ÈáëÂâõ‰∏çÂ£äÊùøË°£", slot:"armor", fixed:{ hp: 180, def: 20, regen:0.006, dr:0.04 }, desc:"ÂÄí„Çå„Å™„ÅÑ„ÄÇ" },
    { name:"Â§¢ÂπªÊ≥ïË°£", slot:"armor", fixed:{ hp: 95, def: 8, crit:0.08, spd:0.03 }, desc:"ËñÑ„ÅÑ„ÅåÈã≠„ÅÑ„ÄÇ" },
    { name:"ÊúâÊôÇ„ÅÆÊáê‰∏≠ÊôÇË®à", slot:"accessory", fixed:{ spd:0.09, def:3, regen:0.003 }, desc:"Âàª„ÇÄ„Åª„Å©ÈÄü„ÅÑ„ÄÇ" },
    { name:"Á†¥ÈÇ™Èõ∑Âº©", slot:"weapon", fixed:{ atk: 27, crit:0.08, spd:0.05, dmgMult:0.03 }, desc:"Èõ∑„ÇíÊ∫ú„ÇÅ„Å¶Êîæ„Å§„ÄÇ" },
    { name:"‰ªèÊÄßÁ´úÈ±óÈéß", slot:"armor", fixed:{ hp: 150, def: 17, dr:0.03, crit:0.02 }, desc:"Á°¨„Åï„Å®Èã≠„Åï„ÄÇ" },
    { name:"ÁÑ°Â∏∏„ÅÆÁ†ÇÊôÇË®à", slot:"accessory", fixed:{ spd:0.10, xpBonus:0.10, luck:3 }, desc:"ÊôÇÈñì„ÇíÂâä„Å£„Å¶ÈÄ≤„ÇÄ„ÄÇ" },
    { name:"Êñ≠Ëº™Âªª„ÅÆÊ∑±Ê∑µÈéå", slot:"weapon", fixed:{ atk: 31, execute:0.08, lifesteal:0.04 }, desc:"Âàà„ÇäÂèñ„Çã„Åü„ÇÅ„ÅÆÂàÉ„ÄÇ" },
    { name:"Á∏ÅËµ∑È¢®Á¥ãËìÆËèØÂâ£", slot:"weapon", fixed:{ atk: 23, crit:0.14, spd:0.10 }, desc:"È¢®„ÅÆÂà∫Á™Å„ÄÇ" },
    { name:"Áéã‰æØ„ÅÆ‰∏âÂ≠¶ÊàíÁí∞", slot:"accessory", fixed:{ crit:0.07, luck:8, goldBonus:0.05 }, desc:"ÂØå„Å®ÈñÉ„Åç„ÄÇ" },
    { name:"ÊòüÂñ∞„ÅÑ„ÅÆÂ¶ÇÊù•ËîµÂÆùÁè†", slot:"accessory", fixed:{ dmgMult:0.06, atk: 4, crit:0.03 }, desc:"Âê∏„ÅÑËæº„ÇÄ„Åª„Å©Âº∑„ÅÑ„ÄÇ" },
    { name:"ÈáëÂâõ‰∏çÂ£äÊùøË°£", slot:"armor", fixed:{ hp: 180, def: 20, dr:0.04, regen:0.006 }, desc:"ÂÄí„Çå„Å™„ÅÑÈéß„ÄÇ" },
    { name:"Â§¢ÂπªÊ≥ïË°£", slot:"armor", fixed:{ hp: 95, def: 8, crit:0.08, spd:0.03 }, desc:"ÂΩ±„ÅÆË°ìÂºè„ÄÇ" },
    { name:"ÊúâÊôÇ„ÅÆÊáê‰∏≠ÊôÇË®à", slot:"accessory", fixed:{ spd:0.09, def: 3, xpBonus:0.05 }, desc:"Èáù„ÅåÈÄü„ÅÑ„ÄÇ" },

  ];

  // --------------------
  // State
  // --------------------
  const KEY_V3 = "hackloot_single_v3_99999";
  const KEY_V4 = "hackloot_single_v4_fix_99999";
  const KEY_V5 = "hackloot_single_v5_ui_fix_99999";
  const KEY_V6 = "hackloot_single_v6_compare_ui_99999";
  const KEY_V7 = "hackloot_mikkyo_v1_jp_00001";
  const KEY_V8 = "hackloot_mikkyo_v2_dualmandala_00002";
  const MAX_LV = Number.POSITIVE_INFINITY;
  // Visual scaling reference for slash thickness (‰Ωç1=Á≥∏ / ‰Ωç99999=ÊúÄÂ§ßÂ§™„Åï)
  const LV_VIS_MAX = 99999;

  const STARTER_GEAR = {
    weapon: { id:"starter-weapon", slot:"weapon", ilv:1, rarity:"uncommon", name:"Ë®ìÁ∑¥Áî®„ÅÆËà¨Ëã•Ââ£", stats:{ atk: 18, crit:0.02, spd:0.08 }, desc:"Â∫èÁõ§ÂÆâÂÆö„ÄÇ", t: now() },
    armor:  { id:"starter-armor",  slot:"armor",  ilv:1, rarity:"uncommon", name:"ÂéöÁ∂øÁ¶ÖË°£",    stats:{ hp: 95, def: 10, dr:0.02 }, desc:"Ë©∞„ÅøÈò≤Ê≠¢„ÄÇ", t: now() },
    accessory:{ id:"starter-acc",  slot:"accessory", ilv:1, rarity:"common", name:"Ë°åÊóÖ„ÅÆË≠∑Á¨¶", stats:{ hp: 20, luck:2, xpBonus:0.04 }, desc:"ÊàêÈï∑Ë£úÂä©„ÄÇ", t: now() },
  };

  const defaultState = () => ({
    t: now(),
    version: 8,
    hero:{
      name:"Ë°åËÄÖ", nameSet:false,
      lv:1, exp:0,
      gold: 80,
      karma: 0,
      satori: 0,
      path:{},
      codex:{ realms:{}, events:{}, bosses:0, elites:0, uniques:0, mantras:0, purifies:0, kills:0, maxFloor:1 },
      mandala:"",
      mandalaSeal:{ kongo:0, taizo:0 },
      base:{ str:0, vit:0, def:0, luck:0 },
      guild:{ forge:0, bounty:0, library:0, shrine:0 },
      hp: 150,
      hpMax: 150,
      dead:false,
          lock:{ weapon:false, armor:false, accessory:false },
    },
    gear:{ weapon: STARTER_GEAR.weapon, armor: STARTER_GEAR.armor, accessory: STARTER_GEAR.accessory },
    inv:[],
    ui:{ tab:"all", preview:null, fx:1, sound:0, upgBulk:1, gupgBulk:1 },
    run:{
      active:false,
      floor:1,
      room:1,
      roomsPerFloor:30,
      enemy:null,
      enemyHp:0,
      enemyHpMax:0,
      isBoss:false,
      isElite:false,
      mods:[],
      lastTick: now(),
      speed:1,
      auto:true,
      offlineChest: null,
      _roomTime: 0,
      _lastEnemyHp: 0,
      history: [],
      entryShield: 0,
      entryShieldDR: 0.45,
      mantraUntil: 0,
      mantraCdUntil: 0,
      _eventLock: 0,
      _resumeAfterEvent: 0,
    },
    log:[]
  });

  function migrateToV8(obj){
    // Make old / partial saves safe to use in v2
    const d = defaultState();
    const o = (obj && typeof obj === 'object') ? obj : {};
    const out = { ...d, ...o };
    out.hero = { ...d.hero, ...(o.hero||{}) };
    out.hero.lock = { ...(d.hero.lock||{}), ...((o.hero||{}).lock||{}) };
    out.hero.guild = { ...(d.hero.guild||{}), ...((o.hero||{}).guild||{}) };
    out.hero.path = { ...(d.hero.path||{}), ...((o.hero||{}).path||{}) };
    out.hero.codex = { ...(d.hero.codex||{}), ...((o.hero||{}).codex||{}) };
    out.gear = { ...d.gear, ...(o.gear||{}) };
    out.ui = { ...d.ui, ...(o.ui||{}) };
    out.run = { ...d.run, ...(o.run||{}) };
    out.inv = Array.isArray(o.inv) ? o.inv : [];
    out.log = Array.isArray(o.log) ? o.log : [];
    out.version = 8;
    return out;
  }

  function tryLoadAny(){
    const s8 = load(KEY_V8);
    if (s8) return migrateToV8(s8);
    const s7 = load(KEY_V7);
    if (s7) return migrateToV8(s7);
    const s6 = load(KEY_V6);
    if (s6) return migrateToV8(s6);
    const s5 = load(KEY_V5);
    if (s5) return migrateToV8(s5);
    const s4 = load(KEY_V4);
    if (s4) return migrateToV8(s4);
    const s3 = load(KEY_V3);
    if (s3) return migrateToV8(s3);
    return null;
  }

  // --------------------
  // State init (fix: S was never declared/initialized, causing the game to not boot)
  // --------------------
  S = tryLoadAny() || defaultState();
  try{ ensureLogIds(); }catch(_){ }

  try{ ensureMikkyoFields(); }catch(_){}
  try{
    const tNow = now();
    const cdU = num(S.run && S.run.mantraCdUntil, 0);
    if (cdU > tNow){
      const left = (cdU - tNow) / 1000;
      if (left > 35){
        S.run.mantraCdUntil = tNow + 30*1000;
      }
    }
  }catch(_){}


  // v64: Ë™ø‰ºèÊºîÂá∫„ÇíÂªÉ„Åó„ÄÅË®ò„ÅÆ„Åø„ÅßÈÄ≤Ë°å„ÇíË°®Á§∫Ôºà„É≠„Ç∞„ÅÆ„Åø„ÅßÁä∂Ê≥Å„ÅåÂàÜ„Åã„Çã„Çà„ÅÜ„Å´Ôºâ
  try{
    S.ui = S.ui || {};
    S.ui.fx = 0;      // ÊºîÂá∫„ÅØÂ∏∏„Å´OFF
    S.ui.sound = 0;
  }catch(_){ }




  // --------------------
  // Guild bonus + Stat calc (fix)
  // --------------------
  function guildBonus(){
    // ÂÉßÂõ£‰ºΩËóçÔºàÂäüÂæ≥„ÉªÈï∑ÊúüÂêë„ÅëÔºâ„ÅØÂâäÈô§ÔºöÂ∏∏„Å´ÁÑ°ÂäπÂÄ§„ÇíËøî„Åô
    return { dropIlv:0, lootMult:1, goldMult:1, xpMult:1, rarityBoost:0 };
  }

  function calcStats(){
    // Central stat calc used by combat/UI/loot.
    ensureMikkyoFields();
    const h = S.hero;
    const base = calcStatsPure(S.gear);

    const mantraOn = (S.run && num(S.run.mantraUntil, 0) > 0 && now() < num(S.run.mantraUntil, 0));

    let goldMult2 = base.goldMult;
    let xpMult2   = base.xpMult;
    let dmgFactor = base.dmgFactor;
    let dr        = base.dr;

    // ÁúüË®ÄÔºàÁü≠ÊôÇÈñìÂä†ÊåÅÔºâ
    if (mantraOn){
      dmgFactor *= 1.60;
      goldMult2 *= 1.80;
      xpMult2   *= 1.80;
      dr = clamp(dr + 0.40, 0, 0.75);
    }



    // ÁµêÈ°òÔºàÂÖ≠Âç∞Ôºâ: Ê∞∏Á∂ö„ÅÆÂä†ÊåÅ
    try{
      ensureStoryFields();
      const ending = String((S.hero.codex && S.hero.codex.story && S.hero.codex.story.ending) || "");
      if (ending === "kongo"){
        // Ë™ø‰ºè: ÂàÉ„ÅåÂÜ¥„Åà„ÄÅÂäüÂæ≥„ÅÆÂ∑°„Çä„ÅåËâØ„Åè„Å™„Çã
        dmgFactor *= 1.18;
        goldMult2 *= 1.08;
      } else if (ending === "taizo"){
        // ÊÖàÊÇ≤: ÂÆà„Çä„ÅåÂéö„Åè„ÄÅ‰øÆË°å„ÅÆÁ©ç„Åø‰∏ä„Åí„ÅåÊó©„Åè„Å™„Çã
        dr = clamp(dr + 0.08, 0, 0.75);
        xpMult2 *= 1.10;
      }
    }catch(_){}
    const hpMax = Math.max(1, Math.round(base.hpMax));
    h.hpMax = hpMax;
    h.hp = clamp(num(h.hp, hpMax), 0, hpMax);

    // ÂÖ´Ê≠£ÈÅìÔºàÊ∞∏Á∂öÔºâ/ÂõûÂêë „ÅØÂâäÈô§Ê∏à„Åø
    return { ...base, hpMax, goldMult: goldMult2, xpMult: xpMult2, dmgFactor, dr, rarityExtra:0, mantraOn };
  }

  function calcStatsPure(gearObj){
    const h = S.hero;
    const eq = gearObj;
    const gB = guildBonus();
    const lv = h.lv;

    const baseAtk = 12 + lv*1.9 + Math.pow(lv, 1.08)*0.05;
    const baseDef =  6 + lv*0.95 + Math.pow(lv, 1.05)*0.02;
    const baseHp  = 110 + lv*16  + Math.pow(lv, 1.10)*0.25;

    const up = h.base;
    let atk = baseAtk + up.str*1.4;
    let def = baseDef + up.def*1.2;
    let hpMax = baseHp + up.vit*16;

    let crit = 0.06;
    let spd = 1.18;
    let luck = up.luck;

    let lifesteal = 0, thorns = 0, regen = 0, goldBonus = 0, xpBonus = 0, dmgMult = 0, dr = 0, execute = 0, shred = 0;

    for (const slot of SLOT_ORDER){
      const it = eq[slot];
      if (!it) continue;
      const st = it.stats || {};
      atk += st.atk || 0;
      def += st.def || 0;
      hpMax += st.hp || 0;
      crit += st.crit || 0;
      spd += st.spd || 0;
      luck += st.luck || 0;

      lifesteal = Math.max(lifesteal, st.lifesteal || 0);
      thorns = Math.max(thorns, st.thorns || 0);
      regen = Math.max(regen, st.regen || 0);
      goldBonus += st.goldBonus || 0;
      xpBonus += st.xpBonus || 0;
      dmgMult += st.dmgMult || 0;
      dr += st.dr || 0;
      execute = Math.max(execute || 0, st.execute || 0);
      shred = Math.max(shred || 0, st.shred || 0);
    }

    crit = clamp(crit, 0, 0.65);
    spd = clamp(spd, 0.55, 2.75);
    dr = clamp(dr, 0, 0.60);

    const luckFactor = 1 + (Math.min(luck, 60) * 0.015);
    const goldMult = (1 + goldBonus) * gB.goldMult;
    const xpMult = (1 + xpBonus) * gB.xpMult;

    return { atk, def, hpMax, crit, spd, luck, luckFactor, lifesteal, thorns, regen, goldMult, xpMult, dmgFactor:1+(dmgMult||0), dr, execute:execute||0, shred:shred||0, gB };
  }

  function expectedDps(st){
    // ÊúüÂæÖÂÄ§Âü∫Ôºà‰ºöÂøÉ1.6ÂÄçÔºâ
    const expHit = st.atk * st.dmgFactor * (1 + st.crit * 0.6);
    return expHit * st.spd;
  }

  function fmtSigned(n){
    const s = n >= 0 ? "+" : "‚àí";
    return s + fmt(Math.abs(n));
  }
  function fmtSignedPct(p){
    const s = p >= 0 ? "+" : "‚àí";
    return s + Math.abs(p).toFixed(1) + "%";
  }
  function fmtSignedPt(p){
    const s = p >= 0 ? "+" : "‚àí";
    return s + Math.abs(p*100).toFixed(1) + "pt";
  }

  function compareDeltaForItem(it){
    const slot = it.slot;
    const cur = S.gear[slot];
    const a = calcStatsPure(S.gear);
    const gear2 = { ...S.gear, [slot]: it };
    const b = calcStatsPure(gear2);

    const dpsA = expectedDps(a);
    const dpsB = expectedDps(b);
    const dpsPct = dpsA > 0 ? ((dpsB/dpsA)-1)*100 : 0;

    const delta = {
      dpsPct,
      atk: b.atk - a.atk,
      def: b.def - a.def,
      hpMax: b.hpMax - a.hpMax,
      crit: b.crit - a.crit,
      spd: b.spd - a.spd,
      luck: b.luck - a.luck,
      dr: b.dr - a.dr,
      lifesteal: b.lifesteal - a.lifesteal,
      shred: b.shred - a.shred,
      execute: b.execute - a.execute,
      goldMult: b.goldMult - a.goldMult,
      xpMult: b.xpMult - a.xpMult,
      curItem: cur,
      a, b
    };
    return delta;
  }

  function summarizeDelta(delta, slot){
    const parts = [];
    // Ë™ø‰ºè/Áßí is the main indicator for weapons, ÂëΩ/DEF for armor
    if (Number.isFinite(delta.dpsPct) && Math.abs(delta.dpsPct) >= 0.5) parts.push(`Ë™ø‰ºèÂäõ(Ë™ø‰ºè/Áßí) ${fmtSignedPct(delta.dpsPct)}`);
    if (Math.abs(delta.hpMax) >= 1) parts.push(`ÂëΩ ${fmtSigned(delta.hpMax)}`);
    if (Math.abs(delta.def) >= 1) parts.push(`ÊåÅÊàí ${fmtSigned(delta.def)}`);
    if (Math.abs(delta.atk) >= 1) parts.push(`ÈôçÈ≠î ${fmtSigned(delta.atk)}`);
    if (Math.abs(delta.crit) >= 0.002) parts.push(`ÊÖßÁúº ${fmtSignedPt(delta.crit)}`);
    if (Math.abs(delta.spd) >= 0.01) parts.push(`ËøÖË°å ${fmtSignedPct(delta.spd*100)}`); // ËøÖË°å„ÅØÂä†ÁÆóÔºà%ÂäüÂæ≥„Å£„ÅΩ„ÅèË°®Á§∫Ôºâ
    if (Math.abs(delta.dr) >= 0.002) parts.push(`Ëã¶Ê∏õ ${fmtSignedPt(delta.dr)}`);
    if (Math.abs(delta.lifesteal) >= 0.002) parts.push(`ÈÇÑÂëΩ ${fmtSignedPt(delta.lifesteal)}`);
    if (parts.length === 0) return "Âä†ÊåÅ‰∏≠„Å®„Åª„ÅºÂêåÁ≠â";
    return parts.slice(0, 6).join(" / ");
  }

  function deltaLines(delta){
    const lines = [];
    lines.push(`Âä†ÊåÅ‰∏≠„Çà„Çä: Ë™ø‰ºèÂäõ(Ë™ø‰ºè/Áßí) ${fmtSignedPct(delta.dpsPct)}`);
    lines.push(`ÈôçÈ≠î ${fmtSigned(delta.atk)}   ÊåÅÊàí ${fmtSigned(delta.def)}   ÂëΩ ${fmtSigned(delta.hpMax)}`);
    if (Math.abs(delta.crit) >= 0.0005 || Math.abs(delta.spd) >= 0.0005 || Math.abs(delta.luck) >= 0.1){
      lines.push(`ÊÖßÁúº ${fmtSignedPt(delta.crit)}   ËøÖË°å ${fmtSignedPct(delta.spd*100)}   Á∏Å ${fmtSigned(delta.luck)}`);
    }
    if (Math.abs(delta.dr) >= 0.0005 || Math.abs(delta.lifesteal) >= 0.0005 || Math.abs(delta.shred) >= 0.0005 || Math.abs(delta.execute) >= 0.0005){
      const extra = [];
      if (Math.abs(delta.dr) >= 0.0005) extra.push(`Ëã¶Ê∏õ ${fmtSignedPt(delta.dr)}`);
      if (Math.abs(delta.lifesteal) >= 0.0005) extra.push(`ÈÇÑÂëΩ ${fmtSignedPt(delta.lifesteal)}`);
      if (Math.abs(delta.shred) >= 0.0005) extra.push(`Á†¥Èöú ${fmtSignedPt(delta.shred)}`);
      if (Math.abs(delta.execute) >= 0.0005) extra.push(`Êñ≠Ê•≠ ${fmtSignedPt(delta.execute)}`);
      lines.push(extra.join("   "));
    }
    return lines.join("\n");
  }

  function setPreview(id){
    S.ui = S.ui ?? { tab:"all", preview:null };
    S.ui.preview = id;
    save();
    dirtyInv = true;
    dirtyHUD = true;
    renderInventory();
    renderCompare();
  }

  function clearPreview(){
    if (!S.ui) S.ui = { tab:"all", preview:null };
    S.ui.preview = null;
    save();
    dirtyInv = true;
    dirtyHUD = true;
    renderInventory();
    renderCompare();
  }

  function renderCompare(){
    if (!els.cmpPanel) return;
    const id = (S.ui && S.ui.preview) ? S.ui.preview : null;
    if (!id){
      if (els.cmpHint) els.cmpHint.style.display = "";
      if (els.cmpBody) els.cmpBody.style.display = "none";
      return;
    }
    const it = S.inv.find(x => x.id === id) || null;
    if (!it){
      clearPreview();
      return;
    }
    const slot = it.slot;
    const cur = S.gear[slot];

    const delta = compareDeltaForItem(it);

    if (els.cmpHint) els.cmpHint.style.display = "none";
    if (els.cmpBody) els.cmpBody.style.display = "";

    if (els.cmpSlotPill) els.cmpSlotPill.textContent = SLOT_NAME[slot] + ` / Âä†ÊåÅ‰Ωç ${fmt(it.ilv)}`;
    if (els.cmpNewRar){ els.cmpNewRar.className = `rar ${it.rarity}`; els.cmpNewRar.textContent = rarLabel(it.rarity); }
    if (els.cmpNewName) els.cmpNewName.textContent = dispItemName(it);
    if (els.cmpNewPower) els.cmpNewPower.textContent = `Âº∑„Åï ${fmt(itemPower(it))}`;
    if (els.cmpNewStats) els.cmpNewStats.textContent = statLinesWithCaps(it) + (it.desc ? `\n${it.desc}` : "");

    if (cur){
      if (els.cmpCurRar){ els.cmpCurRar.className = `rar ${cur.rarity}`; els.cmpCurRar.textContent = rarLabel(cur.rarity); }
      if (els.cmpCurName) els.cmpCurName.textContent = dispItemName(cur);
      if (els.cmpCurPower) els.cmpCurPower.textContent = `Âº∑„Åï ${fmt(itemPower(cur))}`;
    } else {
      if (els.cmpCurRar){ els.cmpCurRar.className = "rar common"; els.cmpCurRar.textContent = "‚Äî"; }
      if (els.cmpCurName) els.cmpCurName.textContent = "Êú™Âä†ÊåÅ";
      if (els.cmpCurPower) els.cmpCurPower.textContent = "";
    }

    const txt = deltaLines(delta);
    if (els.cmpDelta) els.cmpDelta.textContent = txt;

    if (els.btnEquipSelected){
      els.btnEquipSelected.onclick = () => { equip(it.id); clearPreview(); };
    }
    if (els.btnClearSelected){
      els.btnClearSelected.onclick = () => { clearPreview(); };
    }
  }

  // --------------------
  // Enemy
  // --------------------
  function enemyFor(floor, room, hero‰Ωç){
    const biome = biomeForFloor(floor);
    const roomsPerFloor = S.run.roomsPerFloor || 30;
    const isBoss = (room % 10 === 0) || (room === roomsPerFloor);
    const depth = (floor-1)*roomsPerFloor + room;
    const base = floor*2.3 + room*0.16 + Math.floor(depth*0.04);

    // ‰ΩçËøΩÂæìÔºà„ÇÑ„Çä„Åô„Åé„Çã„Å®„ÄéÊàª„Å£„Å¶„ÇÇÈ≠î„ÅåÂº±„Åè„Å™„Çâ„Å™„ÅÑ„ÄèÔºùË©∞„Åø„ÇÑ„Åô„ÅÑÔºâ
    // baseÔºàÈöéÂ±§/ÈÉ®Â±ãÔºâ„ÇíÂü∫Ê∫ñ„Å´„Åó„Å§„Å§„ÄÅË°åËÄÖ‰Ωç„ÅåÈ´ò„Åô„Åé„ÇãÂ†¥Âêà„Å†„ÅëÂ∞ë„Åó„Å†„ÅëÂºï„Åç‰∏ä„Åí„Çã„ÄÇ
    const follow = Math.floor(hero‰Ωç * 0.75);
    const cap = Math.floor(base + 10);
    const synced = Math.min(follow, cap);
    let ilv = Math.max(1, Math.floor(Math.max(base, synced)));

    // Âæ©Ê¥ªÁõ¥Âæå„ÅÆÊïëÊ∏àÔºöÊï∞ÈÉ®Â±ã„Å†„ÅëÈ≠î‰Ωç„Çí‰∏ã„Åí„ÇãÔºàÂÜçËµ∑Âãï„ÅÆ„Åü„ÇÅ„ÅÆÂõûÂæ©Â∏ØÔºâ
    const graceRooms = Math.max(0, Math.floor((S.run && S.run.reviveGraceRooms) || 0));
    if (graceRooms > 0){
      ilv = Math.max(1, ilv - 15);
    }
    let eliteChance = clamp(0.06 + depth*0.00025, 0.06, 0.45);
    // Âæ©Ê¥ªÁõ¥Âæå„ÅØÈ≠îËªç„ÇíÊäë„Åà„Å¶Á´ã„Å¶Áõ¥„Åó„ÇÑ„Åô„Åè„Åô„Çã
    if (graceRooms > 0) eliteChance *= 0.20;

    let isElite = !isBoss && (Math.random() < eliteChance);
    if (graceRooms > 0) isElite = false;
    const name = isBoss ? choice(biome.boss) : choice(biome.enemy);
    let modCount =
      isBoss ? (depth > 80 ? 2 : 1) :
      isElite ? (depth > 120 ? 2 : 1) :
      (depth > 140 && Math.random() < 0.22) ? 1 : 0;

    // Âæ©Ê¥ªÁõ¥Âæå„ÅÆÊïëÊ∏àÔºöÈùûÂ§©È≠î„ÅØ‰ªòÂ∏ØÁÑ°„Åó„ÅßÂÜçÈñãÔºàÁêÜ‰∏çÂ∞Ω‰∫ãÊïÖ„ÇíÊ∏õ„Çâ„ÅôÔºâ
    if (graceRooms > 0 && !isBoss){
      modCount = 0;
    }

    const mods = [];
    const used = new Set();
    for (let i=0;i<modCount;i++){
      const m = pickWeighted(MON_MODS, "w");
      if (used.has(m.key)) { i--; continue; }
      used.add(m.key);
      mods.push(m);
    }

    const modMult = mods.reduce((acc, m) => ({
      hp: acc.hp*m.mult.hp,
      atk: acc.atk*m.mult.atk,
      def: acc.def*m.mult.def,
    }), { hp:1, atk:1, def:1 });
    let hp = Math.round((60 + ilv*7.8 + Math.pow(ilv, 1.06)*0.95) * (isBoss ? 2.35 : 1.0) * (isElite ? 1.45 : 1.0) * biome.mult.hp * modMult.hp);
    let atk = (7.5 + ilv*1.12 + Math.pow(ilv, 1.06)*0.055) * (isBoss ? 1.22 : 1.0) * (isElite ? 1.16 : 1.0) * biome.mult.atk * modMult.atk;
    let def = (3 + ilv*0.52 + Math.pow(ilv, 1.04)*0.018) * (isBoss ? 1.12 : 1.0) * (isElite ? 1.16 : 1.0) * biome.mult.def * modMult.def;

    // Âæ©Ê¥ªÁõ¥Âæå„ÅÆÊïëÊ∏àÔºöÊï∞ÈÉ®Â±ã„Å†„ÅëÈ≠îÂäüÂæ≥Áõ∏„ÇíËªΩ„Åè„Åô„ÇãÔºàÊ∑±Â±§„Åß„ÇÇÂäπÊûú„ÅåÂá∫„Çã„Çà„ÅÜ„Å´Ôºâ
    if (graceRooms > 0 && !isBoss){
      hp = Math.max(1, Math.round(hp * 0.85));
      atk = atk * 0.85;
      def = def * 0.75;
    }

    // mod-derived extra properties
    const goldMul = mods.reduce((p,m)=> p * (m.goldMul || 1), 1.0);
    const xpMul   = mods.reduce((p,m)=> p * (m.xpMul || 1), 1.0);
    const karmaKill = mods.reduce((s,m)=> s + (m.karmaKill || 0), 0);

    return {
      name,
      biome: biome.name,
      realmKey: biome.key,
      ilv,
      isBoss,
      isElite,
      mods: mods.map(x => x.name),
      modKeys: mods.map(x => x.key),
      hp, atk, def,
      defMul: 1.0,
      enemyLs: mods.some(m=>m.key==="vampiric") ? 0.03 : 0.0,
      enemySpite: mods.some(m=>m.key==="spiteful") ? 0.04 : 0.0,
      mysticLoot: mods.some(m=>m.key==="mystic") ? 0.15 : 0.0,
      swift: mods.some(m=>m.key==="swift") ? 0.12 : 0.0,
      goldMul, xpMul, karmaKill,
    };
  }

  // --------------------
  // Loot
  // --------------------
  function rollRarity(luckFactor, rarityBoost){
    const boosted = RAR.map(r => {
      let w = r.w;
      if (r.key !== "common") w *= (0.92 + 0.18*luckFactor) * (1 + rarityBoost);
      if (r.key === "common") w *= (1.10 - 0.10*(luckFactor-1));
      return { ...r, w: Math.max(0.01, w) };
    });
    return pickWeighted(boosted, "w");
  }

  function scaleStats(statObj, ilv, mult){
    const s = {};
    for (const [k,v] of Object.entries(statObj)){
      if (k==="crit" || k==="spd" || k==="lifesteal" || k==="thorns" || k==="regen" || k==="goldBonus" || k==="xpBonus" || k==="dmgMult" || k==="dr" || k==="execute" || k==="shred"){
        const bump = (ilv * 0.0005) * (mult - 0.9);
        if (k==="execute" || k==="shred") s[k] = clamp(v + bump, 0, 0.35);
        else if (k==="dr") s[k] = clamp(v + bump*0.9, 0, 0.60);
        else s[k] = v + bump;
      } else if (k==="luck"){
        s[k] = Math.round((v + ilv/10) * mult);
      } else {
        s[k] = Math.round((v * mult) + (ilv * (k==="hp"? 2.5 : 1.05)) * mult);
      }
    }
    return s;
  }

  function rollUniqueAffCount(heroLuck, rarityBoost){
    // ÂÖ≠Âç∞„ÅÆÊ¨†Áâá‰ªò‰∏éÊï∞: ÊúÄÂ§ß8„ÄÇÈ´ò‰ªò‰∏é„ÅØÂ¶ôÂìÅ„ÄÇ
    // Á∏Å60Ë∂Ö„ÅØ„Äå‰ªò‰∏éÊï∞„Äç„Å†„Åë„Å´Âäπ„ÅèÔºàlog„ÅßÈÄìÊ∏õ„ÄÅ‰∏äÈôê„ÅÇ„ÇäÔºâ„ÄÇ
    const luck = Math.max(0, Number(heroLuck || 0));
    const over = Math.max(0, luck - 60);
    const boost = clamp(1 + (Math.log1p(over) / 20) + (Number(rarityBoost || 0) * 0.08), 1, 1.65);

    // Âü∫ÂàÜÂ∏ÉÔºà%Ôºâ: 1„Äú3„Åå‰∏≠ÂøÉ„ÄÅ6+„ÅØÊøÄÂ¶ôÂìÅ„ÄÇ8„ÅØË∂ÖÂ¶ôÂìÅ„ÄÇ
    const base = [
      {c:1, w:59.95},
      {c:2, w:25.00},
      {c:3, w:10.00},
      {c:4, w: 3.50},
      {c:5, w: 1.00},
      {c:6, w: 0.35},
      {c:7, w: 0.12},
      {c:8, w: 0.08},
    ].map(o => ({ c:o.c, w: o.w * Math.pow(boost, o.c - 1) }));

    return pickWeighted(base, 'w').c;
  }

  function makeItem(ilv, luckFactor, heroLuck, rarityBoost){
    const slot = choice(SLOT_ORDER);
    const rar = rollRarity(luckFactor, rarityBoost);

    if (rar.key === "unique"){
      const pool = UNIQUES.filter(x => x.slot === slot);
      const u = choice(pool);

      // Unique: Âõ∫ÊúâÂõ∫ÂÆöÂÄ§ + Â¶ôÂìÅÂÄçÁéáÔºàRAR.unique.multÔºâ„ÇíÈÅ©Áî®„Åó„Å¶‚Äú„Å°„ÇÉ„Çì„Å®Âº∑„ÅÑ‚Äù„Å´„Åô„Çã
      let merged = scaleStats(u.fixed, ilv, rar.mult);

      // Unique: Âõ∫Êúâ‰∏ªÈ°å„ÅØÂõ∫ÂÆö„Åó„Å§„Å§„ÄÅ‰ªò‰∏é„ÅØÊúÄÂ§ß8ÔºàÈ´ò‰ªò‰∏é„ÅØÊøÄÂ¶ôÂìÅÔºâ
      const used = new Set();
      const affCount = clamp(rollUniqueAffCount(heroLuck, rarityBoost), 1, 8);
      let lines = [];
      for (let i=0;i<affCount;i++){
        const a = pickWeighted(AFFIX, "w");
        if (used.has(a.key)) { i--; continue; }
        used.add(a.key);
        const before = merged[a.key] || 0;
        const add = a.apply(before, ilv);
        merged = { ...merged, ...add };
        lines.push(a.name);
      }

      const desc = u.desc + (lines.length ? ` / ‰ªò‰∏é: ${lines.join("„ÄÅ")}` : "");
      return { id: safeUUID(), slot, ilv, rarity:"unique", name:u.name, stats: merged, desc, t: now() };
    }

    const tmpl = slot === "weapon" ? choice(WEAPONS) : slot === "armor" ? choice(ARMORS) : choice(ACCS);
    const stats = scaleStats(tmpl.stat, ilv, rar.mult);

    const affCount = rar.aff;
    const used = new Set();
    let lines = [];
    let merged = { ...stats };
    for (let i=0;i<affCount;i++){
      const a = pickWeighted(AFFIX, "w");
      if (used.has(a.key)) { i--; continue; }
      used.add(a.key);
      const before = merged[a.key] || 0;
      const add = a.apply(before, ilv);
      merged = { ...merged, ...add };
      lines.push(a.name);
    }

    const prefix =
      rar.key==="legendary" ? choice(["Á•ûË©±„ÅÆ","Á†¥ÊªÖ„ÅÆ","Ëºù„Åè","Âè§‰ª£„ÅÆ","Áéã„ÅÆ"]) :
      rar.key==="epic" ? choice(["È≠îÂ∞é„ÅÆ","ÈªíÁæΩ„ÅÆ","Á¥´„ÅÆ","Âµê„ÅÆ","ËÅñ„Å™„Çã"]) :
      rar.key==="rare" ? choice(["‰∏äË≥™„Å™","Èã≠„ÅÑ","Á∏ÅËµ∑„ÅÆ","ËøÖÈÄü„Å™","‰∏çÂ±à„ÅÆ"]) :
      rar.key==="uncommon" ? choice(["È†ë‰∏à„Å™","Âàá„ÇåÂë≥„ÅÆËâØ„ÅÑ","„Åç„Çâ„ÇÅ„Åè","ËªΩÈáè„ÅÆ"]) :
      "";

    const fullName = prefix ? `${prefix}${tmpl.base}` : tmpl.base;
    return { id: safeUUID(), slot, ilv, rarity: rar.key, name: fullName, stats: merged, desc: lines.length ? `‰ªò‰∏é: ${lines.join("„ÄÅ")}` : "", t: now() };
  }

  function rarScore(k){ return ({common:0,uncommon:1,rare:2,epic:3,legendary:4,unique:5}[k] ?? 0); }

  function itemPower(it){
    const st = it.stats || {};
    const atk = st.atk||0, def = st.def||0, hp = st.hp||0;
    const crit = st.crit||0, spd = st.spd||0, luck=st.luck||0;
    const ls = st.lifesteal||0, th = st.thorns||0;
    const regen = st.regen||0;
    const gb = st.goldBonus||0, xb=st.xpBonus||0;
    const dm = st.dmgMult||0, dr=st.dr||0;
    const ex = st.execute||0, sh=st.shred||0;
    return (atk*2.3 + def*1.7 + hp*0.40 + crit*160 + spd*95 + luck*7
            + ls*140 + th*110 + regen*240 + gb*140 + xb*140 + dm*180 + dr*220 + ex*180 + sh*160)
            + rarScore(it.rarity)*42 + (it.ilv||1)*2.4;
  }

  // --------------------
  // Progression
  // --------------------
  function expNeed(lv){
    const a = 50 + Math.pow(lv, 1.50) * 16;
    const b = Math.pow(lv, 1.80) * 0.14;
    return Math.round(a + b);
  }

  function damage(att, def){
    const k = 1.35;
    return Math.max(1, Math.round((att*att) / (att + k*def)));
  }

  function grantExp(amount){
    const h = S.hero;
    h.exp += amount;
    let guard = 0;
    while (true){
      const need = expNeed(h.lv);
      if (!Number.isFinite(need) || need <= 0) break;
      if (h.exp < need) break;
      h.exp -= need;
      h.lv += 1;
      logImportant(`<span class="good">Êòá‰ΩçÔºÅ</span> ‰Ωç ${fmt(h.lv)}`);
      // ‰Ωç‰∏äÊòáÂä†ÊåÅ„ÅØÁÑ°„ÅóÔºàÈõ£ÊòìÂ∫¶Ë™øÊï¥Ôºâ
      guard += 1;
      if (guard > 2000){
        log(`<span class="warn">Ë≠¶Á≠ñ</span>: ‰ΩçË®àÁÆó„ÅåÈï∑„Åô„Åé„Çã„Åü„ÇÅ‰∏≠Êñ≠„Åó„Åæ„Åó„Åü„ÄÇ`);
        break;
      }
    }
    dirtyHUD = true;
  }

  // --------------------
  // Combat / Loop
  // --------------------
  function sanitizeRuntime(){
    const h = S.hero;
    const r = S.run;

    // hero numbers
    h.lv = clamp(int0(h.lv, 1), 1, MAX_LV);
    h.exp = Math.max(0, int0(h.exp, 0));
    h.gold = Math.max(0, int0(h.gold, 0));
    h.hpMax = Math.max(1, num(h.hpMax, 150));
    h.hp = clamp(num(h.hp, h.hpMax), 0, h.hpMax);

    h.lock = h.lock ?? { weapon:false, armor:false, accessory:false };
    for (const s of ['weapon','armor','accessory']) h.lock[s] = !!h.lock[s];

    // base / guild (oldË®òÈå≤„ÅßÊñáÂ≠óÂàó„ÇÑNaN„ÅåÊ∑∑„Åò„Å£„Å¶„ÇÇÂæ©Êóß)
    h.base = h.base ?? { str:0, vit:0, def:0, luck:0 };
    h.base.str = Math.max(0, int0(h.base.str, 0));
    h.base.vit = Math.max(0, int0(h.base.vit, 0));
    h.base.def = Math.max(0, int0(h.base.def, 0));
    h.base.luck= Math.max(0, int0(h.base.luck,0));

    h.guild = h.guild ?? { forge:0, bounty:0, library:0, shrine:0 };
    h.guild.forge = Math.max(0, int0(h.guild.forge, 0));
    h.guild.bounty = Math.max(0, int0(h.guild.bounty,0));
    h.guild.library= Math.max(0, int0(h.guild.library,0));
    h.guild.shrine = Math.max(0, int0(h.guild.shrine,0));

    // run numbers
    r.floor = Math.max(1, int0(r.floor, 1));
    r.room  = Math.max(1, int0(r.room,  1));
    r.roomsPerFloor = Math.max(1, int0(r.roomsPerFloor, 30));
    
// speed preset: 1 / 2 / 4 / 8 / MAX
// ÔºàÊóßË®òÈå≤„ÅÆ 0.05 / 0.1 / 0.25 / 16 / 32 / 256 „Å™„Å©„ÅØÂÆâÂÖ®„Å´„Çπ„Éä„ÉÉ„ÉóÔºâ
const _spMax = SPEED_MAX_LABEL;
const _spRaw = num(r.speed, 1);

// Old saves: if speed < 1, treat it as the new 1√ó (readable baseline).
let _sp = _spRaw;
if (_sp < 0.5) _sp = 1;
// Old MAX (256) or any very large number => MAX label
if (_sp >= 200) _sp = _spMax;

// Snap to nearest allowed label
let best = SPEED_ALLOWED[0];
let bestD = Math.abs(_sp - best);
for (const cand of SPEED_ALLOWED){
  const d = Math.abs(_sp - cand);
  if (d < bestD){ best = cand; bestD = d; }
}

// Gate MAX until the Mandala ledger has all six fragments.
try{
  if (best === _spMax && !hasAllSixFragments()){
    best = Math.max(...SPEED_ALLOWED.filter(v => v < _spMax));
  }
}catch(_){
  if (best === _spMax) best = Math.max(...SPEED_ALLOWED.filter(v => v < _spMax));
}
r.speed = clamp(best, 1, _spMax);
    r.lastTick = num(r.lastTick, now());
    r._acc = num(r._acc, 0);
    r._heroCd = num(r._heroCd, 0);
    r._enemyCd = num(r._enemyCd, 0);
    r._roomTime = num(r._roomTime, 0);
    r.entryShield = Math.max(0, num(r.entryShield, 0));
    r.entryShieldDR = clamp(num(r.entryShieldDR, 0.45), 0.30, 0.95);
    r._cheatCd = Math.max(0, num(r._cheatCd, 0));
    r._invuln  = Math.max(0, num(r._invuln,  0));

    // enemy hp sanityÔºàNaN/0„ÅßÊ≠¢„Åæ„Çã„ÅÆ„ÇíÈò≤„ÅêÔºâ
    if (r.enemy){
      const ehpMaxRaw = r.enemyHpMax;
      const ehpRaw = r.enemyHp;

      let ehpMax = num(ehpMaxRaw, 0);
      if (!Number.isFinite(ehpMax) || ehpMax <= 0){
        const base = num(r.enemy.hp, 1);
        ehpMax = base > 0 ? base : 1;
        r.enemyHpMax = ehpMax;
      }

      if (!Number.isFinite(Number(ehpRaw))){
        // ÂëΩ„ÅåNaN„Å´„Å™„Å£„Å¶Âõ∫„Åæ„Çã‰æãÔºöÂëΩ„ÇíÊúÄÂ§ß„Å´Êàª„Åó„Å¶Á∂öË°å
        r.enemyHp = ehpMax;
        if (!r._enemyHpRecoverLogged){
          try{ log(`<span class="warn">Âæ©Êóß</span>: È≠îÂëΩ„ÅåÂ£ä„Çå„Å¶„ÅÑ„Åü„Åü„ÇÅÂæ©ÂÖÉ„Åó„Åæ„Åó„Åü`); } catch{}
          r._enemyHpRecoverLogged = true;
          dirtyLog = true;
        }
      } else {
        const ehp = num(ehpRaw, ehpMax);
        if (ehp <= 0 && ehpMax > 0){
          // „ÄåÈ≠î„ÅåÂ±Ö„Çã„ÅÆ„Å´ÂëΩ0„Äç„ÅßË©∞„ÇÄ‰æãÔºöÈ≠î„ÇíÂÜçÁîüÊàê
          r.enemy = null;
          r.enemyHp = 0;
          r.enemyHpMax = 0;
          r.isBoss = false;
          r.isElite = false;
          r.mods = [];
          r._roomTime = 0;
          if (!r._enemyZeroRecoverLogged){
            try{ log(`<span class="warn">Âæ©Êóß</span>: Ë™ø‰ºèÁä∂ÊÖã„ÅåÂ£ä„Çå„Å¶„ÅÑ„Åü„Åü„ÇÅ„ÄÅÈ≠î„ÇíÂÜçÈÖçÁΩÆ„Åó„Åæ„Åó„Åü`); } catch{}
            r._enemyZeroRecoverLogged = true;
            dirtyLog = true;
          }
          dirtyHUD = true;
        } else {
          r.enemyHp = clamp(ehp, 0, ehpMax);
          r.enemyHpMax = ehpMax;
        }
      }
    } else {
      r.enemyHp = num(r.enemyHp, 0);
      r.enemyHpMax = num(r.enemyHpMax, 0);
    }
  }

  function ensureEnemy(){
    const r = S.run;
    if (!r.enemy){
      const e = enemyFor(r.floor, r.room, S.hero.lv);
      try{ if (e && e.realmKey) touchRealm(e.realmKey); }catch(_){ }
      r.enemy = e;
      r.enemyHp = e.hp;
      r.enemyHpMax = e.hp;

      if (r.reviveGraceRooms && r.reviveGraceRooms>0) r.reviveGraceRooms--;
      r.isBoss = e.isBoss;
      r.isElite = e.isElite;
      r.mods = e.mods || [];
      r._roomTime = 0;
      r._lastEnemyHp = r.enemyHp;

      // vBattleLog+: reset aggregated combat log when a new enemy appears (avoid stale enemy names)
      resetBattleAgg();

      const modText = r.mods.length ? ` <span class="warn">[${modsHtml(r.mods)}]</span>` : "";
      const eliteText = e.isElite ? ` <span class="gold">ÔºàÈáçÁÖ©Ôºâ</span>` : "";
      const bossText = e.isBoss ? ` <span class="rare">ÔºàÊ†πÊú¨Ôºâ</span>` : "";
      const hpNow0 = fmt(Math.max(0, Math.round(S.hero.hp)));
      const hpMax0 = fmt(Math.round(S.hero.hpMax));
      log(`ÁèæÂâç: <span class="${e.isBoss?'rare':''}">${dispEnemyName(e.name)}</span>${eliteText}${bossText}${modText} (Êà¶Âà©ÂìÅ‰Ωç ${fmt(e.ilv)} / ÂëΩ ${hpNow0}/${hpMax0})`);
      dirtyHUD = true;
    }
  }

  function startExplore(){
    if (S.hero.dead) return;
    S.run.active = true;
    S.run.lastTick = now();
    try{
      const b = biomeForFloor(S.run.floor);
      if (b && maybeRealmPrologue(b.key, b.name)) { save(); dirtyHUD = true; return; }
    }catch(_){ }
    ensureEnemy();
    save();
    dirtyHUD = true;
  }
  function pauseExplore(){ S.run.active = false; save(); dirtyHUD = true; }

  function nextRoom(force=false){
    if (S.hero.dead) return;
    const r = S.run;
    if (!force && r.enemy && r.enemyHp > 0) return;

    r.history = Array.isArray(r.history) ? r.history : [];
    r.history.push({ floor:r.floor, room:r.room });
    if (r.history.length > 60) r.history.shift();

    // ÂÖ•ÂÆ§Ê∫ñÂÇôÔºàÁü≠„ÅÑÂÆâÂÖ®ÊôÇÈñì„ÅÆ„ÅøÔºöÂä†ÊåÅ„ÅØÁÑ°„ÅóÔºâ
    r.entryShield = 1.2; // Áßí

    r.room += 1;
    if (r.room > r.roomsPerFloor){
      r.floor += 1;
      r.room = 1;
      logImportant(`<span class="good">Â±§ ${r.floor}</span> „Å´Âà∞ÈÅî„ÄÇÂÖ≠ÈÅì: ${biomeForFloor(r.floor).name}`);
    }
    r.enemy = null;
    r.enemyHp = 0;
    r.enemyHpMax = 0;

    // ÁïåÈñÄÔºàÁ´†Ôºâ: ÂàùÂÖ•Áïå„ÅÆÂ∞éÂÖ•
    try{
      const b = biomeForFloor(r.floor);
      if (b && maybeRealmPrologue(b.key, b.name)) { save(); dirtyHUD = true; return; }
    }catch(_){ }

    // ÂØÜÊïôÂÑÄÁ§ºÔºàÂÑÄÁ§ºÔºâ
    if (maybeTriggerEvent()){ save(); dirtyHUD = true; return; }

    ensureEnemy();
    save();
    dirtyHUD = true;
  }

  function prevRoom(){
    if (S.hero.dead) return;
    const r = S.run;
    r.history = Array.isArray(r.history) ? r.history : [];
    if (!r.history.length){
      log(`<span class="warn">Êàª„Çå„Åæ„Åõ„Çì</span>: „Åì„Çå‰ª•‰∏ä„ÄÅÂâç„ÅÆÈñì„Å∏„ÅØÊàª„Çå„Åæ„Åõ„Çì„ÄÇ`);
      dirtyLog = true;
      return;
    }
    const prev = r.history.pop();
    r.floor = Math.max(1, Math.floor(prev.floor || 1));
    r.room = Math.max(1, Math.floor(prev.room || 1));
    // Êàª„Å£„ÅüÁõ¥Âæå„ÅÆÁü≠„ÅÑÂÆâÂÖ®ÊôÇÈñì„ÅÆ„ÅøÔºöÂä†ÊåÅ„ÅØÁÑ°„Åó
    r.entryShield = 0.9;

    r.enemy = null;
    r.enemyHp = 0;
    r.enemyHpMax = 0;

    // ÁïåÈñÄÔºàÁ´†Ôºâ: ÂàùÂÖ•Áïå„ÅÆÂ∞éÂÖ•
    try{
      const b = biomeForFloor(r.floor);
      if (b && maybeRealmPrologue(b.key, b.name)) { save(); dirtyHUD = true; return; }
    }catch(_){ }

    // ÂØÜÊïôÂÑÄÁ§ºÔºàÂÑÄÁ§ºÔºâ
    if (maybeTriggerEvent()){ save(); dirtyHUD = true; return; }

    ensureEnemy();
    save();
    dirtyHUD = true;
  }


  function maybeAutoEquip(item){
    const slot = item.slot;
    const cur = S.gear[slot];
    if (S.hero && S.hero.lock && S.hero.lock[slot] && cur){ return; }
    if (!cur) return equip(item.id);

    // Ëá™ÂãïÂä†ÊåÅ„ÅÆÂäüÂæ≥ÁÇπË®àÁÆó„Åß„ÅØ„ÄÅÁ∏Å60Ë∂Ö„ÅØÈÅéÂ§ßË©ï‰æ°„Åó„Å™„ÅÑÔºàÊéà‰∏éÁ∏Å„ÅÆ‰∏äÈôê„Å´Âêà„Çè„Åõ„ÇãÔºâ„ÄÇ
    // ‚ÄªÁ∏Å60Ë∂Ö„ÅÆ‰æ°ÂÄ§„ÅØ„ÄéÂÖ≠Âç∞„ÅÆÊ¨†Áâá‰ªò‰∏éÊï∞„ÄèÂÅ¥„ÅßÂë≥„Çè„Åà„Çã„ÅÆ„Åß„ÄÅ„Åì„Åì„Åß„ÅØÂà∞ÈÅîÂàÜ„Å†„ÅëË©ï‰æ°„Åô„Çã„ÄÇ
    let curTotalLuck = (S.hero.base && S.hero.base.luck) ? S.hero.base.luck : 0;
    for (const s of SLOT_ORDER){
      const it = S.gear[s];
      if (it && it.stats && it.stats.luck) curTotalLuck += it.stats.luck;
    }
    const curLuck = (cur && cur.stats && cur.stats.luck) ? cur.stats.luck : 0;
    const candLuck = (item && item.stats && item.stats.luck) ? item.stats.luck : 0;

    const otherLuck = curTotalLuck - curLuck;
    const capSpace = Math.max(0, 60 - otherLuck);
    const curEffLuck = Math.min(curLuck, capSpace);
    const candEffLuck = Math.min(candLuck, capSpace);

    const curScore  = itemPower(cur)  - curLuck*7  + curEffLuck*7;
    const candScore = itemPower(item) - candLuck*7 + candEffLuck*7;

    if (candScore > curScore * 1.12){
      equip(item.id);
      log(`<span class="good">Ëá™ÂãïÂä†ÊåÅ</span>: ${SLOT_NAME[slot]}„ÇíÊõ¥Êñ∞`);
    }
  }

  function shouldAutoSell(item){
    const ui = S.ui || {};
    if (!(Number(ui.autoSellOn) === 1)) return false;

    const maxR = (ui.autoSellRarMax != null) ? String(ui.autoSellRarMax) : "common";
    const protectUnique = !(Number(ui.autoSellProtectUnique) === 0);
    if (protectUnique && item.rarity === "unique" && maxR !== "unique") return false;

    const useEq = (Number(ui.autoSellUseEq) === 1);
    const eqPct = clamp(num(ui.autoSellEqPct, 90), 1, 100) / 100;

    let match = false;

    if (maxR && maxR !== "none"){
      const a = RAR_RANK[item.rarity] ?? 0;
      const b = RAR_RANK[maxR] ?? 0;
      if (a <= b) match = true;
    }

    if (useEq){
      const cur = S.gear[item.slot];
      if (cur){
        const curScore = itemPower(cur);
        const candScore = itemPower(item);
        if (candScore < curScore * eqPct) match = true;
      }
    }

    return match;
  }

  function dropLoot(ilv, st, e){
    const gB = st.gB;
    // reset aggregated auto-sell counters for this drop batch
    S.run._autoSoldN = 0;
    S.run._autoSoldG = 0;
    ensureMikkyoFields();
    const karma = clampKarma(S.hero.karma||0);
    const karmaPos = Math.max(0, karma), karmaNeg = Math.max(0, -karma);
    const satori = Math.max(0, Math.floor(S.hero.satori||0));
    let count = 0;
    const base = e.isBoss ? 1 : (Math.random() < 0.52 ? 1 : 0);
    count += base;
    if (e.isElite && Math.random() < 0.70) count += 1;
    if (Math.random() < clamp((st.luckFactor-1)*0.30, 0, 0.40)) count += 1;
    if (Math.random() < clamp(satori/150000, 0, 0.12)) count += 1;
    // ‰∫îÊØí„ÄåË≤™„Äç: ËøΩÂä†Êéà‰∏éÔºàÊ¨≤„ÅØÂ†±ÈÖ¨„ÇíÂëº„Å∂„Åå„ÄÅÊ•≠„ÇÇÂ¢ó„Åà„ÇãÔºâ
    if (e && e.modKeys && e.modKeys.includes("greed") && Math.random() < 0.78) count += 1;

    const extraRolls = Math.floor(gB.lootMult - 1);
    for (let i=0;i<extraRolls;i++) if (Math.random() < 0.52) count += 1;
    if (Math.random() < (gB.lootMult - 1 - extraRolls)) count += 1;

    const dropCap = (e.isBoss ? 5 : 3) + ((e && e.modKeys && e.modKeys.includes("greed")) ? 1 : 0);
    count = clamp(count, 0, dropCap);
    const itemIlv = ilv + gB.dropIlv + (e.isBoss ? 2 : 0) + (e.isElite ? 1 : 0);
    const karmBoost = (karmaPos/108)*0.05 - (karmaNeg/108)*0.03;
    const satBoost = Math.min(0.06, satori/60000);
    const rarityBoost = gB.rarityBoost + (e.mysticLoot || 0) + (st.rarityExtra || 0) + karmBoost + satBoost;

    for (let i=0;i<count;i++){
      const it = makeItem(itemIlv, st.luckFactor, st.luck, rarityBoost);
      if (it && it.rarity === "unique"){
        const rk = biomeForFloor(S.run.floor).key;
        applySealToUnique(it, rk);
        grantSealFragment(rk);
      }
      S.inv.push(it);
      const rarName = RAR.find(r=>r.key===it.rarity)?.name ?? it.rarity;
      const rarTag = (it.rarity === "unique") ? "‚òÖÂÖ≠Âç∞Ê¨†Áâá" : rarName;
      log(`Âä†ÊåÅ: <span class="rar ${it.rarity}">${rarTag}</span> ${SLOT_NAME[it.slot]}„Äå${dispItemName(it)}„Äç`);
      maybeAutoEquip(it);
      if (it.rarity === "unique"){ try{ ensureMikkyoFields(); S.hero.codex.uniques = (S.hero.codex.uniques||0) + 1; }catch(_){ } }

      // Auto-sell (instant) if enabled and the dropped item is still in inventory (i.e., not equipped)
      if (S.inv.findIndex(x=>x.id===it.id) >= 0 && shouldAutoSell(it)){
        const idx = S.inv.findIndex(x=>x.id===it.id);
        if (idx >= 0){
          const soldIt = S.inv[idx];
          const rar = RAR.find(r=>r.key===soldIt.rarity) ?? RAR[0];
          const base = 8 + (soldIt.ilv||1) * 2.7;
          const price = Math.round(base * rar.sell);
          S.hero.gold += price;
          S.inv.splice(idx, 1);
          // aggregate log to reduce spam
          S.run._autoSoldN = (S.run._autoSoldN||0) + 1;
          S.run._autoSoldG = (S.run._autoSoldG||0) + price;
        }
      }
    }

    if (S.run._autoSoldN){
      const n = S.run._autoSoldN || 0;
      const g = S.run._autoSoldG || 0;
      log(`<span class="warn">Ëá™ÂãïÂ∏ÉÊñΩ</span>: ${n}ÂÄã <span class="gold">(+${fmt(g)}ÂäüÂæ≥)</span>`);
      dirtyHUD = true;
    }

    if (S.inv.length > 900){
      autoTrimInventory();
    }
    dirtyInv = true;
  }

  function autoTrimInventory(){
    let target = 700;
    if (S.inv.length <= target) return;
    let sold = 0, got = 0;
    const low = S.inv.filter(it => it.rarity==="common" || it.rarity==="uncommon");
    low.sort((a,b)=> itemPower(a)-itemPower(b));
    const toSell = [];
    for (const it of low){
      if (S.inv.length - toSell.length <= target) break;
      toSell.push(it);
    }
    if (!toSell.length){
      const all = S.inv.slice().sort((a,b)=> itemPower(a)-itemPower(b));
      for (const it of all){
        if (S.inv.length - toSell.length <= target) break;
        toSell.push(it);
      }
    }
    const set = new Set(toSell.map(x=>x.id));
    const keep = [];
    for (const it of S.inv){
      if (set.has(it.id)){
        const rar = RAR.find(r=>r.key===it.rarity) ?? RAR[0];
        const base = 8 + (it.ilv||1) * 2.7;
        const price = Math.round(base * rar.sell);
        got += price; sold++;
      } else keep.push(it);
    }
    S.inv = keep;
    S.hero.gold += got;
    log(`<span class="warn">Ëá™ÂãïÊï¥ÁêÜ</span>: Ê≥ïÂÖ∑Â∫´ËÇ•Â§ßÂåñ„ÅÆ„Åü„ÇÅ${sold}ÂÄã„ÇíÂ∏ÉÊñΩ <span class="gold">(+${fmt(got)}ÂäüÂæ≥)</span>`);
    dirtyInv = true; dirtyHUD = true;
  }

  // --------------------
  // Battle detail log (vBattleLog+)
  // --------------------
  function heroDispName(){
    const n = (S.hero && typeof S.hero.name==="string" && S.hero.name.trim()) ? S.hero.name.trim() : "Ë°åËÄÖ";
    return n;
  }
  function weaponDispName(){
    try{
      const w = S && S.gear && S.gear.weapon;
      return w ? dispItemName(w) : "Á¥†Êâã";
    } catch(_){
      return "Á¥†Êâã";
    }
  }
  function enemyAtkName(e){
    const rk = (e && e.realmKey) ? e.realmKey : "";
    const base = {
      hell:["ÁûãÁÅ´ÊíÉ","Ê•≠Áà™","ÁÜ±ÊÇ©„ÅÆÊÅØ","Ê•≠ÁÅ´„ÅÆÈéñ"],
      hungry:["Ê∏áÊÑõÂô¨","Ê∏áÁâô","ÊÄ®Âöô„Åø","Ê∏áÊÑõ„ÅÆÂë™Âîæ"],
      animal:["ÁÑ°ÊòéÂôõ„Åø","ÁÑ°ÊòéËßí","ÊØíÁâô","ÁåõË∫ç"],
      asura:["ÈóòË´çÊñ¨","Êà¶Ëº™ÊíÉ","È¨ºÊßå","ÁæÖÂàπ„ÅÆÈÄ£ÊíÉ"],
      human:["ÂàÜÂà•Á™Å„Åç","Âë™Áü¢","Â¶ÑÂü∑Âë™Ë©õ","Â•™ÂëΩ„ÅÆÊâã"],
      deva:["ÊúâÈ†ÇÈõ∑","È¢®ÂàÉ","Â§©Êßç","ÂÖâËº™"],
    };
    const list = base[rk] || ["ÈóáÊíÉ","Âë™ÊíÉ","Ë£ÇÂÇ∑"];
    let name = choice(list);
    const mk = (e && e.modKeys) ? e.modKeys : [];
    if (mk.includes("anger")) name = "ÊøÄÊòÇ" + name;
    else if (mk.includes("envy")) name = "Â•™ÂäüÂæ≥" + name;
    else if (mk.includes("greed")) name = "Ë≤™Ê¨≤" + name;
    else if (mk.includes("pride")) name = "ÂÇ≤ÊÖ¢" + name;
    else if (mk.includes("ignorance")) name = "Êú¶Êúß" + name;
    if (e && e.isBoss) name += "„ÉªÂ••Áæ©";
    return name;
  }
  function resetBattleAgg(){
    try{
      const r = S.run;
      r._battleAgg = null;
      r._battleAggEnemy = null;
      r._battleLogCd = 0;
    } catch(_){}
  }
  function battleAggEnsure(e){
    const r = S.run;
    if (!r._battleAgg || r._battleAggEnemy !== e){
      r._battleAggEnemy = e;
      r._battleAgg = {
        heroName: heroDispName(),
        weaponName: weaponDispName(),
        enemyName: e ? dispEnemyName(e.name) : "È≠î",
        heroHits:0, heroDmg:0, heroCrit:0, heroMax:0, heroHeal:0, heroSelfDmg:0, selfBefore:NaN, selfAfter:NaN,
        enemyHits:0, enemyDmg:0, enemyMax:0, shieldHits:0, spiteDmg:0,
        thornsDmg:0, enemyHeal:0, atkNames:[],
      };
      r._battleLogCd = Number.isFinite(r._battleLogCd) ? r._battleLogCd : 0;
    }
    // refresh labels (gear/name can change mid-fight)
    try{ r._battleAgg.heroName = heroDispName(); r._battleAgg.weaponName = weaponDispName(); if (e) r._battleAgg.enemyName = dispEnemyName(e.name); } catch(_){ }
    return r._battleAgg;
  }
  function pushUnique(arr, v, limit=3){
    if (!v) return;
    if (arr.indexOf(v) >= 0) return;
    if (arr.length < limit) arr.push(v);
  }
  function flushBattleAgg(force){
    const r = S.run;
    const agg = r._battleAgg;
    if (!agg) return;
    if (!force && (r._battleLogCd || 0) > 0) return;
    // heroSelfDmg„Å†„ÅëÁô∫Áîü„Åô„Çã„Ç±„Éº„ÇπÔºàÊÖ¢„ÅÆËøîÊ•≠„Å™„Å©Ôºâ„ÇÇ„ÅÇ„Çã
    if (!(agg.heroHits || agg.enemyHits || agg.heroSelfDmg)) return;
    // MAX speed / ËøÖË°åMAX: never build combat-detail log strings (heavy).
    if (isLogLite()){
      // Clear the accumulator quickly and skip rendering.
      r._battleAgg = null;
      r._battleAggEnemy = null;
      // Keep a small cooldown so callers won't keep trying to flush immediately.
      r._battleLogCd = 0.35;
      _logLiteBump();
      return;
    }


    const hpNow = fmt(Math.max(0, Math.round(S.hero.hp)));
    const hpMax = fmt(Math.round(S.hero.hpMax));
    const hasEnemyHP = (r.enemyHpMax > 0);
    const ehpNow = hasEnemyHP ? fmt(Math.max(0, Math.round(r.enemyHp))) : "";
    const ehpMax = hasEnemyHP ? fmt(Math.round(r.enemyHpMax)) : "";

    // vBattleLog+: show actual HP change for ËøîÊ•≠ (clamped to min 1), and keep the raw ËøîÊ•≠ÂÄ§ as note when they differ
    const selfLoss = (agg.heroSelfDmg && Number.isFinite(agg.selfBefore) && Number.isFinite(agg.selfAfter))
      ? Math.max(0, Math.round(agg.selfBefore - agg.selfAfter))
      : 0;
    const selfNote = (agg.heroSelfDmg && selfLoss && Math.abs(selfLoss - agg.heroSelfDmg) > 1)
      ? ` <span class="mutedTxt">(ËøîÊ•≠ÂÄ§${fmt(agg.heroSelfDmg)} / ‰∏ãÈôêÈÅ©Áî®)</span>`
      : "";

    // ---- linesÔºàË¶ã„ÇÑ„Åô„ÅÑ„Çà„ÅÜ„Å´ÂàÜËß£Ôºâ
    let heroLine = "";
    if (agg.heroHits){
      heroLine = `<span class="good">ÈôçÈ≠î</span> ${agg.heroName}„Äå${agg.weaponName}„Äç√ó${agg.heroHits} ÂêàË®à${fmt(agg.heroDmg)} Ëã¶`
        + (agg.heroCrit ? `Ôºà<span class="rare">Á†¥È≠î</span> ${agg.heroCrit}Ôºâ` : "")
        + (agg.heroHeal ? ` / <span class="good">Âê∏ÂëΩ</span>+${fmt(agg.heroHeal)}` : "")
        + `ÔºàÊúÄÂ§ß‰∏ÄÊíÉ${fmt(agg.heroMax)}Ôºâ`;
    }

    let selfLine = "";
    if (agg.heroSelfDmg){
      selfLine = `<span class="warn">ËøîÊ•≠</span> ÂëΩ ${fmt(agg.selfBefore)}‚Üí${fmt(agg.selfAfter)} (-${fmt(selfLoss)})${selfNote}`
        + (agg.heroMax ? ` <span class="mutedTxt">(ÊúÄÂ§ß‰∏ÄÊíÉ${fmt(agg.heroMax)})</span>` : "");
    }

    let enemyLine = "";
    if (agg.enemyHits){
      const atk = agg.atkNames.length ? agg.atkNames.join(" / ") : "ÈôçÈ≠î";
      enemyLine = `<span class="bad">È≠îÊíÉ</span> ${agg.enemyName}„Äå${atk}„Äç√ó${agg.enemyHits} ÂêàË®à${fmt(agg.enemyDmg)} Ëã¶`
        + (agg.spiteDmg ? ` / <span class="warn">ËøΩÊíÉ</span>+${fmt(agg.spiteDmg)}` : "")
        + (agg.thornsDmg ? ` / <span class="good">ËøîËã¶</span>${fmt(agg.thornsDmg)}` : "")
        + (agg.enemyHeal ? ` / <span class="warn">ÂõûÂæ©</span>+${fmt(agg.enemyHeal)}` : "")
        + (agg.shieldHits ? ` <span class="good">ÁµêÁïå</span>` : "")
        + `ÔºàÊúÄÂ§ß‰∏ÄÊíÉ${fmt(agg.enemyMax)}Ôºâ`;
    }

    const statusLine = hasEnemyHP
      ? `ÂëΩ ${hpNow}/${hpMax} / È≠îÂëΩ ${ehpNow}/${ehpMax}`
      : `ÂëΩ ${hpNow}/${hpMax}`;

    let detailParts = [];
    try{
      if (agg.lastEnemy && Number.isFinite(agg.lastEnemy.hpBefore)){
        detailParts.push(`Ë¢´Âºæ ÂëΩ ${fmt(agg.lastEnemy.hpBefore)}‚Üí${fmt(agg.lastEnemy.hpAfter)} (-${fmt(agg.lastEnemy.dmg)})`);
      }
      if (hasEnemyHP && agg.lastHero && Number.isFinite(agg.lastHero.ehpBefore)){
        detailParts.push(`ÈôçÈ≠î È≠îÂëΩ ${fmt(agg.lastHero.ehpBefore)}‚Üí${fmt(agg.lastHero.ehpAfter)} (-${fmt(agg.lastHero.dmg)})`);
      }
    }catch(_){ detailParts = []; }

    const lines = [];
    if (heroLine) lines.push(heroLine);
    if (selfLine) lines.push(selfLine);
    if (enemyLine) lines.push(enemyLine);

    // „Éâ„É©„ÇØ„Ç®È¢®Ôºö„Å†„Çå„Åå‚Üí„Å™„Å´„Çí„Åó„Åü‚ÜíÁµêÊûúÔºà„ÉÄ„É°„Éº„Ç∏/ÂõûÂæ©Ôºâ„ÇíÊñáÁ´†„ÅßÂá∫„Åô
    const dq = [];

    if (agg.heroHits){
      const n = agg.heroName || "Ë°åËÄÖ";
      const target = agg.enemyName || "Êïµ";
      dq.push(`<span class="good">${n}</span>„ÅÆÊîªÊíÉÔºÅ`);
      const tail = (agg.heroHits > 1)
        ? ` <span class="mutedTxt">(${agg.heroHits}Âõû / ÊúÄÂ§ß${fmt(agg.heroMax)})</span>`
        : ` <span class="mutedTxt">(ÊúÄÂ§ß${fmt(agg.heroMax)})</span>`;
      dq.push(`<span class="indent">${target}„Å´${fmt(agg.heroDmg)}„ÅÆ„ÉÄ„É°„Éº„Ç∏ÔºÅ</span>` + tail);
      if (agg.heroCrit){
        dq.push(`<span class="indent"><span class="rare">‰ºöÂøÉ„ÅÆ‰∏ÄÊíÉÔºÅ</span> √ó${fmt(agg.heroCrit)}</span>`);
      }
      if (agg.heroHeal){
        dq.push(`<span class="indent">${n}„ÅØ${fmt(agg.heroHeal)}ÂõûÂæ©„Åó„Åü„ÄÇ</span>`);
      }
    }

    if (agg.heroSelfDmg){
      const n = agg.heroName || "Ë°åËÄÖ";
      dq.push(`<span class="warn">${n}„ÅØÊ•≠„ÅÆÂèçÂãï„ÇíÂèó„Åë„Åü‚Ä¶</span>`);
      dq.push(`<span class="indent">${n}„ÅØ${fmt(selfLoss)}„ÅÆ„ÉÄ„É°„Éº„Ç∏„ÇíÂèó„Åë„Åü„ÄÇ</span>${selfNote}`);
    }

    if (agg.enemyHits){
      const enemy = agg.enemyName || "Êïµ";
      const hero  = agg.heroName || "Ë°åËÄÖ";
      const atk = agg.atkNames.length ? agg.atkNames.join(" / ") : "ÊîªÊíÉ";
      dq.push(`<span class="bad">${enemy}</span>„ÅÆÊîªÊíÉÔºÅ <span class="mutedTxt">„Äå${atk}„Äç</span>`);
      const tail = (agg.enemyHits > 1)
        ? ` <span class="mutedTxt">(${agg.enemyHits}Âõû / ÊúÄÂ§ß${fmt(agg.enemyMax)})</span>`
        : ` <span class="mutedTxt">(ÊúÄÂ§ß${fmt(agg.enemyMax)})</span>`;
      dq.push(`<span class="indent">${hero}„ÅØ${fmt(agg.enemyDmg)}„ÅÆ„ÉÄ„É°„Éº„Ç∏„ÇíÂèó„Åë„ÅüÔºÅ</span>` + tail);

      if (agg.shieldHits){
        dq.push(`<span class="indent"><span class="good">ÁµêÁïå</span>„Åå„ÉÄ„É°„Éº„Ç∏„ÇíËªΩÊ∏õ„Åó„ÅüÔºÅ</span>`);
      }
      if (agg.spiteDmg){
        dq.push(`<span class="indent"><span class="warn">ËøΩÊíÉ</span>„ÅßËøΩÂä†${fmt(agg.spiteDmg)}„ÉÄ„É°„Éº„Ç∏ÔºÅ</span>`);
      }
      if (agg.thornsDmg){
        dq.push(`<span class="indent"><span class="good">ÂèçÊíÉ</span>ÔºÅ${enemy}„Å´${fmt(agg.thornsDmg)}„ÅÆ„ÉÄ„É°„Éº„Ç∏ÔºÅ</span>`);
      }
      if (agg.enemyHeal){
        dq.push(`<span class="indent">${enemy}„ÅØ${fmt(agg.enemyHeal)}ÂõûÂæ©„Åó„Åü„ÄÇ</span>`);
      }
    }
    let msg = dq.join("<br>");
    log(msg);

    // reset counters but keep labels
    agg.heroHits=0; agg.heroDmg=0; agg.heroCrit=0; agg.heroMax=0; agg.heroHeal=0; agg.heroSelfDmg=0; agg.selfBefore=NaN; agg.selfAfter=NaN;
    agg.enemyHits=0; agg.enemyDmg=0; agg.enemyMax=0; agg.shieldHits=0; agg.spiteDmg=0;
    agg.thornsDmg=0; agg.enemyHeal=0; agg.atkNames.length=0;

    // reset last-hit details
    agg.lastHero = null;
    agg.lastEnemy = null;

    r._battleLogCd = 0.22; // seconds (real-time)
    dirtyLog = true;
  }

  function tick(dt){
    const r = S.run;
    if (!r.active) return;
    if (S.hero.dead) { r.active=false; dirtyHUD=true; return; }

    ensureEnemy();
    const e = r.enemy;
    const st = calcStatsFast();

    // Cache: is attack-speed (ËøÖË°å) at cap? used for log-lite mode.
    r._spdIsMax = (Number(st.spd) >= (2.75 - 1e-6));


    // vBattleLog+: throttle combat detail logs by real time (dt is simulated)
    const spdNow = effectiveSimSpeedScaled(r.speed);
    const realDt = dt / Math.max(1e-6, spdNow);
    r._battleLogCd = Math.max(0, (Number.isFinite(r._battleLogCd) ? r._battleLogCd : 0) - realDt);
    battleAggEnsure(e);

    r._roomTime = Number.isFinite(r._roomTime) ? r._roomTime : 0;
    r._roomTime += dt;

    // cd ÂÆâÂÆöÂåñ
    r._heroCd = Number.isFinite(r._heroCd) ? r._heroCd : 0;
    r._enemyCd = Number.isFinite(r._enemyCd) ? r._enemyCd : 0;
    r.entryShield = Math.max(0, (r.entryShield || 0) - dt);

    // v9: Ëá¥Ê≠ªÂõûÈÅø/ÁÑ°È≠î„ÅÆÊôÇË®àÊõ¥Êñ∞
    r._cheatCd = Number.isFinite(r._cheatCd) ? r._cheatCd : 0;
    r._invuln  = Number.isFinite(r._invuln)  ? r._invuln  : 0;
    r._cheatCd = Math.max(0, r._cheatCd - dt);
    r._invuln  = Math.max(0, r._invuln  - dt);

    if (st.regen > 0){
      S.hero.hp = clamp(S.hero.hp + (st.regen * S.hero.hpMax * dt), 1, S.hero.hpMax);
    }

    r._heroCd = (r._heroCd ?? 0) - dt;
    r._enemyCd = (r._enemyCd ?? 0) - dt;

    // ÈôçÈ≠îÈÄüÂ∫¶„ÅåÊ•µÁ´Ø„Å´‰∏ä„Åå„Çã„Å®„ÄÅ1tickÂÜÖ„ÅÆËº™Ëª¢ÂõûÊï∞„ÅåÁàÜÂ¢ó„Åó„Å¶Èñ≤Ë¶ßÂô®„ÅåÂõ∫„Åæ„Çã„Åü„ÇÅ‰∏äÈôê„ÇíË®≠„Åë„Çã
    const cappedSpd = clamp(st.spd, 0.2, 20);
    if (cappedSpd != st.spd && !r._spdCapLogged){
      logImportant(`<span class="warn">Ë≤†Ëç∑ÂØæÁ≠ñ</span>: ÈôçÈ≠î„ÅÆËøÖË°å„ÅåÈ´ò„Åô„Åé„Çã„Åü„ÇÅ„ÄÅÂá¶ÁêÜ‰∏äÈôêÔºà20Âõû/ÁßíÔºâ„ÇíÈÅ©Áî®„Åó„Åæ„Åó„Åü`);
      r._spdCapLogged = true;
      dirtyLog = true;
    }
    const heroInterval = 1 / cappedSpd;
    const enemyBaseInterval = e.isBoss ? 1.00 : 1.25;
    const enemyInterval = clamp(enemyBaseInterval * (1 - e.swift), 0.50, 2.00);

    const MAX_ACTS_PER_TICK = isSpeedMax() ? 60 : 120;
    let heroActs = 0;
    while (r._heroCd <= 0 && r.enemyHp > 0 && !S.hero.dead){
      if (++heroActs > MAX_ACTS_PER_TICK){
        // ÊÆã„Çä„ÅØÊ¨°tick„Å´Âõû„Åó„Å¶Âõ∫„Åæ„Çä„ÇíÈò≤„Åê
        r._heroCd = heroInterval;
        if (!r._actsCapLogged){
          if (!isLogLite()) log(`<span class="warn">Ë≤†Ëç∑ÂØæÁ≠ñ</span>: 1Êõ¥Êñ∞ÂÜÖ„ÅÆÈôçÈ≠îÂõûÊï∞„ÅåÂ§ö„Åô„Åé„Çã„Åü„ÇÅ„ÄÅ‰∏ÄÈÉ®„ÇíÊ¨°Êõ¥Êñ∞„Å´Âõû„Åó„Åæ„Åó„ÅüÔºàËøÖË°å„Çí‰∏ã„Åí„Çã„Å®ÂÆâÂÆöÔºâ`);
          r._actsCapLogged = true;
          dirtyLog = true;
        }
        break;
      }

      r._heroCd += heroInterval;

      e.defMul = Math.max(0.45, e.defMul * 0.995);
      // ‰∫îÊØí„ÄåË≤™„Äç: Âè©„Åè„Åª„Å©ÂÆà„Çä„ÇíÂõ∫„ÇÅ„ÇãÔºàÊéà‰∏é„ÅØÁîò„ÅÑÔºâ
      if (e && e.modKeys && e.modKeys.includes("greed") && Math.random() < 0.14){
        e.defMul = clamp(e.defMul + 0.012, 0.45, 1.25);
        if (Math.random() < 0.06) if (!isLogLite()) log(`<span class="warn">Ë≤™</span>: ÊåÅÊàí„ÇíÂõ∫„ÇÅ„Åü`);
      }

      const enemyDef = e.def * e.defMul;
      const shredMul = 1 - clamp(st.shred, 0, 0.35);
      const finalEnemyDef = enemyDef * shredMul;

      let isCrit = Math.random() < st.crit;
      const hasIgn = (e && e.modKeys && e.modKeys.includes("ignorance"));
      if (hasIgn && isCrit){ isCrit = false; if (Math.random()<0.10) if (!isLogLite()) log(`<span class="warn">Áó¥</span>: Á†¥È≠î„ÅåÂ∞ÅÂç∞„Åï„Çå„Åü`); }
      let att = st.atk * st.dmgFactor;
      if (isCrit) att *= 1.6;

      let dmg = damage(att, finalEnemyDef);

      if (st.execute > 0 && r.enemyHp / r.enemyHpMax < 0.25){
        dmg = Math.round(dmg * (1 + st.execute));
      }

      if (r._roomTime > 22){
        const trueDmg = Math.max(1, Math.round(r.enemyHpMax * 0.004));
        dmg += trueDmg;
      }

      const ehpBefore = Number.isFinite(r.enemyHp) ? r.enemyHp : 0;
      r.enemyHp = Math.max(0, r.enemyHp - dmg);
      const ehpAfter = Number.isFinite(r.enemyHp) ? r.enemyHp : 0;

      
          try { if (typeof BATTLE !== 'undefined' && BATTLE) { BATTLE.heroAttack(isCrit, dmg); BATTLE.enemyHit(dmg, isCrit); } } catch (_) {}
      const aggH = battleAggEnsure(e);
      try{ aggH.lastHero = { dmg, isCrit, ehpBefore, ehpAfter }; }catch(_){ }
      aggH.heroHits++;
      aggH.heroDmg += dmg;
      aggH.heroMax = Math.max(aggH.heroMax, dmg);
      if (isCrit) aggH.heroCrit++;

      let lsHeal = 0;
      if (st.lifesteal > 0){
        lsHeal = Math.max(1, Math.round(dmg * st.lifesteal));
        S.hero.hp = clamp(S.hero.hp + lsHeal, 1, S.hero.hpMax);
      }
      if (lsHeal) aggH.heroHeal += lsHeal;

      // ‰∫îÊØí„ÄåÊÖ¢„Äç: ËøîÊ•≠ÔºàËá¥Ê≠ª„Å´„ÅØ„Åó„Å™„ÅÑÔºâ
      if (e && e.modKeys && e.modKeys.includes("pride") && dmg > 0){
        const ref0 = Math.max(1, Math.round(dmg * (0.10 + (e.isBoss?0.04:0))));
        const ref = Math.max(1, Math.round(ref0 * (1 - st.dr*0.5)));
        const selfBefore = Math.max(0, Math.round(S.hero.hp));
        S.hero.hp = Math.max(1, S.hero.hp - ref);
        const selfAfter  = Math.max(0, Math.round(S.hero.hp));
        try{
          aggH.heroSelfDmg += ref;
          if (!Number.isFinite(aggH.selfBefore)) aggH.selfBefore = selfBefore;
          aggH.selfAfter = selfAfter;
        }catch(_){ }
        if (Math.random() < 0.08) if (!isLogLite()) log(`<span class="warn">ÊÖ¢</span>: ËøîÊ•≠ ${fmt(ref)} Ëã¶`);
      }

      if (r.enemyHp <= 0){
        const biome = biomeForFloor(r.floor);
        const goldBase = (11 + e.ilv*2.15 + Math.pow(e.ilv, 1.05)*0.33) * (e.isBoss?2.2:1.0) * (e.isElite?1.45:1.0) * biome.loot.gold;
        const xpBase   = (15 + e.ilv*2.4 + Math.pow(e.ilv, 1.06)*0.38) * (e.isBoss?2.35:1.0) * (e.isElite?1.45:1.0) * biome.loot.xp;

        let gold = Math.round(goldBase * st.goldMult * (e.goldMul||1));
        // ‰∫îÊØí„ÄåË≤™„Äç: „Åï„Çâ„Å´Â∞ë„Åó„Å†„ÅëÂäüÂæ≥„ÅåÂ¢ó„Åà„ÇãÔºà‰ª£„Çè„Çä„Å´Ê•≠„ÅåÂ¢ó„Åà„ÇãÔºâ
        const bonusGoldFromGreed = (e && e.modKeys && e.modKeys.includes("greed")) ? Math.round(gold * 0.12) : 0;
        gold += bonusGoldFromGreed;
        const xp   = Math.round(xpBase * st.xpMult * (e.xpMul||1));

        S.hero.gold += gold;
        grantExp(xp);
        try{ onEnemyDefeated(e, gold, xp); }catch(_){ }

        flushBattleAgg(true);
        if (!isLogLite()){
          log(`<span class="good">ÊíÉÁ†¥</span>: ${e.name}ÔºàÊúÄÂæå„ÅÆÈôçÈ≠î: ${isCrit?'<span class="rare">Á†¥È≠î</span> ':''}${fmt(dmg)} Ëã¶Ôºâ <span class="gold">(+${fmt(gold)}ÂäüÂæ≥)</span> (+${fmt(xp)}ÁµåÈ®ì)`);
        } else {
          _logLiteBump();
        }
        // ÊíÉÁ†¥ÊôÇÂä†ÊåÅ„ÅØÁÑ°„ÅóÔºàÈõ£ÊòìÂ∫¶Ë™øÊï¥Ôºâ

        dropLoot(e.ilv, st, e);

        
        try { if (typeof BATTLE !== 'undefined' && BATTLE) { BATTLE.enemyDie(); } } catch (_) {}
r.enemy = null;
        r.enemyHp = 0;
        r.enemyHpMax = 0;

        if (r.auto) nextRoom();
        break;
      }
    }

    let enemyActs = 0;
    while (r._enemyCd <= 0 && r.enemyHp > 0 && !S.hero.dead){
      if (++enemyActs > 80){
        r._enemyCd = enemyInterval;
        if (!r._enemyActsCapLogged){
          if (!isLogLite()) log(`<span class="warn">Ë≤†Ëç∑ÂØæÁ≠ñ</span>: 1Êõ¥Êñ∞ÂÜÖ„ÅÆÈ≠îÈôçÈ≠îÂõûÊï∞„ÅåÂ§ö„Åô„Åé„Çã„Åü„ÇÅ„ÄÅ‰∏ÄÈÉ®„ÇíÊ¨°Êõ¥Êñ∞„Å´Âõû„Åó„Åæ„Åó„Åü`);
          r._enemyActsCapLogged = true;
          dirtyLog = true;
        }
        break;
      }

      r._enemyCd += enemyInterval;

      // ÁÑ°È≠î‰∏≠ÔºàËá¥Ê≠ªÂõûÈÅøÂæå„Å™„Å©Ôºâ„ÅØÈ≠î„ÅÆÈôçÈ≠î„ÇíÁÑ°ÂäπÂåñ
      if ((r._invuln || 0) > 0){
        if (Math.random() < 0.05){
          if (!isLogLite()) log(`<span class="good">ÁÑ°È≠î</span>: ÈôçÈ≠î„ÇíÁÑ°ÂäπÂåñ`);
        }
        continue;
      }

      // ‰∫îÊØí„ÄåÁûã„Äç: Âè©„Åè„Åª„Å©ÊÄí„Çä„ÅåÂ¢ó„Åó„ÄÅÈôçÈ≠î„ÅåÂ∞ñ„Çã
      if (e && e.modKeys && e.modKeys.includes("anger")) {
        e._rage = clamp((e._rage||0) + 1, 0, 30);
        if (e._rage <= 30) e.atk *= 1.006;
      }

      let dmg = damage(e.atk, st.def);
      dmg = Math.round(dmg * (1 - st.dr));
      if ((r.entryShield || 0) > 0){
        dmg = Math.max(0, Math.round(dmg * (1 - (r.entryShieldDR ?? 0.45))));
      }

      const hpBefore = Number.isFinite(S.hero.hp) ? S.hero.hp : 0;
      const hpAfter = hpBefore - dmg;
      const bigHit = dmg >= (S.hero.hpMax * 0.18);

      // Ëá¥Ê≠ªÂõûÈÅø„ÅØÁÑ°ÂäπÔºàÈõ£ÊòìÂ∫¶Ë™øÊï¥Ôºâ

      S.hero.hp = Math.max(0, hpAfter);

      // ‰∫îÊØí„ÄåÂ´â„Äç: Âæ≥Âê∏„ÅÑÔºàÂ∞ë„Åó„Åö„Å§Â•™„ÅÜ„ÄÇË®é‰ºê„Åß‰∏ÄÈÉ®ÂõûÂèéÔºâ
      if (e && e.modKeys && e.modKeys.includes("envy") && dmg > 0 && Math.random() < 0.32){
        const curG = Math.max(0, Math.floor(S.hero.gold||0));
        const steal = Math.min(curG, Math.max(1, Math.round(curG*0.004 + e.ilv*0.35)));
        S.hero.gold = Math.max(0, curG - steal);
        e._stolenGold = (e._stolenGold||0) + steal;
        if (Math.random() < 0.20) if (!isLogLite()) log(`<span class="warn">Â´â</span>: ÂäüÂæ≥„ÇíÂê∏„Çè„Çå„Åü (-${fmt(steal)})`);
      }
      // ‰∫îÊØí„ÄåÁûã„Äç: ÂèóËã¶„ÅßÂøÉ„ÅåËçí„Çå„ÄÅÊ•≠„ÅåÂÇæ„Åç„ÇÑ„Åô„ÅÑ
      if (e && e.modKeys && e.modKeys.includes("anger") && dmg > 0){
        if (Math.random() < 0.10) addKarma(-1);
}

      
      try { if (typeof BATTLE !== 'undefined' && BATTLE) { BATTLE.enemyAttack(dmg); BATTLE.heroHit(dmg); } } catch (_) {}

      let thornsDmg = 0;
      if (st.thorns > 0){
        thornsDmg = Math.max(1, Math.round(dmg * st.thorns));
        r.enemyHp = Math.max(0, r.enemyHp - thornsDmg);
      }

      let enemyHeal = 0;
      if (e.enemyLs > 0){
        enemyHeal = Math.max(1, Math.round(dmg * e.enemyLs));
        r.enemyHp = clamp(r.enemyHp + enemyHeal, 0, r.enemyHpMax);
      }

      // ËøΩÊíÉÔºàÊÄ®ÂóüÔºâ„ÇÇËá¥Ê≠ªÂõûÈÅø„ÅÆÂØæË±°„Å´„Åô„Çã
      let extraDmg = 0;
      if (e.enemySpite > 0 && Math.random() < 0.20){
        extraDmg = Math.max(1, Math.round(dmg * e.enemySpite));
        const hp2 = S.hero.hp - extraDmg;
        // Ëá¥Ê≠ªÂõûÈÅø„ÅØÁÑ°ÂäπÔºàÈõ£ÊòìÂ∫¶Ë™øÊï¥Ôºâ
        S.hero.hp = Math.max(0, hp2);
      }

      // vBattleLog+: Ë©≥Á¥∞Êà¶Ê≥ÅÔºàÈ≠î„ÅÆÊîªÊíÉÂêç/ÂèóËã¶Èáè„ÇíË°®Á§∫Ôºâ
      const aggE = battleAggEnsure(e);
      const atkName = enemyAtkName(e);
      pushUnique(aggE.atkNames, atkName, 3);
      aggE.enemyHits++;
      const totalDmg = dmg + extraDmg;
      try{ aggE.lastEnemy = { enemy: dispEnemyName(e.name), atk: atkName, dmg: totalDmg, base: dmg, extra: extraDmg, hpBefore, hpAfter: (Number.isFinite(S.hero.hp)?S.hero.hp:0), shield: ((r.entryShield||0)>0), shieldDR: (r.entryShieldDR ?? 0.45) }; }catch(_){ }
      aggE.enemyDmg += totalDmg;
      aggE.enemyMax = Math.max(aggE.enemyMax, totalDmg);
      if ((r.entryShield || 0) > 0) aggE.shieldHits++;
      if (extraDmg) aggE.spiteDmg += extraDmg;
      if (thornsDmg) aggE.thornsDmg += thornsDmg;
      if (enemyHeal) aggE.enemyHeal += enemyHeal;

      // ÁÄïÊ≠ª/Â§ßÂÆ≥„ÅØÂç≥Ë°®Á§∫
      if (bigHit || S.hero.hp <= S.hero.hpMax*0.22){
        flushBattleAgg(true);
      }

      if (S.hero.hp <= 0){
        flushBattleAgg(true);
        S.hero.dead = true;
        
      try { if (typeof BATTLE !== 'undefined' && BATTLE) { BATTLE.heroDie(); } } catch (_) {}
S.run.active = false;
        S.run.enemy = null;
        S.run.enemyHp = 0;
        S.run.enemyHpMax = 0;
        logImportant(`<span class="bad">Ë™ø‰ºè„Å´Ëá≥„Çâ„Åö</span>‚Ä¶ÔºàÊ≠ªÂõ†: ${dispEnemyName(e.name)}„Äå${atkName}„Äç ÂèóËã¶:${fmt(totalDmg)} / ÂëΩ:${fmt(hpBefore)}‚Üí0` + (((r.entryShield||0)>0)?` / ÁµêÁïå(-${Math.round((r.entryShieldDR ?? 0.45)*100)}%)`:'') + `Ôºâ`);
        dirtyHUD = true;
        break;
      }
    }

    flushBattleAgg(false);

    dirtyHUD = true;
  }

  // --------------------
  // Inventory actions
  // --------------------
  function equip(itemId){
    const idx = S.inv.findIndex(x=>x.id===itemId);
    if (idx < 0) return;
    const it = S.inv[idx];
    const slot = it.slot;
    const cur = S.gear[slot];
    if (cur) S.inv.push(cur);
    S.gear[slot] = it;
    S.inv.splice(idx,1);
    markStatsDirty();
    log(`Âä†ÊåÅ: ${SLOT_NAME[slot]}„Äå${it.name}„Äç`);
    calcStats();
    save();
    dirtyInv = true;
    dirtyHUD = true;
  }

  function sell(itemId){
    const idx = S.inv.findIndex(x=>x.id===itemId);
    if (idx < 0) return;
    const it = S.inv[idx];
    const rar = RAR.find(r=>r.key===it.rarity) ?? RAR[0];
    const base = 8 + (it.ilv||1) * 2.7;
    const price = Math.round(base * rar.sell);
    S.hero.gold += price;
    S.inv.splice(idx,1);
    log(`Â∏ÉÊñΩ: ${dispItemName(it)} <span class="gold">(+${fmt(price)}ÂäüÂæ≥)</span>`);
    save();
    dirtyInv = true;
    dirtyHUD = true;
  }

  function sellWhere(fn){
    let sold = 0, got = 0;
    const keep = [];
    for (const it of S.inv){
      if (fn(it)){
        const rar = RAR.find(r=>r.key===it.rarity) ?? RAR[0];
        const base = 8 + (it.ilv||1) * 2.7;
        const price = Math.round(base * rar.sell);
        got += price; sold++;
      } else keep.push(it);
    }
    S.inv = keep;
    if (sold){
      S.hero.gold += got;
      log(`‰∏ÄÊã¨Â∏ÉÊñΩ: ${sold}ÂÄã <span class="gold">(+${fmt(got)}ÂäüÂæ≥)</span>`);
      save();
      dirtyInv = true;
      dirtyHUD = true;
    }
  }

  // --------------------
  // Upgrades
  // --------------------
  function upgradeCost(){
    const u = S.hero.base;
    const total = u.str + u.vit + u.def + u.luck;
    return Math.round(42 + Math.pow(total+1, 1.28) * 21);
  }

  function clampBulk(n){
    n = Math.floor(Number(n)||1);
    if (n <= 1) return 1;
    if (n <= 10) return 10;
    if (n <= 100) return 100;
    if (n <= 1000) return 1000;
    return 10000;
  }

  function buyUpgradeN(key, count){
    const n = clampBulk(count);
    let bought = 0;
    let spent = 0;
    for (let i=0; i<n; i++){
      const cost = upgradeCost();
      if (S.hero.gold < cost) break;
      S.hero.gold -= cost;
      spent += cost;
      S.hero.base[key] += 1;
      bought++;
    }
    if (!bought){
      const cost = upgradeCost();
      log(`<span class="bad">‰∏çË∂≥</span>: ÊòáÊ†º„Å´${fmt(cost)}Âæ≥„ÅåÂøÖË¶Å„Åß„Åô`);
      return;
    }
    const note = (bought < n) ? ` (${bought}/${n})` : "";
    log(`<span class="good">Êã†ÁÇπÂº∑Âåñ</span>: ${UPG_LABEL[key] || key} +${bought}${note} <span class="gold">(-${fmt(spent)}ÂäüÂæ≥)</span>`);
    calcStats();
    save();
    dirtyHUD = true;
    markStatsDirty();
  }

  function buyUpgrade(key){
    return buyUpgradeN(key, 1);
  }


  function guildCost(which){
    const g = S.hero.guild;
    const lv = g[which] || 0;
    const base = 230 + Math.pow(lv+1, 1.50) * 190;
    const slope = (which==="forge") ? 1.10 : (which==="library") ? 1.15 : 1.00;
    return Math.round(base * slope);
  }

  function buyGuildN(which, count){
    const n = clampBulk(count);
    const cap = guildCap(which);
    const cur0 = Math.max(0, Math.floor(num(S.hero.guild[which], 0)));

    if (cur0 >= cap){
      log(`<span class="warn">‰∏äÈôê</span>: ${GUILD_LABEL[which] || which} „ÅØ‰Ωç${cap}„ÅßÈ†≠Êâì„Å°„Åß„Åô„ÄÇ`);
      dirtyLog = true;
      return;
    }

    const want = Math.min(n, cap - cur0);

    let bought = 0;
    let spent = 0;
    for (let i=0; i<want; i++){
      const cost = guildCost(which);
      if (S.hero.gold < cost) break;
      S.hero.gold -= cost;
      spent += cost;
      S.hero.guild[which] = (S.hero.guild[which]||0) + 1;
      bought++;
    }

    if (!bought){
      const cost = guildCost(which);
      log(`<span class="bad">‰∏çË∂≥</span>: Ë®≠ÂÇô„Å´${fmt(cost)}Âæ≥„ÅåÂøÖË¶Å„Åß„Åô`);
      return;
    }

    const now‰Ωç = Math.floor(num(S.hero.guild[which], 0));
    const note = (bought < n) ? ` (${bought}/${n})` : "";
    const capNote = (now‰Ωç >= cap) ? " [MAX]" : "";
    log(`<span class="rare">Ë®≠ÂÇôÂº∑Âåñ</span>: ${GUILD_LABEL[which] || which} ‰Ωç${now‰Ωç} (+${bought})${note}${capNote} <span class="gold">(-${fmt(spent)}ÂäüÂæ≥)</span>`);
    save();
    dirtyHUD = true;
    markStatsDirty();
  }


  function buyGuild(which){
    return buyGuildN(which, 1);
  }


  // --------------------
  // Heal / Revive / Panic button
  // --------------------
  function healSmall(){
    if (S.hero.dead) return;
    const cost = 18 + Math.floor(S.run.floor*4);
    if (S.hero.gold < cost){
      log(`<span class="bad">‰∏çË∂≥</span>: Âä†ÊåÅ„Å´${fmt(cost)}Âæ≥„ÅåÂøÖË¶Å„Åß„Åô`);
      return;
    }
    S.hero.gold -= cost;
    const amt = Math.round(S.hero.hpMax * 0.40);
    S.hero.hp = clamp(S.hero.hp + amt, 1, S.hero.hpMax);
    log(`Âä†ÊåÅ: +${fmt(amt)}ÂëΩ <span class="gold">(-${fmt(cost)}ÂäüÂæ≥)</span>`);
    save();
    dirtyHUD = true;
  }

  function revive(){
    if (!S.hero.dead) return;
    const r = S.run;
    const cost = Math.round(60 + r.floor*22);

    // Âæ©Ê¥ªÁõ¥Âæå„Å´Âêå„ÅòÂú∞ÁÇπ/Èõ£ÊòìÂ∫¶„Å∏Êàª„Åô„Å®„ÄåÂæ©Ê¥ª‚ÜíÂç≥Ê≠ª‚ÜíÈÄ≤Ë°å‰∏çËÉΩ„Äç„Å´„Å™„Çä„ÇÑ„Åô„ÅÑ„ÄÇ
    // „Åù„ÅÆ„Åü„ÇÅ„ÄÅÂæ©Ê¥ªÊôÇ„ÅØÂøÖ„ÅöÂ∞ë„ÅóÊí§ÈÄÄ„Åó„Å¶È≠î„ÇíËº™Âªª„Åô„ÇãÔºàÂÜçÊà¶Ëº™Ëª¢Èò≤Ê≠¢Ôºâ„ÄÇ
    const retreatAfterRevive = (paid) => {
      const beforeFloor = r.floor, beforeRoom = r.room;
      const back = 10;
      r.floor = Math.max(1, r.floor - back);
      r.room = 1;
      // È≠î„ÇíÊ∂à„Åó„Å¶„ÄÅÊñ∞„Åó„ÅÑÂ†¥ÊâÄ„ÅßÂÜçÁîüÊàê
      r.enemy = null;
      r.enemyHp = 0;
      r.enemyHpMax = 0;
      // Âæ©Ê¥ªÁõ¥Âæå„ÅÆ‰∫ãÊïÖÈò≤Ê≠¢ÔºàÁü≠ÊôÇÈñì„ÅÆÂÖ•ÂÆ§Ë≠∑ÁõæÔºâ
      r.entryShield = Math.max(1.2, (r.entryShield || 0));

      r.reviveGraceRooms = Math.max(0, Math.floor(r.reviveGraceRooms||0));
      r.reviveGraceRooms = Math.max(r.reviveGraceRooms, 30);

      // Ë°®Á§∫Áî®
      const moved = (r.floor !== beforeFloor) || (r.room !== beforeRoom);
      if (moved){
        const why = paid ? 'ÂÜçÊà¶Ëº™Ëª¢Èò≤Ê≠¢„Åß10ÈöéÂ±§Êí§ÈÄÄ' : 'Êí§ÈÄÄ';
        log(`<span class="warn">${why}</span>: ${beforeFloor}-${beforeRoom} ‚Üí ${r.floor}-${r.room}`);
      }
    };

    if (S.hero.gold >= cost){
      S.hero.gold -= cost;
      logImportant(`<span class="good">Âæ©Ê¥ª</span>: <span class="gold">-${fmt(cost)}ÂäüÂæ≥</span>`);
      retreatAfterRevive(true);
    } else {
      const lost = S.hero.gold;
      S.hero.gold = 0;
      S.hero.exp = Math.floor(S.hero.exp * 0.65);
      const newFloor = Math.max(1, r.floor - 10);
      r.floor = newFloor;
      r.room = 1;
      r.enemy = null;
      r.enemyHp = 0;
      r.enemyHpMax = 0;
      logImportant(`<span class="warn">ÊïëÊ∏àÂæ©Ê¥ª</span>: ${fmt(lost)}Âæ≥Ê≤°Âèé / ÈöéÂ±§ ${newFloor}„Å∏Ôºà10ÈöéÂ±§ÔºâÊí§ÈÄÄ / Ë°åÊ∏õÂ∞ë`);
      r.entryShield = Math.max(1.2, (r.entryShield || 0));
      r.reviveGraceRooms = Math.max(0, Math.floor(r.reviveGraceRooms||0));
      r.reviveGraceRooms = Math.max(r.reviveGraceRooms, 30);
    }

    S.hero.hp = Math.max(1, Math.round(S.hero.hpMax * 0.80));
    S.hero.dead = false;
    r.active = false;
    ensureEnemy();
    save();
    dirtyHUD = true;
  }

  function nukeStuck(){
    if (S.hero.dead) return;
    const r = S.run;
    if (!r.enemy || r.enemyHp <= 0) return;
    const cut = Math.max(1, Math.round(r.enemyHpMax * 0.35));
    r.enemyHp = Math.max(0, r.enemyHp - cut);
    log(`<span class="warn">Ë©∞„ÅøËß£Èô§</span>: È≠îÂëΩ„Çí${fmt(cut)}Ââä„Çä„Åæ„Åó„Åü„ÄÇ`);
    dirtyHUD = true;
  }

  // --------------------
  // Offline
  // --------------------
  function applyOffline(){
    const prev = S.t ?? now();
    const elapsed = Math.max(0, now() - prev);
    const mins = Math.floor(elapsed / 60000);
    if (mins < 2) return;
    const capMins = Math.min(mins, 180);

    if (S.run.active && !S.hero.dead){
      const st = calcStats();
      const ilv = Math.floor(Math.max(S.run.floor*2.2 + S.run.room*0.18, S.hero.lv*0.55));
      const gold = Math.round(capMins * (14 + ilv*1.9) * 0.40 * st.goldMult);
      const exp  = Math.round(capMins * (18 + ilv*2.1) * 0.33 * st.xpMult);

      S.hero.gold += gold;
      grantExp(exp);

      const count = clamp(Math.floor(capMins/10) + (Math.random() < 0.35 ? 1 : 0), 1, 14);
      S.run.offlineChest = { count, ilv };
      logImportant(`<span class="good">Êú™Êé•Á∂öÂ†±ÈÖ¨</span>: ${capMins}ÂàÜ <span class="gold">(+${fmt(gold)}ÂäüÂæ≥)</span> (+${fmt(exp)}ÁµåÈ®ì) / ÂÆùÂáΩ${count}ÂÄãÂàÜ`);
    } else {
      log(`Èõ¢Â∏≠: ${capMins}ÂàÜ`);
    }
    dirtyHUD = true;
  }

  function openOfflineChest(){
    const c = S.run.offlineChest;
    if (!c) return;
    const st = calcStats();
    // reset aggregated auto-sell counters for this chest batch
    S.run._autoSoldN = 0;
    S.run._autoSoldG = 0;
    ensureMikkyoFields();
    const rarityBoost = st.gB.rarityBoost;
    for (let i=0;i<c.count;i++){
      const it = makeItem(c.ilv + st.gB.dropIlv, st.luckFactor, st.luck, rarityBoost);
      if (it && it.rarity === "unique"){
        const rk = biomeForFloor(S.run.floor).key;
        applySealToUnique(it, rk);
        grantSealFragment(rk);
      }
      S.inv.push(it);
      const rarName = RAR.find(r=>r.key===it.rarity)?.name ?? it.rarity;
      const rarTag = (it.rarity === "unique") ? "‚òÖÂÖ≠Âç∞Ê¨†Áâá" : rarName;
      logImportant(`ÂÆùÂáΩ: <span class="rar ${it.rarity}">${rarTag}</span> ${SLOT_NAME[it.slot]}„Äå${dispItemName(it)}„Äç`);
      maybeAutoEquip(it);
      if (it.rarity === "unique"){ try{ ensureMikkyoFields(); S.hero.codex.uniques = (S.hero.codex.uniques||0) + 1; }catch(_){ } }

      // Auto-sell (instant) if enabled and the chest item is still in inventory (i.e., not equipped)
      if (S.inv.findIndex(x=>x.id===it.id) >= 0 && shouldAutoSell(it)){
        const idx = S.inv.findIndex(x=>x.id===it.id);
        if (idx >= 0){
          const soldIt = S.inv[idx];
          const rar = RAR.find(r=>r.key===soldIt.rarity) ?? RAR[0];
          const base = 8 + (soldIt.ilv||1) * 2.7;
          const price = Math.round(base * rar.sell);
          S.hero.gold += price;
          S.inv.splice(idx, 1);
          // aggregate log to reduce spam
          S.run._autoSoldN = (S.run._autoSoldN||0) + 1;
          S.run._autoSoldG = (S.run._autoSoldG||0) + price;
        }
      }
    }

    if (S.run._autoSoldN){
      const n = S.run._autoSoldN || 0;
      const g = S.run._autoSoldG || 0;
      logImportant(`<span class="warn">Ëá™ÂãïÂ∏ÉÊñΩ(ÂÆùÂáΩ)</span>: ${n}ÂÄã <span class="gold">(+${fmt(g)}ÂäüÂæ≥)</span>`);
      dirtyHUD = true;
    }

    if (S.inv.length > 900){
      autoTrimInventory();
    }

    S.run.offlineChest = null;
    save();
    dirtyInv = true;
    dirtyHUD = true;
  }

  // --------------------
  // Logging + dirty flags
  // --------------------
  
  // Smooth log flow (auto-scroll + incremental render)
  let logPinned = true;              // whether log is currently pinned to bottom
  let lastLogScrollAt = 0;
  const reduceMotion = !!(window.matchMedia && window.matchMedia('(prefers-reduced-motion: reduce)').matches);

  // Live log pacing: show new cards one-by-one (reduces burst)
  // Pacing is tuned by simulation speed so the user can read it.
  // Target: at 1√ó speed, show ~1 log line per second.
  function logPumpMs(){
  try{
    const label = (S && S.run) ? Number(S.run.speed) : 1;
    let pace = speedPace(label); // 1√ó => 1 log card / sec (baseline)

    // Keep logs and simulation in sync even when iOS calibration boosts sim speed.
    if (IS_IOS && S && S.run){
      const k = Number(S.run._iosSpeedScale);
      if (Number.isFinite(k) && k > 0) pace *= k;
    }

    if (!Number.isFinite(pace) || pace <= 0) return 1000;
    const ms = 1000 / pace;

    // iOS timers can be coarse; allow a slightly smaller min so it can catch up.
    const minMs = IS_IOS ? 60 : 40;
    return clamp(ms, minMs, 3500);
  }catch(_){
    return 1000;
  }
}

let logPending = [];     // [{id:number, node:HTMLElement}]
  let logQueuedUpTo = 0;   // max log id already rendered or queued
  let logPumpOn = false;

  function trimLogDomToRange(firstId){
    try{
      if (!els || !els.log) return;
      const el = els.log;
      while (el.firstElementChild && Number(el.firstElementChild.dataset.id || 0) < firstId){
        el.removeChild(el.firstElementChild);
      }
    }catch(_){}
  }
  function dropPendingBefore(firstId){
    while (logPending.length && Number(logPending[0].id || 0) < firstId) logPending.shift();
  }
  function flushLogPending(){
    try{
      if (!els || !els.log) return;
      if (!logPending.length) return;
      const frag = document.createDocumentFragment();
      for (const it of logPending){
        if (it && it.node) frag.appendChild(it.node);
      }
      logPending = [];
      els.log.appendChild(frag);
    }catch(_){}
  }
  function startLogPump(){
    if (logPumpOn) return;
    logPumpOn = true;

    const step = ()=>{
      if (!logPumpOn) return;

      // If user scrolled up, pause pacing (keep pending; don't burst-append)
      if (!logPinned){
        logPumpOn = false;
        return;
      }

      // Append in small batches to reduce layout/paint overhead (especially on iOS Safari)
      if (els && els.log && logPending.length){
        const backlog = logPending.length;

        // Catch-up: if pending is piling up, append more per tick.
        let batch = 1;
        if (backlog > 8) batch = Math.min(12, 1 + Math.floor(backlog / 6));

        // iOS: favor batching even at low backlog (DOM append is relatively expensive).
        if (IS_IOS) batch = Math.max(batch, 2);

        const frag = document.createDocumentFragment();
        for (let i=0;i<batch;i++){
          const it = logPending.shift();
          if (!it) break;
          if (it.node) frag.appendChild(it.node);
        }
        els.log.appendChild(frag);
      }

      // Align DOM to current window (handles rotation)
      const want = (S && Array.isArray(S.log)) ? S.log.slice(-logCap()) : [];
      const firstId = want.length ? Number(want[0].id || 0) : 0;
      if (firstId){
        trimLogDomToRange(firstId);
        dropPendingBefore(firstId);
      }

      // Keep glued to bottom
      try{
        if (IS_IOS || reduceMotion){
          pinLogToBottom(els.log, 0);
        }else{
          smoothFollowLogBottom(els.log, {offset:0, snapDiff:1400, maxStep:520});
        }
      }catch(_){ }

      if (logPending.length){
        let ms = logPumpMs();

        // If we are far behind, tick a bit faster to catch up (without pegging CPU).
        if (logPending.length > 12) ms = Math.max(24, ms * 0.6);

        setTimeout(step, ms);
      }else{
        logPumpOn = false;
      }
    };

    // Kick immediately
    step();
  }


  function isLogPinned(el){
    try{
      return (el.scrollHeight - el.scrollTop - el.clientHeight) < 180;
    }catch(_){
      return true;
    }
  }

  

  function pinLogToBottom(el, offset){
    try{
      offset = clamp(num(offset, 0), 0, 80);
      el.scrollTop = Math.max(0, el.scrollHeight - el.clientHeight - offset);
    }catch(_){ }
  }
// Waterfall log follow (time-based easing / „Éå„É´„Éå„É´ pin)
  let logFollowRAF = 0;
  let logFollowEl = null;
  let logFollowLastT = 0;

  function smoothFollowLogBottom(el, opt){
    if (!el) return;
    opt = opt || {};
    const offset   = clamp(num(opt.offset, 0), 0, 80);           // keep 0 to truly pin
    const maxStep  = clamp(num(opt.maxStep, 520), 20, 1600);
    const snapDiff = clamp(num(opt.snapDiff, 1400), 80, 8000);

    if (reduceMotion){
      el.scrollTop = Math.max(0, el.scrollHeight - el.clientHeight - offset);
      return;
    }

    logFollowEl = el;
    if (logFollowRAF) return;
    logFollowLastT = 0;

    const step = (t)=>{
      if (!logPinned || !logFollowEl){
        logFollowRAF = 0;
        logFollowEl = null;
        logFollowLastT = 0;
        return;
      }
      const el = logFollowEl;
      const target = Math.max(0, el.scrollHeight - el.clientHeight - offset);
      const cur = el.scrollTop;
      const diff = target - cur;

      // If we somehow got far behind (e.g., long pause / tab hidden), snap once.
      if (diff > snapDiff){
        el.scrollTop = target;
        logFollowRAF = 0;
        logFollowEl = null;
        logFollowLastT = 0;
        return;
      }

      const dt = logFollowLastT ? clamp((t - logFollowLastT)/1000, 0.012, 0.05) : 0.016;
      logFollowLastT = t;

      // Exponential smoothing (time-based)
      const alpha = 1 - Math.exp(-dt * 22);
      let stepPx = diff * alpha;
      stepPx = clamp(stepPx, -maxStep, maxStep);
      el.scrollTop = cur + stepPx;

      // Stop when settled (renderLog()/pump will re-start us)
      if (Math.abs(target - el.scrollTop) < 0.45 && (!logPending || logPending.length === 0)){
        el.scrollTop = target;
        logFollowRAF = 0;
        logFollowEl = null;
        logFollowLastT = 0;
        return;
      }

      logFollowRAF = requestAnimationFrame(step);
    };

    logFollowRAF = requestAnimationFrame(step);
  }




  // --------------------
  // MAX-speed performance helpers
  // --------------------
  function markStatsDirty(){
    try{
      if (!S || !S.run) return;
      S.run._stCacheDirty = true;
    }catch(_){}
  }
  function calcStatsFast(){
    // calcStats() can be expensive on mobile Safari.
    // We cache for a short real-time window and invalidate on stat-changing actions.
    const r = S.run;
    const t = now();
    const sp = Number(r && r.speed) || 1;

    const useCache = (sp >= 8) || isSpeedMax() || (IS_IOS && sp >= 4);
   // iPhone„Åß1√ó/2√ó„ÅåÈÅÖ„ÅèÊÑü„Åò„ÇãÂéüÂõ†„Å´„Å™„Çä„ÇÑ„Åô„ÅÑ„ÅÆ„Åß„ÄÅ‰ΩéÈÄüÂüü„ÅØ„Ç≠„É£„ÉÉ„Ç∑„É•„Åó„Å™„ÅÑ
    if (IS_IOS && sp <= 2 && !isSpeedMax()) return calcStats();
    if (!useCache) return calcStats();

    const dirty = !!(r && r._stCacheDirty);
    const age = t - (Number.isFinite(r._stCacheT) ? r._stCacheT : 0);

    // iOS: keep cache a bit longer to reduce per-tick cost.
    const cacheMs = IS_IOS ? (isSpeedMax() ? 750 : 450) : (isSpeedMax() ? 250 : 180);

    if (!r._stCache || dirty || age > cacheMs){
      r._stCache = calcStats();
      r._stCacheT = t;
      r._stCacheDirty = false;
    }
    return r._stCache;
  }

  function isSpeedMax(){
    // Simulation speed selector (MAX is usually 256)
    return !!(S && S.run && Number(S.run.speed) >= SPEED_MAX_LABEL);
  }
  function isSpdMax(){
    // Combat stat "ËøÖË°å" (spd) hard cap is 2.75. When capped, actions/logs can explode.
    return !!(S && S.run && S.run._spdIsMax);
  }
  function isLogLite(){
    // Log-lite mode is ONLY for simulation speed MAX.
    // (User request) When speed is not MAX, keep the normal (detailed) logs even if spd is capped.
    return isSpeedMax();
  }
  function logCap(){
    // In log-lite mode, keep the DOM small.
    return isLogLite() ? 40 : 240;
  }

  function _logLiteCtx(){
    const r = (S && S.run) ? S.run : null;
    if (!r) return null;
    if (!r._logLite) r._logLite = { lastFlush:0, skipped:0 };
    return r._logLite;
  }
  function _logLiteBump(){
    const ctx = _logLiteCtx();
    if (!ctx) return;
    ctx.skipped += 1;

    // Avoid calling Date.now() for every skipped log at very high speed.
    if ((ctx.skipped & 255) !== 0) return;

    const t = now();
    if ((t - (ctx.lastFlush||0)) < 3000) return;

    const n = ctx.skipped;
    ctx.skipped = 0;
    ctx.lastFlush = t;

    // Super short summary. (No parsing / no formatting)
    pushLog(S, `<span class="mutedTxt">ÈÄüÂ∫¶MAX</span>: „É≠„Ç∞${n}‰ª∂ ÁúÅÁï•`);
    dirtyLog = true;
  }

  function compactMsgIfNeeded(msg){
    if (!isLogLite()) return msg;
    const s = String(msg || "");
    let c = s.replace(/<br\s*\/?>/gi, " / ").replace(/\s+/g, " ").trim();
    if (c.length > 110) c = c.slice(0, 110) + "‚Ä¶";
    return c;
  }

  function pushLog(state, msg){
    const cap = logCap();
    const t = new Date().toLocaleTimeString("ja-JP",{hour:"2-digit",minute:"2-digit",second:"2-digit"});
    state.log = Array.isArray(state.log) ? state.log : [];
    state.logSeq = Math.floor(num(state.logSeq, 0)) || 0;
    state.logSeq += 1;
    state.log.push({ id: state.logSeq, t, msg });
    if (state.log.length > cap) state.log.splice(0, state.log.length - cap);
  }

  function logImportant(msg){
    pushLog(S, compactMsgIfNeeded(msg));
    dirtyLog = true;
  }

  function log(msg){
    // Log-lite mode: drop almost everything without inspecting the message.
    // This keeps MAX speed from freezing the browser.
    if (isLogLite()){
      _logLiteBump();
      return;
    }
    pushLog(S, compactMsgIfNeeded(msg));
    dirtyLog = true;
  }

  function ensureLogIds(){
    try{
      S.log = Array.isArray(S.log) ? S.log : [];
      let seq = Math.floor(num(S.logSeq, 0)) || 0;
      // If older logs have no id, assign sequentially in order
      for (const x of S.log){
        if (!x) continue;
        if (typeof x.id !== "number"){
          seq += 1;
          x.id = seq;
        }else{
          seq = Math.max(seq, x.id);
        }
      }
      S.logSeq = seq;
    }catch(_){}
  }



  // --------------------
  // Save / Load
  // --------------------
  function save(){
    S.t = now();
    try{ localStorage.setItem(KEY_V8, JSON.stringify(S)); } catch(e){}
  }
  function load(key){
    try{
      const raw = localStorage.getItem(key);
      if (!raw) return null;
      const obj = JSON.parse(raw);
      if (!obj) return null;
      return obj;
    } catch(e){
      return null;
    }
  }
  function hardReset(){
    localStorage.removeItem(KEY_V3);
    localStorage.removeItem(KEY_V4);
    localStorage.removeItem(KEY_V5);
    localStorage.removeItem(KEY_V6);
    localStorage.removeItem(KEY_V7);
    localStorage.removeItem(KEY_V8);
    try{ if (typeof SOUND!=="undefined" && SOUND) SOUND.stop(); }catch(_){ }
    S = defaultState();
    // v58: Ëº™ÂªªÊôÇ„Å´ÂêçÂâç„ÇíË®≠ÂÆö„Åß„Åç„Çã
    promptHeroName(true);
    log("Ëº™Âªª„ÅåÊàêÂ∞±„Åó„Åæ„Åó„Åü„ÄÇ");
    save();
    dirtyHUD = true; dirtyInv = true; dirtyLog = true;
  }

  // v58: hero name
  function promptHeroName(force){
    try{
      const cur = (S.hero && typeof S.hero.name === 'string' && S.hero.name.trim()) ? S.hero.name.trim() : 'Ë°åËÄÖ';
      const msg = force ? 'Ë°åËÄÖ„ÅÆÂêçÂâç„ÇíÂÖ•Âäõ„Åó„Å¶„Åè„Å†„Åï„ÅÑ' : 'Ë°åËÄÖ„ÅÆÂêçÂâç';
      const raw = window.prompt(msg, cur);
      if (raw === null){
        // ÂèñÊ∂à„Åß„ÇÇË°åÊåÅ„ÅØÈÄ≤„ÇÅ„Çâ„Çå„Çã„Çà„ÅÜ„Å´„Åô„Çã
        S.hero.name = cur;
        S.hero.nameSet = true;
        return false;
      }
      const clean = String(raw).replace(/\s+/g,' ').trim().slice(0,16);
      S.hero.name = clean || cur;
      S.hero.nameSet = true;
      save();
      dirtyHUD = true;
      return true;
    }catch(_){
      try{ S.hero.name = S.hero.name || 'Ë°åËÄÖ'; S.hero.nameSet = true; }catch(__){}
      return false;
    }
  }
  function ensureHeroName(){
    if (!S || !S.hero) return;
    if (S.hero.nameSet) return;
    promptHeroName(true);
  }

  // --------------------
  // UI (optimized)
  // --------------------
  const $ = (id) => document.getElementById(id);
  const els = {
    btnExplore: $("btnExplore"), btnPause: $("btnPause"), btnNext: $("btnNext"), btnSave: $("btnSave"), btnReset: $("btnReset"), btnChant: $("btnChant"), btnCodex: $("btnCodex"),
    speedSel: $("speedSel"), autoSel: $("autoSel"), fxSel: $("fxSel"),
    locText: $("locText"),
    lvExp: $("lvExp"), expBar: $("expBar"), expText: $("expText"), goldText: $("goldText"), karmaText: $("karmaText"), satoriText: $("satoriText"),
    heroName: $("heroName"),
    hpText: $("hpText"), heroSprite: $("heroSprite"), heroStageSprite: $("heroStageSprite"), heroActor: $("heroActor"), hpBar: $("hpBar"), dpsText: $("dpsText"), luckText: $("luckText"),
    enemyName: $("enemyName"), enemySprite: $("enemySprite"), enemyStageSprite: $("enemyStageSprite"), enemyActor: $("enemyActor"), battleStage: $("battleStage"), battleFx: $("battleFx"), battleFxFull: $("battleFxFull"), battleFlash: $("battleFlash"), biomeText: $("biomeText"), floorText: $("floorText"), roomText: $("roomText"),
    eliteTag: $("eliteTag"), bossTag: $("bossTag"),
    enemyHpBar: $("enemyHpBar"), enemyHpText: $("enemyHpText"), enemyStatsText: $("enemyStatsText"),
    atkVal: $("atkVal"), defVal: $("defVal"), critText: $("critText"), spdText: $("spdText"),
    eqWeapon: $("eqWeapon"), eqWeaponIcon: $("eqWeaponIcon"), eqWeaponRar: $("eqWeaponRar"), eqWeapon‰Ωç: $("eqWeapon‰Ωç"), eqWeaponPerf: $("eqWeaponPerf"),
    eqArmor: $("eqArmor"), eqArmorIcon: $("eqArmorIcon"), eqArmorRar: $("eqArmorRar"), eqArmor‰Ωç: $("eqArmor‰Ωç"), eqArmorPerf: $("eqArmorPerf"),
    eqAcc: $("eqAcc"), eqAccIcon: $("eqAccIcon"), eqAccRar: $("eqAccRar"), eqAcc‰Ωç: $("eqAcc‰Ωç"), eqAccPerf: $("eqAccPerf"),
    lockWeapon: $("lockWeapon"), lockArmor: $("lockArmor"), lockAcc: $("lockAcc"),
    upgText: $("upgText"), upgCostText: $("upgCostText"), pathBulkSel: $("pathBulkSel"), pathText: $("pathText"), pathCostText: $("pathCostText"), pathNoteText: $("pathNoteText"), btnDedicate: $("btnDedicate"), btnPurify: $("btnPurify"), dedicateText: $("dedicateText"), purifyText: $("purifyText"),
    gupgText: $("gupgText"), gupgCostText: $("gupgCostText"),
    upgBulkSel: $("upgBulkSel"), gupgBulkSel: $("gupgBulkSel"),
    log: $("log"), runInfo: $("runInfo"),
    invCount: $("invCount"), invList: $("invList"),
    search: $("search"), sortSel: $("sortSel"),
    btnClearSearch: $("btnClearSearch"), btnSellAll: $("btnSellAll"),
    autoSellOn: $("autoSellOn"), autoSellRarMax: $("autoSellRarMax"), autoSellUseEq: $("autoSellUseEq"), autoSellEqPct: $("autoSellEqPct"), autoSellProtectUnique: $("autoSellProtectUnique"),
    btnRevive: $("btnRevive"),
    deathNote: $("deathNote"),
    deathOverlay: $("deathOverlay"),
    offlineNote: $("offlineNote"), btnOpenChest: $("btnOpenChest"),
    btnBack: $("btnBack"), locBadge: $("locBadge"), tabs: $("tabs"), safeTag: $("safeTag"), safeText: $("safeText"),
    cmpPanel: $("cmpPanel"), cmpHint: $("cmpHint"), cmpBody: $("cmpBody"),
    cmpSlotPill: $("cmpSlotPill"), cmpNewRar: $("cmpNewRar"), cmpNewName: $("cmpNewName"), cmpNewPower: $("cmpNewPower"), cmpNewStats: $("cmpNewStats"),
    cmpCurRar: $("cmpCurRar"), cmpCurName: $("cmpCurName"), cmpCurPower: $("cmpCurPower"), cmpDelta: $("cmpDelta"),
    btnEquipSelected: $("btnEquipSelected"), btnClearSelected: $("btnClearSelected"), eventOverlay: $("eventOverlay"), eventTitle: $("eventTitle"), eventBody: $("eventBody"), eventChoices: $("eventChoices"), eventFoot: $("eventFoot"), btnEventClose: $("btnEventClose"), codexOverlay: $("codexOverlay"), codexBody: $("codexBody"), btnCodexClose: $("btnCodexClose"),
  };

  // Keep log pin state in sync when the user scrolls the log
  try{
    if (els.log){
      els.log.addEventListener("scroll", ()=>{ logPinned = isLogPinned(els.log); }, {passive:true});
    }
  }catch(_){}


  // v64: log-only battle view ‚Äî lock "ÊºîÂá∫" to OFF
  try{
    if (els.fxSel){
      els.fxSel.value = "0";
      els.fxSel.disabled = true;
      els.fxSel.title = "Ë™ø‰ºèÊºîÂá∫„ÅØÂªÉÊ≠¢ÔºàË®ò„ÅÆ„ÅøÔºâ";
    }
  }catch(_){ }


  function setEquipLock(slot, on){
    S.hero.lock = S.hero.lock ?? { weapon:false, armor:false, accessory:false };
    S.hero.lock[slot] = !!on;
    save();
    dirtyHUD = true;
  }
  function toggleEquipLock(slot){
    const cur = !!(S.hero.lock && S.hero.lock[slot]);
    setEquipLock(slot, !cur);
    log(`<span class="warn">Âä†ÊåÅÂ∞ÅÂç∞</span>: ${SLOT_NAME[slot]} ${!cur ? "Â∞Å" : "Ëß£"}`);
    dirtyLog = true;
  }

  // init battle FX sizing
  try{ BFX.resize(true); window.addEventListener('resize', () => { try{ BFX.resize(); }catch(_){ } }, { passive:true }); }catch(_){ }

  function rarLabel(key){
    const r = RAR.find(x=>x.key===key);
    return r ? r.name : key;
  }

  function statLines(stats){
    const s = stats || {};
    const lines = [];
    // Ë£ÖÂÇô„Çµ„Éû„É™ÔºàstatTokenÔºâ„Å®Âêå„ÅòË™ûÂΩô„Å∏Áµ±‰∏Ä
    const push = (k, extra="") => {
      const t = statToken(k, s[k]);
      if (t) lines.push(t + extra);
    };
    push('atk');
    push('def');
    push('hp');
    push('crit');
    push('spd');
    push('luck');
    push('lifesteal');
    push('thorns');
    push('regen');      // ÊÅØÁÅΩ+xx%/s
    push('goldBonus');  // ÂäüÂæ≥+xx%
    push('xpBonus');    // Ë°å+xx%
    push('dmgMult');
    push('dr');
    // ‰ªòË®òÔºàtooltip„ÅÆ„ÅøË©≥Á¥∞Ôºâ
    if (s.execute) {
      const t = statToken('execute', s.execute);
      if (t) lines.push(t + 'ÔºàÂëΩ25%‰ª•‰∏ãÔºâ');
    }
    if (s.shred) {
      const t = statToken('shred', s.shred);
      if (t) lines.push(t + 'ÔºàÈ≠î„ÅÆÊåÅÊàí‚ÜìÔºâ');
    }
    return lines.join("\n");
  }


  function statLinesWithCaps(it){
    if (!it) return "";
    const s = it.stats || {};
    const lines = [];

    let before = null, after = null;
    try{
      if (it && it.slot){
        before = calcStatsPure(S.gear);
        const g2 = { ...S.gear, [it.slot]: it };
        after = calcStatsPure(g2);
      }
    }catch(_){
      before = null; after = null;
    }

    const push = (k, extra="") => {
      const t = statToken(k, s[k]);
      if (!t) return;

      let note = "";
      const cap = capMetaForKey(k);
      if (cap && before && after && (s[k]||0) > 0){
        const b = before[k] ?? 0;
        const a = after[k] ?? 0;
        const delta = a - b;
        const isMax = (cap.max != null) && (a >= cap.max - 1e-9);
        const wasMax = (cap.max != null) && (b >= cap.max - 1e-9);
        if (wasMax && delta <= 1e-12) note = "ÔºàMAXÔºö‰∏äÊòá„Å™„ÅóÔºâ";
        else if (isMax) note = "ÔºàMAXÔºâ";
      }

      lines.push(t + note + extra);
    };

    push('atk');
    push('def');
    push('hp');
    push('crit');
    push('spd');
    push('luck');
    push('lifesteal');
    push('thorns');
    push('regen');
    push('goldBonus');
    push('xpBonus');
    push('dmgMult');
    push('dr');

    if (s.execute) {
      const t = statToken('execute', s.execute);
      if (t){
        let note = "";
        const cap = capMetaForKey('execute');
        if (cap && before && after){
          const b = before.execute ?? 0;
          const a = after.execute ?? 0;
          const delta = a - b;
          const isMax = (cap.max != null) && (a >= cap.max - 1e-9);
          const wasMax = (cap.max != null) && (b >= cap.max - 1e-9);
          if (wasMax && delta <= 1e-12) note = "ÔºàMAXÔºö‰∏äÊòá„Å™„ÅóÔºâ";
          else if (isMax) note = "ÔºàMAXÔºâ";
        }
        lines.push(t + note + 'ÔºàÂëΩ25%‰ª•‰∏ãÔºâ');
      }
    }
    if (s.shred) {
      const t = statToken('shred', s.shred);
      if (t){
        let note = "";
        const cap = capMetaForKey('shred');
        if (cap && before && after){
          const b = before.shred ?? 0;
          const a = after.shred ?? 0;
          const delta = a - b;
          const isMax = (cap.max != null) && (a >= cap.max - 1e-9);
          const wasMax = (cap.max != null) && (b >= cap.max - 1e-9);
          if (wasMax && delta <= 1e-12) note = "ÔºàMAXÔºö‰∏äÊòá„Å™„ÅóÔºâ";
          else if (isMax) note = "ÔºàMAXÔºâ";
        }
        lines.push(t + note + 'ÔºàÈ≠î„ÅÆÊåÅÊàí‚ÜìÔºâ');
      }
    }

    return lines.join("\n");
  }

  function statToken(key, v){
    if (!v) return "";
    switch(key){
      case 'atk': return `ÈôçÈ≠î+${fmt(v)}`;
      case 'def': return `ÊåÅÊàí+${fmt(v)}`;
      case 'hp': return `ÂëΩ+${fmt(v)}`;
      case 'crit': return `ÊÖßÁúº+${pct(v)}`;
      case 'spd': return `ËøÖË°å+${pct(v)}`;
      case 'luck': return `Á∏Å+${fmt(v)}`;
      case 'lifesteal': return `ÈÇÑÂëΩ+${pct(v)}`;
      case 'thorns': return `ËøîÊ•≠+${pct(v)}`;
      case 'regen': return `ÊÅØÁÅΩ+${pct(v)}/s`;
      case 'goldBonus': return `ÂäüÂæ≥+${pct(v)}`;
      case 'xpBonus': return `Ë°å+${pct(v)}`;
      case 'dmgMult': return `Â®ÅÂÖâ+${pct(v)}`;
      case 'dr': return `Ëã¶Ê∏õ+${pct(v)}`;
      case 'execute': return `Êñ≠Ê•≠+${pct(v)}`;
      case 'shred': return `Á†¥Èöú+${pct(v)}`;
      default: return '';
    }
  }

  const STAT_CAPS = {
    crit:{ min:0, max:0.65 },
    spd:{ min:0.55, max:2.75 },
    dr:{ min:0, max:0.60 },
    execute:{ min:0, max:0.35 },
    shred:{ min:0, max:0.35 },
  };
  function capMetaForKey(k){ return STAT_CAPS[k] || null; }

  function statPillsHTML(stats, it){
    const s = stats || {};
    const keys = ['atk','def','hp','crit','spd','luck','lifesteal','thorns','regen','goldBonus','xpBonus','dmgMult','dr','execute','shred'];

    let before = null, after = null;
    try{
      if (it && it.slot){
        before = calcStatsPure(S.gear);
        const g2 = { ...S.gear, [it.slot]: it };
        after = calcStatsPure(g2);
      }
    }catch(_){
      before = null; after = null;
    }

    return keys.map(k => {
      const tok = statToken(k, s[k]);
      if (!tok) return '';
      let cls = '';
      let tag = '';
      const cap = capMetaForKey(k);

      if (cap && before && after && (s[k]||0) > 0){
        const b = before[k] ?? 0;
        const a = after[k] ?? 0;
        const delta = a - b;
        const isMax = (cap.max != null) && (a >= cap.max - 1e-9);
        const wasMax = (cap.max != null) && (b >= cap.max - 1e-9);
        if (isMax) tag = `<span class="maxTag">MAX</span>`;
        if (wasMax && delta <= 1e-12) cls = ' capDead';
      }

      return `<span class="sp${cls}">${escapeHtml(tok)}${tag ? ` ${tag}` : ''}</span>`;
    }).join('');
  }

  function affixNamesFromDesc(desc){

    const s = String(desc ?? '');
    // desc‰æã: "‰ªò‰∏é: ‰øäÊïè„ÄÅÂê∏Ë°Ä" / Unique„ÅØ "... / ‰ªò‰∏é: ‚óã‚óã„ÄÅ‚óã‚óã"
    const ms = [...s.matchAll(/(?:‰ªò‰∏é|Affix|Affixes)\s*:\s*([^\n]+)/g)];
    if (!ms.length) return [];
    const last = String(ms[ms.length-1][1] ?? '').split('|')[0].trim();
    if (!last) return [];
    return last.split(/[„ÄÅ,]/).map(x=>x.trim()).filter(Boolean);
  }

  function equipAffixCount(it){
    if (!it) return 0;
    if (typeof it.affCount === 'number') return Math.max(0, Math.round(it.affCount));
    if (Array.isArray(it.affixes)) return it.affixes.length;
    const n = affixNamesFromDesc(it.desc).length;
    if (n) return n;
    // ÊóßË®òÈå≤Á≠â„Åßdesc„ÅåÁ©∫„ÅÆ„Å®„Åç„ÅØ„ÄÅÂÆùÊ†º„ÅÆÊ®ôÊ∫ñ‰ªò‰∏éÊï∞„Åã„ÇâÊé®ÂÆö
    try{ const r = RAR.find(x=>x.key === it.rarity); return r ? (r.aff||0) : 0; }catch(_){ return 0; }
  }

  function equipSummary(it){
    if (!it || !it.stats) return '‚Äî';
    const s = it.stats || {};
    const slot = it.slot || '';

    const order = (slot==='weapon')
      ? ['atk','crit','spd','dmgMult','execute','shred','lifesteal','luck','def','hp','dr','regen','goldBonus','xpBonus','thorns']
      : (slot==='armor')
        ? ['def','hp','dr','regen','thorns','atk','crit','spd','dmgMult','execute','shred','lifesteal','luck','goldBonus','xpBonus']
        : ['luck','goldBonus','xpBonus','crit','spd','dmgMult','dr','regen','hp','atk','def','lifesteal','thorns','execute','shred'];

    const parts = [];
    for (const k of order){
      const v = s[k];
      if (!v) continue;
      const t = statToken(k, v);
      if (t) parts.push(t);
    }

    const affN = equipAffixCount(it);
    const shown = parts.slice(0, 3);
    const extra = Math.max(0, parts.length - shown.length);

    let out = `‰ªò‰∏é${affN}`;
    if (shown.length){
      out += ' | ' + shown.join(' / ');
      if (extra > 0) out += ` / ‰ªñ${extra}`;
    } else {
      out += ' | ÂäπÊûú„Å™„Åó';
    }
    return out;
  }

  function equipPerfTitle(it){
    if (!it) return '';
    const lines = [];
    try{ lines.push(`Âº∑„Åï ${fmt(itemPower(it))}`); }catch(_){ }
    lines.push(`‰ªò‰∏é ${equipAffixCount(it)}`);
    const stats = statLinesWithCaps(it) || statLines(it.stats);
    if (stats) lines.push(stats);
    else lines.push('ÂäπÊûú„Å™„Åó');
    if (it.desc) lines.push(dispDesc(it.desc));
    return lines.join('\n');
  }


  // Êó•Êú¨Ë™ûË°®Á§∫ÔºàÊóßË®òÈå≤„ÅÆËã±Ë™ûÂêçÁß∞„ÇÇ„ÄÅ„Åß„Åç„ÇãÁØÑÂõ≤„ÅßÁΩÆÊèõÔºâ
  const JP_REPLACE = [
    [/(\b)Ruins(\b)/g, 'ÈÅ∫Ë∑°'], [/(\b)Forest(\b)/g, 'Ê£ÆÊûó'], [/(\b)Crypt(\b)/g, 'ÈúäÂªü'], [/(\b)Forge(\b)/g, 'ÁÇâÂøÉÂ∑•Êàø'], [/(\b)Tundra(\b)/g, 'Èõ™Âéü'], [/(\b)Abyss(\b)/g, 'Ê∑±Ê∑µ'], [/(\b)Skyreach(\b)/g, 'Â§©Á©∫ÂõûÂªä'], [/(\b)Mythic(\b)/g, 'Á•ûÁßòÈ†òÂüü'],
    [/(\b)Slime(\b)/g,'ÁÖ©ÊÇ©Á≤ò‰Ωì'],[/(\b)Goblin(\b)/g,'ÁæÖÂàπÂ∞èÈ¨º'],[/(\b)Skeleton(\b)/g,'ÁôΩÈ™®'],[/(\b)Bandit(\b)/g,'ÁõóË≥ä'],[/(\b)Wolf(\b)/g,'Áãº'],[/(\b)Bat(\b)/g,'ËùôËù†'],[/(\b)Spider(\b)/g,'ËúòËõõ'],[/(\b)Rat(\b)/g,'Èº†'],
    [/(\b)Armored(\b)/g,'Ë£ÖÁî≤'],[/(\b)Frenzied(\b)/g,'ÁãÇ‰π±'],[/(\b)Titanic(\b)/g,'Â∑®Ë∫Ø'],[/(\b)Hexed(\b)/g,'Âë™Ë©õ'],[/(\b)Volatile(\b)/g,'Êö¥Ëµ∞'],[/(\b)Vampiric(\b)/g,'Âê∏Ë°Ä'],[/(\b)Swift(\b)/g,'‰øäÊïè'],[/(\b)Unyielding(\b)/g,'‰∏çÂ±à'],[/(\b)Spiteful(\b)/g,'ÊÄ®Âóü'],[/(\b)Mystic(\b)/g,'Á•ûÁßò'],
    [/(\b)Sword(\b)/g,'Ââ£'],[/(\b)Axe(\b)/g,'Êñß'],[/(\b)Spear(\b)/g,'Êßç'],[/(\b)Dagger(\b)/g,'Áü≠ÈáëÂâõÂâ£'],[/(\b)Bow(\b)/g,'Âºì'],[/(\b)Staff(\b)/g,'Êùñ'],[/(\b)Hammer(\b)/g,'ÈáëÂâõÊßå'],[/(\b)Mace(\b)/g,'ÈáëÂâõÊ£ç'],[/(\b)Wand(\b)/g,'Âä†ÊåÅÈå´Êùñ'],[/(\b)Katana(\b)/g,'ÂàÄ'],
    [/(\b)Leather(\b)/g,'ÁöÆÊ≥ïË°£'],[/(\b)Chain(\b)/g,'ÈéñÂ≠êË°£'],[/(\b)Plate(\b)/g,'ÊùøË°£'],[/(\b)Robe(\b)/g,'Ë¢àË£ü'],[/(\b)Scale(\b)/g,'È±óË°£'],[/(\b)Mantle(\b)/g,'Â§ñÂ•ó'],
    [/(\b)Ring(\b)/g,'ÊàíÁí∞'],[/(\b)Amulet(\b)/g,'Ë≠∑Á¨¶'],[/(\b)Charm(\b)/g,'ÂøµÁ¨¶'],[/(\b)Talisman(\b)/g,'ÈúäÁ¨¶'],[/(\b)Bracelet(\b)/g,'ÂøµÁè†Ë≠∑ËÖïËº™'],[/(\b)Pendant(\b)/g,'‰Ω©Á¨¶'],
    [/(\b)Training Sword(\b)/g,'Ë®ìÁ∑¥Áî®„ÅÆÈáëÂâõÂâ£'],[/(\b)Padded Vest(\b)/g,'ÂéöÁ∂øÊ≥ïË°£'],[/(\b)Traveler's Charm(\b)/g,'Ë°åÊóÖ„ÅÆË≠∑Á¨¶'],
    [/(\b)Level Up!(\b)/g,'‰Ωç‰∏äÊòáÔºÅ'], [/(\b)Gold(\b)/g,'ÂäüÂæ≥'], [/(\b)Ë°å(\b)/g,'Ë°å'],
    [/Affix:/g,'‰ªò‰∏é:'], [/Mods:/g,'ÁâπÊÄß:'],
  ];
  function jpText(s){
    let out = String(s ?? '');
    for (const [re, rep] of JP_REPLACE) out = out.replace(re, rep);
    return out;
  }
  function dispItemName(it){ return jpText(it?.name ?? ''); }
  function dispDesc(desc){ return jpText(desc ?? ''); }
  function nameText(x){
    if (x == null) return '';
    if (typeof x === 'string' || typeof x === 'number') return String(x);
    if (typeof x === 'object'){
    // Prefer common fields; also handle nested objects / circular refs without showing "[object Object]"
    const keys = ["jp","name","text","label","title","en","id","key","type","kind"];
    for (const k of keys){
      try{
        if (Object.prototype.hasOwnProperty.call(x, k)){
          const v = x[k];
          if (typeof v === "string" || typeof v === "number") return String(v);
          if (v && typeof v === "object"){
            const vv = nameText(v);
            if (vv && vv !== "[object Object]") return vv;
          }
        }
      }catch(_){}
    }
    try{
      const seen = new WeakSet();
      const s = JSON.stringify(x, (kk,vv)=>{
        if (vv && typeof vv === "object"){
          if (seen.has(vv)) return "[Circular]";
          seen.add(vv);
        }
        return vv;
      });
      // keep it short for logs
      return (s && s.length > 80) ? (s.slice(0, 77) + "...") : (s || "");
    }catch(_){
      return "[È≠î]";
    }
  }
    return String(x);
  }
  function dispEnemyName(name){ return jpText(nameText(name)); }
function escapeHtml(s){
    return String(s).replace(/[&<>"']/g, c => ({ "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#039;" }[c]));
  }

  // --------------------
  // Pixel sprites (procedural)
  // --------------------
  
// High-res (32x32) stylish sprites for hero/enemies (PNG). Items/FX still use ASCII sprites.
const SPRIMG = {
  none: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mNgYGBgAAAABQABeqhXUAAAAABJRU5ErkJggg==',
  hero: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAABd0lEQVR42mNkIBLUXv5TwUACaNZl6cCnDybPxDDAgJFUn3eY8LfjU19x5mMlVvFvWe0MDAwMHVzTKgdVCLCQ6vPWScvwGlgNVYcrJNDNH3whQMjnrU01EJ/WtaDog4nD1KGHBLf5rDAGBgaGmXmXVjEwMDA8ST1SObjTAC6fP7x1Cav6tBg/BgYGBgZ5NT2sIcHAwBBGkgOoDWov/1FmYGBgYJhtQx0H/Pd3RS1QNu4my5zBmwYIgdmhuahpgExzBm8I/P75NYyBgYGhOi9qFXKqhqXyZ+ssUTVc2YoiLhVUM8zTgFTQcZpXRsrQAmlwlYSkAi4RJRTzpqTrDpM0AAPouYHUtDH0Q4DS3DD0SkL03NAVzI3CL1v7FYX/7c09FPMYGBhWDa00gB4S6Pk4fdIJlJbOzDyLVQwMDAw5My+j+5y8krBZl+UuLVtEgy8K0DuVhOoEuM/gLRUb/PKkpgH0viB6nNemMqBYAIt7XAAmX5E6SKIAAJYRpzIJ1RlTAAAAAElFTkSuQmCC',
  hero_atk: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAByElEQVR42mNkIBJ8PZnWxEAG6OCaVovMr/iW1czAwMDAbT6rjoGBgYGJYYABC6k+F7BbWotP/YdD0c1oPsZr/oCHACOpPm+dtAyvgdV5UeghgR5izYMqBFhI9XlrUw3Ep3UtKPpg4jB1AnZRtQwMDAy/f34NQ1Y3M89iFQMDA0NMtF7z4M4FuHz+8NYlrOrTYvwYGBgYGOTV9FBCojovahW2kKB7Gvh6Mk3368k0XZwhQGpJ99/fFTU7bdxNlsMGXxr4rTMTmm+X4tU4OzQXNQ2Q6YDBFwKsV9KbGRgYGF6/+1LLwMDAICrEg5KqYan82TpLVI1XtqKISwXVkOcAbvNZlxkYGBg+fJ05wOUAN2MYNHesYmBgYJh6AVVeKug4VRzARGx+pXsIsLJzQ33ujVISkgq4RJRQStYp6brYQ4DbfFYdrJk0qFpEhAB6biA1bQz+NiEhQGluGLwhAKu/YfU5ersABrqCuVH4ZWu/ovC/vbnHgNYeWDW00gB6SKDn4/RJJ7C2+XJmXmbA1xIiGALULhFxmTf4ogBWGsKaaDBXC9gtxekzZP6SpZfwypOcBtD7guhxHhOth2IBLO5xAZh8TLTe4IgCAMOeuacLuXKuAAAAAElFTkSuQmCC',
  hero_dead: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAABV0lEQVR42mNgGOmAEZfElMU7oigxOCfWYxkx6pgGXQig+7wwJXgpKQb2z1kbTUpIDJ4QwOXz1knLSDKwOi+KpJAY8BBgQRdA93lrUw0DAwMDw8Nbl/AaJK+mx4CsD2YOekgM/hAgBESFeFD4r999ocgBgy8Efv/8agtNzYeR4xQWx69sLVHU//d3xZoLYOYwMDDIDc00gCskFKC5Ah18e3MP3efkOWDK4h1y0ILjESU+g5lDcS5ADwkuESWq+JzoyggWEqzs3EQ5AN3nhCojgiGAy+IBK4iIjXNiGyQEa0NifQ6LiqHfHsDl865gbqwGlK39SlFIDN6SEN3H6ZNO4M3nM/MsDkNYuhAfD9n2AKxAyZl5+TADAwPDlHRdFB+ihwTC59C4nnmZgRifk10OYJTxpxtwdUweEVMnEKwNYSGB8DL+fsLwrQ3xFLmPqFIQEaoNaVUnAACX2sQlgPuzHQAAAABJRU5ErkJggg==',
  enemy_generic: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAABYklEQVR42mNkIADeu7hUMFAABPfs6cAnz8QwwICRWJ+LHT7eTorBr2wtK4kJmcEXArh8/srWkgFNnFAIYFWPHjKDJwSI9fns0FySLEhdPRlvSAy+EID5vHXSMqJ8xLhxNwr/v78rUSFWnRc1ONIAC7klHbrP0cXRQ2LQloQs6KkeV9ynxfhBGFAa5kP08gCWa2AhkQYVn7Vk0yAPAXIBejlBKhjwEBh1ADwN/P75NQxaQq3ClhtgqRhWEuIqB9BLREJ1x9DNBTAfEqoLiHbAexcXZWIaGlSvDdHrAsE9e+4yMDAwsLJzr8JXMpIKYLUfLK3B04Dgnj0dhJrOdE0DuHwO88GUdF28BubMvMxASsix0NvHsLSG0wGwtppguj9KWqBWnDMwMOB3ACwR0hrA0h3BKED3Qc7My6uISQtYfE5cGkCPI0pDBN08ihMhzGewkCDVx2R3TnEVVLgcgCUksZY1AODIqUn/J1qBAAAAAElFTkSuQmCC',
  i_flame: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAz0lEQVR42mNgGAVDHdRe/vOfEv1M1LCcEkcwUcvn5DqCiZrBTo4jmAY6DTFR6vsSpb8UhQITNSynxBFMtMpuxKon2gHNuiyM+IIenY+uftAmQrKy4MevP3FimiZCGOi5x0ySOM1yATUSLCMlBiInPFy+J5QYmahhOTY+saHBSE4w4rKMUDrAFhokJ0J8lhMjT7QDcMUdoZROaloYerUhXcsBfFkI3TJSE9/QiQJiQoFc31MlBMiJ90EVBYzEKkQvGbEFLTFq6NYDorTHNHIAANcdmemvHu1aAAAAAElFTkSuQmCC',
  i_crown: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAoklEQVR42mNgGAWjYBQMdVB7+c9/SvQzDbQHmKjhe0pCgYlWQU2s+qERBdiCGt2H2OSICYUBDwFGWme1Zl0WRopCgNJ8Tkj/4E6ElPqeGHMGdwgQSkDUSIiMlERBidJfOLvnHjNZjmAi1vISpb8oFiKz0fnoavF5hqg0gM9iStQOnboAOX5hbPQ4xyZOKF1QnAipkRMGPBsyUaKZGpXRKBgFAHTqY6scKg2vAAAAAElFTkSuQmCC',
  i_chain: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAoElEQVR42mNgGAWjYBSMgpEOGIlVWHv5z390sWZdFrj+j19/Ysjzc7MTNJ+JXMuRxbFZjk+cJAfgspxYSwjJM5JiOXKQ117+879E6S/OIEe3GFd0MBGbBpAtx8ZHt4CY+CfJAbQCow4YOg5AzxHofPRUT0wZQFRJSKgcQM+K2AC+HMFEavYjtbglJM9EThmALo7LEmLLglEwCkbBKBhQAACF+kYYOTG/KAAAAABJRU5ErkJggg==',
  i_eye: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAm0lEQVR42mNgGAWjYBSMggEGjIQUTFm84z+lluTEeuC0h2nQhwAM1F7+Q3JINOuyMFLsAHwWlyj9hbN77jGT5RBGcixHthgd4HIILkcwDaksU3v5z/+PX3+iYG5+MQwxmiRCGEC2QEpKFi7+7NljOJufm51oc5lIDQFkPsxSZMupmg1HRCIc3OXAoCgJSXUMMZaOglEwCkbBoAIAZUxfJdScGq4AAAAASUVORK5CYII=',
  i_wheel: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAABgUlEQVR42u1WoY6DQBAd2k0qKirx9ST8AgniNJ4/qKxFYSvvD/DVFST9BRJ8PRKBIKHZU0OGze4yS7mcOEbB7jLz5s3bYQA22+y/m7fko6weJD77VQkAAE0YAwBAHggnn2Jp4LkzXCC7NYOr57+Lh1wFQFYPEqlGywPh0SzVjPH8HAjhEtyvSrikX0ZqEQQNitpYxADSTp2g87brZdv1YyB81gW3lY+tAZq5iVa6bmOKBUCHmjot7s/JHn3XBTexwGIAa9t2vUyTaFy/vfbQhPGkRGkSjeXgXEWxpBGlSQS3136y1oQxXM/v9Trh3PXRqVu9qrYSOovwt0xwMqQaQMH5VTk5g9mjRk7Hg8fpoOxOiE6p2q/nN/hVOaG+uD/Zwa0AdAqmuqC3QX3X6cd0I9ga4DQZTrNyAoCoKcUY5HQ8eEg1rTkFgd/Z+sGO04RQbE0YQ1YP0lRb3NOJ8+OJyBRUnYjUvbl/ArsT5oHwXIYS7kTk1IrRqQ2I60y42WZ/bj8C7dqWc4kKrwAAAABJRU5ErkJggg==',
  i_skull: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAsElEQVR42u2VMQrAIAxFVQodOnTrUOj9D1bo3qGDk52EIqj5iVKEvElRkxh/jDGKovyM5Ry6Hx/ieF1mm84RW07inLMuCoBqHAnCtXaO7nc9nCPnJo7hfT+y8+s6TVcRps6XdQul9eYBtGa8AGpvjGrAStRMEV/tZ2Q/QakSuvSCXBbSXoDcHsoA2mSo+7UMnVSA35+QI8SxMkAVFiJYOAM142i1sLkfH2L9f8eKgvICXrpTT9NWDrMAAAAASUVORK5CYII=',
  i_scales: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAyElEQVR42mNgGAWjYBQMdVB7+c9/SvQzUcNyShzBSIyij19/km0BPzc7I0UhQInlxOhnItYHi9ftZ1i8bj/RFsPUUxwC6MHIz83OCMM995gZYBhZnJClZCXCnFgPRgYGBoYpi3cQjBKYGpgemuUCaoBRB5DkAGLSASnxz8DAwMBCanH7koC6l2h6mnVZGCkqCSkt6wk5YvCnAVyuRxcnVh1ZlREx0UPIokEbBYzk+piShEdWCJCaG4hVP3RKQlITGbmJchSMPAAAGIdW2yi+COsAAAAASUVORK5CYII=',
  i_cloud: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAm0lEQVR42u2UMQ6AIAxFC3ISdm/H6uTq7dw9iUQnEoKAFAoO9k0GTf+DFgEYhmH+jqAqtOzn5Z7XWYlhAn5wSImI7BVe8h4AQFEGdp2BMNxo+/hmOyZ0K1TNrmPhbj0lUSWQC48FGW3REpIq3F9PnVCxQE342xw03wJMYZIWUJK7vkME0CeA+Zd3EaCWyNX6vAWidYhqd84wjOMGiXpJCTstBSIAAAAASUVORK5CYII=',
  i_question: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAkElEQVR42mNgGAWjYKQDRnI11l7+8x9drFmXhZHmDsBmMSUOYaK25aSoIykE0A3F5kti1FAUAoQMJicNMFHLcmzyxEQFC7UsJhcwUdMwUhIf1R0As5xURzANlM8pLgmpVSIyDaTlFDsA3TJa5RSapoFRQDH4+PXn/49ff5IdBUyUWo6NPWBF8ZCMglEwCkYBAKCbTpyOVYJ+AAAAAElFTkSuQmCC',

  slime: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAABVElEQVR42mNgGOmAkZACpaNxFZRYcM96UQc+eaZBFwK4fPzYaW07KQbL7guuJCZEBk8IoPsc3cey+4JJMvix01q8IQILiYEPAVw+J9XHxIYIekgMeAiwkOrzaL55eOWXfkrClSvQ7akcXCFACMB8XqzETKDom4c3JAZfScjKzv0fX9yfM1hIkQVGF+Lx5ooBDwGSHSAqxMMgKsRDtPpzBgvxhuKgqAtCGRgYGFjZuVdRMy0QivvfP7+GDa1yAN1Hl1k4UPi6f34QVRfAfA53gNLROGVs1SetAcxeeAjAXPbYae0qcmpDUkOE5Cigts9xOgA9JHC1iGA+JORzQlHLgu6ye9aL7tIjJGBNMpxRgJ5acaUNXHGNK9UzMDCgRAHTPetFHchNZaWjccro8TQoygFcaYNQyFGtYwJLG7Aim1gH4ApNgmmAWj6keueUUC4h5GN0AADtR6kxkbFAGwAAAABJRU5ErkJggg==',
  goblin: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAABm0lEQVR42mNkwAGUjsblMeAB96wXTaJEPQwwMQwwYCTk88dOayci82X3BefjM5CQevSQGDwhgMvnsvuC0X2I1WekqoeFxMCHALE+xxLXDGhxTZR69JAYPCFAyOfnDBaSZLDRhXiiQmLAQ4CFkAKYz//7u6IG3cbdKHx0+XNQeVwhMWjSAAuxCmeH5qIKLNmEykeTTyPS3IHPBazs3P+xpX5Y3M9C82m2wVa8Bk694I0aEjF+WNMCLDcMeAiMOoCRgYEhlIGBgYGVnXsVKWmBECAU979/fg0bGuUAzAfnYlDrAgFuxjBk/oev/1cRUxdgOEDpaJwktuqV1gBmL7w2vGe96Dm+tABz4JR0XbwG58y8zIBPPyzuYQ4YfGkA5sLHTmtXofgYSiP5EGubEK5+5S0U9TBzcToAFiSwqCAE0NWxsnOTFPeDpzqGNY9hiZHYXIHuE1LVw+zFWQ7A4ixn5mWUXCEbroarB8TAwMDA0Ikj1TMwMEjiTQPoIUErgN41I1gSoucKXH0+9BDBleqJLooJ5QpicwF63KMDAOpe3PS2TXKqAAAAAElFTkSuQmCC',
  skeleton: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAABUElEQVR42tVXOw7CMAxNKhBDkBohcS3YmBgp3IBDcAM+I1M3uBZSBRIMiAEWngRRXdsU0ZCtrZP6PT+/utYw63i5T0yN5Z3dVD1PTMPLShH3e9215uBDcc4kjMTDQIg8RHwozqqD+71uJSNgonEGWlSttYhLNECdm0WlgURT07CudeKiYaAldTrUFOhKaqzqFry3eR9AJpz6V9v92/V0PFA9L2Eqi9MHuEUhoxih4uPpAu0GCplUA/HNA+gC7+zJGGPaHZd/41tAqf92vYyePpD+lwYop/POjgKHy5l9+ev95GVjCloa0QA3D4RIF8tdXnXwfDYUMZN4Zzfc6PzTmZDrBo4JKXJ0g9qIoBMkysXV7gLuOx863nwm8wEyAWTOjVUUQilyxJEMIFNoQeoDiA/PYUuATqj7MypFLtZACYJU80/onf1MhJ+qPYynNAHGH0FK0C5j6uQKAAAAAElFTkSuQmCC',
  wolf: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAABhUlEQVR42mNkQAO/J9nkMeABrHlHJuGTJ1U/E8MAA0ZcLucqPT8Rmf+t2zAfn0/I1T/wIYDL5a2TlqEorM6LwuoTdECq/sETArhcjg5gPsEFiNUPC4mBDwFWdu7/+FyeunoyqoaNu/Ea+N/fFYU/OzQXb0gMeAiwEAwiAj4mqH7JJrzqBzwESHaAqBAPg6gQD9XUDYq6IJSBgYGBlZ17Fb7ckBbjR5LBs3DEPSz1//75NWxwhQC8liIQEuQCdJ/Ds+HvSTaS0OrxOT19DrMXoxyAubA6L2oVvlqN2LoAl88xCiJ6hQTMHpwlIa40APPJlHRdvBbkQNXB9MNoWIgyMDAMsfYAsT7HCImZlxmIaRkN3toQl8/TJ51ASc0z8yxW4ZPnv9q+ioGBgeGjduUgrQtgaQCW/WC5AL1cwAUIhQCuXEZ0g4RQPp535w9eeULlCs6SkNTUDgNJ3Yb4PQA1H6MoxlUSovuI0hCDRzWUZqE0EWEJMZIczEhutxo98WIJyUnEdNsB6b3VTX1o50oAAAAASUVORK5CYII=',
  bat: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAABX0lEQVR42s1Xu3LCQAyUM2Yo4Af4IFpC4xQMNaXpaKhp6EyZmklBGpKWD+IHoGAoTAFiYDnd6Rw7d2qY8UPaXa1PIqFbbGdlTooYLpOV7b5vnjcKHAkizopuYXrwe3qY2pSomie4AikiXqy+jA9m+fU+M5B67ZsnvAda7U5pQ4wxz0fGXrqYS3ni8YA2mCH3Eq/7RngPEFFGRNRqdzY2JpPxwCvx5/rX2vvz6fgRlwcY0TwfbTQ9Ld/7z1L+7FSu5zp3ANtZ2bsdrfv/ZM5177MAAUiecHkBey8xZwApXmhaCa7jPAckT0ju1vb8xYQ8VrkVTSmBzLmu8yT0/Tq0zF9a0JQSEvPKswCZ/nUWpNKyiEpkRbdW5o+zgDS7HTOUeoznhrQ3IJAopqFRAdxqta5GRXAbrs2Ehh7vazGhAXGlxKwYAlUDwMKuRJIi/Cu9H+9SKiHW/jl1KRaNAsHjAliF66S3S1klAAAAAElFTkSuQmCC',
  spider: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAABtElEQVR42tVXsU4CQRCdM0souNof4Css/AVDsxbEVjvPjkCoCYbutJPWWBwN8Rcs/Ap+wFoLY4ENQ27f7TC7HHhxun3ZnXtvdnZmLlkO1kOKsN4suS+v654/oYZtS8Dm6dTm6RQ3SHjoPsSXg/WwHLXGI5C02p01EdHi7nOEzH24lgPSOcTZjyk5Xm0cduGDXtyTXCsiola7E4SzGWZk87TYYCNgSjFZj8pb7U7hw7cENOaa8hKx7j6RNBpzm6dRScVCQs8ZjfmhTPJrfO+WiGjy8HJQAjZzXwHnkkGGsSGvXQeYiab8evHorE/f3p31x/mZs57bW6+fcdZ3cq7xSmhCN6KiCaznynlU3lgv6M2SFb+4qAjcXF1Efejp+dWN2Ca3xlnfqbjNd0N+BaWSXByjDvyfHPj5/rqEu6J9IsKK0a/4DLEnHMvEbohdEBlzRBCX9ks4Tkbmr+5e6jVmx8y2UwneLe5DHCct/p6RZjuJsTTphOYSTmCVqRjrAeLaqMXKOAIabjTl2qSEillZKB49FWt29KlY+jGJnYorVyAxrGtaJCvNSLprVO7JheGurJci+QubWGPTb8K0FgAAAABJRU5ErkJggg==',
  boss: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAABkklEQVR42mNkwAG+nkxrYsADuM1n1VGiHgaYGAYYMBLyuYDd0lpk/odD0c34DCSkHj0kBk8I4PL5h0PR6D7E6jNS1cNCYuBDgFifY4lrBrS4Jko9ekgMnhDA5fPda2di1Wh/zhWFf9BoN1Z1rsHpeENiwEOAhViFDvWo/AONuwnIE2fuwKcBVnbu/8SkYhj4rTMTrzzrlXSizIGlhcGbBqZe8EbhZxtsJcmHuPQPytowlIGBgYGVnXsVtrSA7pPU1ZPxGjg7NBevz2Fx//vn17DBFQLwVExkSBAChHwOT4RfT6bpQqvHy/T0OcxejFwAc6GA3VKUkID5aMnSS3gNjonWI8rnGNmQXiEBswdnOYArDZALYObAQpSBgQGlPcACaxoRalZTG8DsZcGjIAwt6FaRaEEYtpAddCUhzlyAC6RPOhFGIBdg9SmSubpEVUboqZXS1I4rdxFsEaH3dGBxiR5SMHGk1nItMT0pFnJ9jq4OvZlOrLmMJPRuLxPjQBLU1WHtnKI7CFfcERvHSCUs1u45APwb1mTbD7S3AAAAAElFTkSuQmCC',
};

const SPRIMG_IMG = (() => {
  const out = Object.create(null);
  for (const k in SPRIMG){
    if (k === 'none') continue;
    const im = new Image();
    im.decoding = 'async';
    im.src = SPRIMG[k];
    out[k] = im;
  }
  return out;
})();

const SPR = (() => {
    const PAL = {
      '.': null,
      'K': '#0b0f16',
      'D': '#0f1b2d',
      'W': '#f1f5f9',
      'S': '#94a3b8',
      'B': '#3b82f6',
      'G': '#22c55e',
      'Y': '#f59e0b',
      'P': '#a855f7',
      'R': '#ef4444',
      'T': '#a16207',
      'O': '#fb923c'
    };

    // 16x16 sprites: '.' is transparent
    const SPRITES = {
      hero: [
        '................',
        '......KKKK...Y..',
        '.....KSSSSK..Y..',
        '....KSDSSDSK..T.',
        '...KSDWWWWDSK.T.',
        '...KSDWRRWDSK.T.',
        '...KSDWSSWDSK.T.',
        '....KSDYYYYDK.T.',
        '....KSDDDDDDK.T.',
        '...KSDDDDDDDDKT.',
        '...KSDDDYYDDDKT.',
        '...KSDDDDDDDDKT.',
        '....KSDDTTDDK.T.',
        '.....KTT..TK..T.',
        '.....KTT..TK..T.',
        '....KK....KK..K.',
      ],
      hero_dead: [
        '................',
        '................',
        '....KKKKKK......',
        '...KSSSSSSK.....',
        '..KSDWWWWDSK....',
        '..KSDWKKWDSK....',
        '...KSDRRRDK.....',
        '....KSDDDK......',
        '.....KDDK.......',
        '....KDDDK.......',
        '...KDDDDDK......',
        '..KDDTTTDDK.....',
        '..KTT....TTK....',
        '...KTT..TTK.....',
        '....KKKKKK......',
        '................',
      ],
      enemy_generic: [
        '................',
        '.....KKKKKK.....',
        '....KRRKKKKRRK..',
        '...KRRSSSSSSRRK.',
        '..KSSSRRWWRRSSSK',
        '..KSSSRWWWWRSSSK',
        '.KSSSWWRKKRWWSSK',
        '.KSSSWWRRRRWWSSK',
        '.KSSSWWRRRRWWSSK',
        '..KSSSRWWWWRSSSK',
        '..KSSSRRWWRRSSSK',
        '...KSSSSSSSSSK..',
        '..KSSKTTTTKSSK..',
        '....KKTTTTKK....',
        '......KTTTK.....',
        '.......KK.......',
      ],
      slime: [
        '................',
        '................',
        '.....KKKKKK.....',
        '...KKGGGGGGKK...',
        '..KGGGGGGGGGGK..',
        '.KGGGGBBBBGGGGK.',
        '.KGGGBWWWWBGGGK.',
        'KGGGWWWWWWWWGGGK',
        'KGGGWWKWWWWWWGGK',
        '.KGGGWWWWWWGGGK.',
        '.KGGGGGYYGGGGK..',
        '..KGGGGYYYYGGK..',
        '...KKGGGYYGGKK..',
        '.....KGGGGGK....',
        '......KKKK......',
        '................',
      ],
      goblin: [
        '................',
        '....KK....KK....',
        '...KGGK..KGGK...',
        '..KGGGGKKGGGGK..',
        '.KGGGWWWWWWGGGK.',
        '.KGGWRRWWRRWGGK.',
        '.KGGWSSSSSSWGGK.',
        'KGGWSSYYYYSSWGGK',
        'KGGWSSYYYYSSWGGK',
        '.KGGWSSSSSSWGGK.',
        '.KGGGWW..WWGGGK.',
        '..KGGKTTTTKGGK..',
        '...KTTK..KTTK...',
        '...KTTK..KTTK...',
        '....KGGKKGGK....',
        '.....KK..KK.....',
      ],
      skeleton: [
        '................',
        '.....KKKKKK.....',
        '...KKWWWWWWKK...',
        '..KWWWWWWWWWWK..',
        '..KWWKWWWWKWWK..',
        '..KWWWKWWKWWWK..',
        '.KWWWSSWWSSWWWK.',
        '.KWWWSWWWWWSWWK.',
        '.KWWWSSWWSSWWWK.',
        '..KWWWWWWWWWWK..',
        '..KWWKWW..WWKWWK',
        '..KWW..SSSS..WWK',
        '...KWW..SS..WWK.',
        '...KKW..WW..WK..',
        '....KK....KK....',
        '................',
      ],
      wolf: [
        '................',
        '...KK......KK...',
        '..KSSK....KSSK..',
        '.KSSSSKKKKSSSSK.',
        'KSSSRRWWWWRRSSSK',
        'KSSSWWWWWWWWSSSK',
        'KSSSWWKWWWWKSSSK',
        '.KSSSWWWWWWSSSK.',
        '..KSSSSSSSSSSK..',
        '...KSSKKKKSSK...',
        '..KSSKTTTTKSSK..',
        '.KSSKTTTTTTKSSK.',
        '.KSKTT..TT..TSK.',
        '..KK....TT....KK',
        '........KK......',
        '................',
      ],
      bat: [
        '................',
        '..KKK......KKK..',
        '.KSSSK....KSSSK.',
        'KSSSSSK..KSSSSSK',
        'KSSSSSSKKSSSSSSK',
        '.KSSSWWWWWWSSSK.',
        '..KSSWWRRWWSSK..',
        '...KSSWWWWSSK...',
        '....KSSSSSSK....',
        '.....KSSSSK.....',
        '.....KSKKSK.....',
        '....KSK..KSK....',
        '...KK......KK...',
        '................',
        '................',
        '................',
      ],
      spider: [
        '................',
        '.K..K....K..K...',
        'K..K......K..K..',
        '.K..........K...',
        '...KKKKKKKKKK...',
        '..KSSSSSSSSSSK..',
        '.KSSSRRKKRRSSSK.',
        '.KSSSSSSSSSSSK..',
        '.KSSSWWWWWWSSSK.',
        '..KSSSSSSSSSSK..',
        '...KKSSSSSSKK...',
        '..K..K..K..K..K.',
        '.K..K....K..K..K',
        'K..K......K..K..',
        '.K..........K...',
        '................',
      ],
      boss: [
        '................',
        '....KK....KK....',
        '...KYYK..KYYK...',
        '..KYYYYKKYYYYK..',
        '.KYYPPPRRPPPYYK.',
        '.KYYPWWPPWWPYYK.',
        'KYYYYYWWWWYYYYYK',
        'KYYSSYYYYYYSSYYK',
        '.KYYSSRRRRSSYYK.',
        '..KYYSSSSSSYYK..',
        '...KYYTTTTYYK...',
        '..KYYYTTTTYYYK..',
        '..K..YTTTTY..K..',
        '.....Y....Y.....',
        '....KKK..KKK....',
        '................',
      ],
      // fx
      fx_slash: [
        '................',
        '........W.......',
        '.......WWY......',
        '......WWYY......',
        '.....WWYY.......',
        '....WWYY........',
        '...WWYY.........',
        '..WWYY..........',
        '.WWYY...........',
        'WWYY............',
        'YY..............',
        '................',
        '................',
        '................',
        '................',
        '................',
      ],
      fx_claw: [
        '................',
        '........R.......',
        '.......RRO......',
        '......RROO......',
        '.....RROO.......',
        '....RROO........',
        '...RROO.........',
        '..RROO..........',
        '.RROO...........',
        'RROO............',
        'OO..............',
        '................',
        '................',
        '................',
        '................',
        '................',
      ],
      fx_spark: [
        '................',
        '................',
        '.......Y........',
        '......YWY.......',
        '.....YWYWY......',
        '......YWY.......',
        '.......Y........',
        '................',
        '................',
        '................',
        '................',
        '................',
        '................',
        '................',
        '................',
        '................',
      ],
      fx_crit: [
        '................',
        '.......R........',
        '....Y..RY..Y....',
        '.....YRRRY......',
        '..Y..RRWRR..Y...',
        '...YRRRWRRRY....',
        '....YRRRRY......',
        '....Y..RY..Y....',
        '.......R........',
        '................',
        '................',
        '................',
        '................',
        '................',
        '................',
        '................',
      ],


      // items
      w_sword: [
        '.......WW.......',
        '......KSSK......',
        '......KSWK......',
        '......KSSK......',
        '......KSWK......',
        '......KSSK......',
        '......KSWK......',
        '......KSSK......',
        '......KSWK......',
        '......YKKY......',
        '......KYTK......',
        '......KTTK......',
        '......KYTK......',
        '......KTTK......',
        '......KBBK......',
        '.......KK.......',
      ],
      w_axe: [
        '................',
        '................',
        '....KSSK........',
        '....KWSK........',
        '...KKWSK........',
        '....KSSK........',
        '....KSSKKTK.....',
        '........KTK.....',
        '........KTK.....',
        '........KTK.....',
        '........KTK.....',
        '........KTK.....',
        '........KTK.....',
        '........KTK.....',
        '........KTK.....',
        '.........K......',
      ],
      w_spear: [
        '.......WW.......',
        '......SSSS......',
        '.......WW.......',
        '......KTTK......',
        '......KTTK......',
        '......KTTK......',
        '......KTTK......',
        '......KTTK......',
        '......KTTK......',
        '......KTTK......',
        '......KTTK......',
        '......KTTK......',
        '......KTTK......',
        '......KTTK......',
        '.......KK.......',
        '.......KK.......',
      ],
      w_dagger: [
        '................',
        '.......WW.......',
        '......KSWK......',
        '......KSSK......',
        '......KSWK......',
        '......KSSK......',
        '......KSWK......',
        '......YKKY......',
        '......KTTK......',
        '......KTTK......',
        '......KTTK......',
        '.......BB.......',
        '.......KK.......',
        '................',
        '................',
        '................',
      ],
      w_bow: [
        '................',
        '................',
        '....KT.W..TK....',
        '...KT..W...TK...',
        '...KT..W...TK...',
        '...KT..W...TWW..',
        '...KT..W...TK...',
        '...KT..W...TK...',
        '...KT..W...TK...',
        '....KT.W..TK....',
        '................',
        '................',
        '................',
        '................',
        '................',
        '................',
      ],
      w_staff: [
        '.......PP.......',
        '......PBBP......',
        '.......YY.......',
        '......KTTK......',
        '......KTTK......',
        '......KTTK......',
        '......KTTK......',
        '......KTTK......',
        '......KTTK......',
        '......KTTK......',
        '......KTTK......',
        '......KTTK......',
        '......KTTK......',
        '......KTTK......',
        '......KTTK......',
        '.......KK.......',
      ],
      w_hammer: [
        '................',
        '......WWWW......',
        '....KSSSSSSK....',
        '....KSSSSSSK....',
        '.....KKKKKK.....',
        '......KTK.......',
        '......KTK.......',
        '......KTK.......',
        '......KTK.......',
        '......KTK.......',
        '......KTK.......',
        '......KTK.......',
        '......KTK.......',
        '......KTK.......',
        '......KTK.......',
        '.......K........',
      ],
      w_mace: [
        '................',
        '.......K........',
        '......KWK.......',
        '.....KWSWK......',
        '......KWK.......',
        '.......K........',
        '......KTK.......',
        '......KTK.......',
        '......KTK.......',
        '......KTK.......',
        '......KTK.......',
        '......KTK.......',
        '......KTK.......',
        '......KTK.......',
        '.......B........',
        '.......K........',
      ],
      w_wand: [
        '................',
        '.......P........',
        '......PBP.......',
        '.......Y........',
        '......KTK.......',
        '......KTK.......',
        '......KTK.......',
        '......KTK.......',
        '......KTK.......',
        '......KTK.......',
        '......KTK.......',
        '......KTK.......',
        '.......B........',
        '.......K........',
        '................',
        '................',
      ],
      w_katana: [
        '................',
        '................',
        '....KS..........',
        '.....KS.........',
        '......KS........',
        '.......KS.......',
        '........KS......',
        '.........KS.....',
        '..........KT....',
        '...........KT...',
        '............KT..',
        '.............KT.',
        '............KBK.',
        '.............K..',
        '................',
        '................',
      ],

      w_greatsword: [
        '.......WW.......',
        '......KSSK......',
        '......KSWK......',
        '......KSSK......',
        '......KSWK......',
        '......KSSK......',
        '......KSWK......',
        '......KSSK......',
        '......KSWK......',
        '.....YYKKYY.....',
        '......KTTK......',
        '......KTTK......',
        '......KTTK......',
        '......KTTK......',
        '.......BB.......',
        '.......KK.......',
      ],
      w_rapier: [
        '.......W........',
        '......KSSK......',
        '......KSWK......',
        '......KSSK......',
        '......KSWK......',
        '......KSSK......',
        '......KSWK......',
        '......KSSK......',
        '......KSWK......',
        '......KSSK......',
        '.....YYKKYY.....',
        '......KTTK......',
        '......KTTK......',
        '......KTTK......',
        '.......BB.......',
        '.......KK.......',
      ],
      w_scythe: [
        '................',
        '................',
        '.........KKW....',
        '........KKW.....',
        '....KTKKKW......',
        '....KTKKW.......',
        '....KTKW........',
        '....KTK.........',
        '....KTK.........',
        '....KTK.........',
        '....KTK.........',
        '....KTK.........',
        '....KTK.........',
        '....KTK.........',
        '....KTK.........',
        '.....K..........',
      ],
      w_flail: [
        '................',
        '................',
        '............K...',
        '...........WW...',
        '..........SWW...',
        '.........S...K..',
        '........S.......',
        '.......S........',
        '.....KTK........',
        '.....KTK........',
        '.....KTK........',
        '.....KTK........',
        '.....KTK........',
        '.....KTK........',
        '.....KTK........',
        '................',
      ],
      w_crossbow: [
        '................',
        '................',
        '................',
        '.......W........',
        '.......W........',
        '...SSSSSSSSSS...',
        '...KSSSWSSSSK...',
        '.....TTWTTT.....',
        '......KTK.......',
        '......KTK.......',
        '......KTK.......',
        '......KTK.......',
        '......KTK.......',
        '................',
        '................',
        '................',
      ],
      w_glaive: [
        '................',
        '.........KKW....',
        '........KKKS....',
        '.......KKKS.....',
        '......KTK.......',
        '......KTK.......',
        '......KTK.......',
        '......KTK.......',
        '......KTK.......',
        '......KTK.......',
        '......KTK.......',
        '......KTK.......',
        '......KTK.......',
        '......KTK.......',
        '......KTK.......',
        '.......K........',
      ],
      w_gun: [
        '................',
        '................',
        '................',
        '................',
        '................',
        '...KY......W....',
        '..KYSSSSSSSS....',
        '..KYSSSSSSSS....',
        '...KY...KTK.....',
        '........KTK.....',
        '........KTK.....',
        '........KTK.....',
        '........KTK.....',
        '................',
        '................',
        '................',
      ],
      w_grimoire: [
        '................',
        '................',
        '....KKKKKKKK....',
        '...KPPPPPPPSK...',
        '...KPPPPPPPWK...',
        '...KPPPPPPPSK...',
        '...KPPPPPPPWK...',
        '...KPPPPPPPSK...',
        '...KPPPYYPPWK...',
        '...KPPPPPPPSK...',
        '...KPPPPPPPWK...',
        '...KPPPPPPPSK...',
        '...KPPPPPPPSK...',
        '....KKKKKKKK....',
        '................',
        '................',
      ],
      a_armor: [
        '................',
        '................',
        '.......YY.......',
        '....KDDDDDDK....',
        '....KDDDDDDK....',
        '....KYDDDDYK....',
        '....KYDDDDYK....',
        '....KYDDDDYK....',
        '....KYDDDDYK....',
        '....KYDDDDYK....',
        '....KYYYYYYK....',
        '....KYDDDDYK....',
        '....KYDDDDYK....',
        '.....KKKKKK.....',
        '................',
        '................',
      ],
      acc_ring: [
        '................',
        '................',
        '................',
        '................',
        '.......YW.......',
        '......Y..Y......',
        '.....Y....Y.....',
        '.....Y....Y.....',
        '......Y..Y......',
        '.......YY.......',
        '................',
        '................',
        '................',
        '................',
        '................',
        '................',
      ],
      acc_amulet: [
        '................',
        '................',
        '................',
        '......SSSS......',
        '......KKKK......',
        '.....KYYYYK.....',
        '.....KYYYYK.....',
        '.....KYBBYK.....',
        '.....KYYYYK.....',
        '.....KYYYYK.....',
        '.....KYYYYK.....',
        '......KKKK......',
        '................',
        '................',
        '................',
        '................',
      ],
      acc_charm: [
        '................',
        '................',
        '......KKKK......',
        '.....KWWWWK.....',
        '.....KWSSWK.....',
        '.....KWWWWK.....',
        '.....KWWWWK.....',
        '.....KWWWWK.....',
        '.....KWWWWK.....',
        '.....KWRRWK.....',
        '.....KWRRWK.....',
        '.....KWRRWK.....',
        '.....KWWWWK.....',
        '......KKKK......',
        '................',
        '................',
      ],

      // v18: pixel art readability (integer scaling) + compact numbers + Ë°å bar styling + smaller rarity pill
      acc_talisman: [
        '................',
        '................',
        '.....KKKKKK.....',
        '....KWWWWWSK....',
        '....KWWWWWSK....',
        '....KWWPWWSK....',
        '....KWWRWWSK....',
        '....KWWPWWSK....',
        '....KWWRWWSK....',
        '....KWWPWWSK....',
        '....KWWRWWSK....',
        '....KWWWWWSK....',
        '.....KKKKKK.....',
        '................',
        '................',
        '................',
      ],
      acc_bracelet: [
        '................',
        '................',
        '................',
        '................',
        '................',
        '................',
        '.....K....K.....',
        '.....BYBYBY.....',
        '.....YYYYYY.....',
        '.....K....K.....',
        '................',
        '................',
        '................',
        '................',
        '................',
        '................',
      ],
      acc_pendant: [
        '................',
        '................',
        '................',
        '.......YY.......',
        '......KYYK......',
        '.....KY..YK.....',
        '.....KY..YK.....',
        '.......PP.......',
        '.......YY.......',
        '.......YY.......',
        '......K..K......',
        '................',
        '................',
        '................',
        '................',
        '................',
      ],
      acc_earring: [
        '................',
        '................',
        '................',
        '........S.......',
        '........S.......',
        '.......KKK......',
        '......KPPPK.....',
        '......KPBPK.....',
        '......KPPPK.....',
        '......KPPPK.....',
        '.......KKK......',
        '................',
        '................',
        '................',
        '................',
        '................',
      ],
      acc_sigil: [
        '................',
        '................',
        '................',
        '.....KKKKKK.....',
        '....KDDDDDDK....',
        '....KDDDDDDK....',
        '....KDDYYDDK....',
        '....KDYYYYDK....',
        '....KDDYYDDK....',
        '....KDDYYDDK....',
        '....KDDDDDDK....',
        '....KDDDDDDK....',
        '.....KKKKKK.....',
        '................',
        '................',
        '................',
      ],
      acc_gem: [
        '................',
        '................',
        '................',
        '................',
        '........K.......',
        '.......KBK......',
        '......KB.BK.....',
        '.....KB...BK....',
        '.....K..W..K....',
        '.....BK...KB....',
        '......BK.KB.....',
        '.......BKB......',
        '........B.......',
        '................',
        '................',
        '................',
      ],
      acc_beads: [
        '................',
        '................',
        '................',
        '................',
        '................',
        '.......YY.......',
        '......B..B......',
        '.....B....B.....',
        '......Y..Y......',
        '.......YB.......',
        '................',
        '................',
        '................',
        '................',
        '................',
        '................',
      ],
      acc_watch: [
        '................',
        '................',
        '.......SS.......',
        '.......SS.......',
        '.......SS.......',
        '.......YY.......',
        '......Y..Y......',
        '.....Y.WW.Y.....',
        '.....Y..W.Y.....',
        '......Y..Y......',
        '.......YY.......',
        '.......SS.......',
        '.......SS.......',
        '.......SS.......',
        '................',
        '................',
      ],

      unique: [
        '................',
        '.......KK.......',
        '.......WW.......',
        '.......YY.......',
        '.......YY.......',
        '.......YY.......',
        '.......YY.......',
        '.......YY.......',
        '.......YY.......',
        '......YPPY......',
        '......P..P......',
        '.....P.BB.P.....',
        '......B..B......',
        '................',
        '................',
        '................',
      ],      // v13 override (hero)
      hero: [
        '................',
        '......KKKK...Y..',
        '.....KSSSSK..Y..',
        '....KSDSSDSK..T.',
        '...KSDWWWWDSK.T.',
        '...KSDWRRWDSK.T.',
        '...KSDWSSWDSK.T.',
        '....KSDYYYYDK.T.',
        '....KSDDDDDDK.T.',
        '...KSDDDDDDDDKT.',
        '...KSDDDYYDDDKT.',
        '...KSDDDDDDDDKT.',
        '....KSDDTTDDK.T.',
        '.....KTT..TK..T.',
        '.....KTT..TK..T.',
        '....KK....KK..K.',
      ],
      hero_atk: [
        '............BB..',
        '......KKKK..YY..',
        '.....KSSSSK.YY..',
        '....KSDSSDSK..T.',
        '...KSDWWWWDSK.T.',
        '...KSDWRRWDSK.T.',
        '..WKSDWSSWDSK.T.',
        '...WKSDYYYYDK.T.',
        '....YSDDDDDDK.T.',
        '...KSDDDDDDDDKT.',
        '...KSDDDYYDDDKT.',
        '...KSDDDDDDDDKT.',
        '....KSDDTTDDK.T.',
        '.....KTT..TK..T.',
        '.....KTT..TK..T.',
        '....KK....KK..K.',
      ],
      hero_dead: [
        '................',
        '................',
        '....KKKKKK......',
        '...KSSSSSSK.....',
        '..KSDWWWWDSK....',
        '..KSDWKKWDSK....',
        '...KSDRRRDK.....',
        '....KSDDDK......',
        '.....KDDK.......',
        '....KDDDK.......',
        '...KDDDDDK......',
        '..KDDTTTDDK.....',
        '..KTT....TTK....',
        '...KTT..TTK.....',
        '....KKKKKK......',
        '................',
      ],
      none: [
        '................',
        '................',
        '................',
        '................',
        '................',
        '................',
        '................',
        '................',
        '................',
        '................',
        '................',
        '................',
        '................',
        '................',
        '................',
        '................',
      ],
    };

    const cache = new Map();
    function bake(key){
      if (cache.has(key)) return cache.get(key);
      const spr = SPRITES[key] || SPRITES.none;
      const c = document.createElement('canvas');
      c.width = 16; c.height = 16;
      const ctx = c.getContext('2d');
      ctx.imageSmoothingEnabled = false;
      ctx.clearRect(0,0,16,16);
      for (let y=0;y<16;y++){
        const row = spr[y] || '';
        for (let x=0;x<16;x++){
          const ch = row[x] || '.';
          const col = PAL[ch];
          if (!col) continue;
          ctx.fillStyle = col;
          ctx.fillRect(x, y, 1, 1);
        }
      }
      cache.set(key, c);
      return c;
    }

    
    function rarityColorFromCanvas(canvas){
      try{
        const cl = canvas && canvas.classList;
        if (!cl) return '#e6edf3';
        if (cl.contains('rar-unique')) return '#fb7185';
        if (cl.contains('rar-legendary')) return '#fbbf24';
        if (cl.contains('rar-epic')) return '#c4b5fd';
        if (cl.contains('rar-rare')) return '#93c5fd';
        if (cl.contains('rar-uncommon')) return '#86efac';
        if (cl.contains('rar-common')) return '#cbd5e1';
      }catch(_){}
      return '#e6edf3';
    }

    function drawGlyphIcon(ctx, w, h, glyph, canvas){
      if (!glyph) return;
      ctx.save();
      ctx.clearRect(0,0,w,h);

      // subtle plate
      ctx.imageSmoothingEnabled = true;
      ctx.fillStyle = 'rgba(9,14,22,0.45)';
      ctx.fillRect(0,0,w,h);
      ctx.lineWidth = Math.max(1, Math.round(Math.min(w,h)*0.08));
      ctx.strokeStyle = 'rgba(226,237,243,0.10)';
      ctx.strokeRect(0.5,0.5,w-1,h-1);

      // glyph (centered by metrics; colored by rarity)
      const fg = rarityColorFromCanvas(canvas);
      const fs = Math.round(Math.min(w,h)*0.78);
      ctx.font = `900 ${fs}px "Noto Serif JP","Hiragino Mincho ProN","Yu Mincho",serif`;
      ctx.lineWidth = Math.max(2, Math.round(fs*0.10));
      ctx.strokeStyle = 'rgba(0,0,0,0.60)';
      ctx.fillStyle = fg;

      // metric-centering
      let x = Math.round(w/2), y = Math.round(h/2);
      try{
        const m = ctx.measureText(glyph);
        if (m && m.actualBoundingBoxLeft != null && m.actualBoundingBoxRight != null && m.actualBoundingBoxAscent != null && m.actualBoundingBoxDescent != null){
          const bw = m.actualBoundingBoxLeft + m.actualBoundingBoxRight;
          const bh = m.actualBoundingBoxAscent + m.actualBoundingBoxDescent;
          x = Math.round((w - bw)/2 + m.actualBoundingBoxLeft);
          y = Math.round((h - bh)/2 + m.actualBoundingBoxAscent);
          ctx.textAlign = 'left';
          ctx.textBaseline = 'alphabetic';
        } else {
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
        }
      } catch(_){
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
      }

      // small glow only for high rarities (kept tight to avoid blur)
      if (canvas && canvas.classList){
        if (canvas.classList.contains('rar-legendary') || canvas.classList.contains('rar-unique')){
          ctx.shadowColor = fg;
          ctx.shadowBlur = Math.round(fs*0.10);
        }
      }

      ctx.strokeText(glyph, x, y);
      ctx.fillText(glyph, x, y);

      ctx.restore();
    }

function draw(canvas, key){
      if (!canvas) return;
      const ctx = canvas.getContext('2d');
      if (!ctx) return;
      ctx.imageSmoothingEnabled = true;
      const w = canvas.width|0, h = canvas.height|0;
      ctx.clearRect(0,0,w,h);

      const glyph = canvas.getAttribute('data-glyph');
      if (glyph){
        drawGlyphIcon(ctx, w, h, glyph, canvas);
        return;
      }

      const im = (typeof SPRIMG_IMG !== 'undefined') ? SPRIMG_IMG[key] : null;
      if (im){
        if (im.complete && im.naturalWidth){
          ctx.drawImage(im, 0, 0, w, h);
        } else {
          im.addEventListener('load', () => {
            try { draw(canvas, key); } catch(_){}
          }, { once: true });
        }
        return;
      }

      // Fallback: avoid pixelated dot-sprites on modern displays.
      // If we don't have an image sprite and no explicit glyph, render a clean monogram.
      try{
        let g = '';
        if (key === 'unique') g = '‚òÖ';
        else if (key === 'none') g = '';
        else if (String(key||'').startsWith('w_')) g = 'Ê≠¶';
        else if (String(key||'').startsWith('a_')) g = 'Èò≤';
        else if (String(key||'').startsWith('acc_')) g = 'È£æ';
        else if (String(key||'').startsWith('i_')) g = 'Âç∞';
        else g = (key ? String(key)[0] : '„Éª');
        if (g){
          drawGlyphIcon(ctx, w, h, g, canvas);
          return;
        }
      }catch(_){ }

      // Last resort (debug): legacy dot sprite
      ctx.imageSmoothingEnabled = false;
      const src = bake(key);
      ctx.drawImage(src, 0, 0, w, h);
    }

    const WEAPON_BASES = ['Âä†ÊåÅÈå´Êùñ','ÈôÄÁæÖÂ∞ºÁµåÂ∑ª','Á†¥È≠îÂº©','ÈáëÂâõÈÄ£Áè†Á†≤','Áü≠ÈáëÂâõÂâ£','Â§ßÈáëÂâõÂâ£','ËìÆËèØÂâ£','ÈáëÂâõËñôÂàÄ','ÈáëÂâõÁè†Èéö','ÈáëÂâõÂâ£','Á†¥ÁÖ©ÊÇ©Êñß','ÈáëÂâõÊßç','Êñ≠Ê•≠Èéå','ËìÆÂºì','Èå´Êùñ','ÈáëÂâõÊßå','ÈáëÂâõÊ£ç','‰∏çÂãïÂàÄ'];
    const ARMOR_BASES = ['ÈáëÂâõÈéñË°£','ÈæçÈ±óÊ≥ïË°£','ÈáëÂâõÊùøË°£','ÁµêÁïåÂ§ñÂ•ó','Èö†ÂØÜË°£','ÁöÆÊ≥ïË°£','ÈéñÂ≠êË°£','ÊùøË°£','È±óË°£','Ë¢àË£ü','Ê≥ïË°£','Â§ñÂ•ó'];
    const ACC_BASES = ['ÊôÇËº™','Á•àÁ•∑Áè†','ÂøµÁè†Ë≠∑ËÖïËº™','ËÄ≥Ëº™','Ë≠∑Á¨¶','‰Ω©Á¨¶','ÈúäÁ¨¶','Âç∞Â•ëÁ´†','Â¶ÇÊÑèÂÆùÁè†','Ë≠∑Ë≠∑ËÖïËº™','ÂøµÁ¨¶','ÊàíÁí∞'];

    function baseFromName(name, slot){
      name = String(name||'');
      const list = slot==='weapon' ? WEAPON_BASES : slot==='armor' ? ARMOR_BASES : ACC_BASES;
      for (const b of list){
        if (name.endsWith(b)) return b;
      }
      return '';
    }

    function itemGlyph(it){
      if (!it) return '„Éª';
      const slot = it.slot || '';
      const name = String(it.name || '');
      const base = baseFromName(name, slot);
      // Prefer a type-like kanji from the base name (e.g., Ââ£/Êßç/Êùñ/Ë°£/Áè†/Á¨¶/Ëº™...)
      if (base){
        for (let i = base.length - 1; i >= 0; i--){
          const ch = base[i];
          if (/[‰∏Ä-ÈæØ„ÄÖ]/.test(ch)) return ch;
        }
      }
      // Otherwise pick the first kanji-ish character in the full name
      for (const ch of name){
        if (/[‰∏Ä-ÈæØ„ÄÖ]/.test(ch)) return ch;
      }
      // Fallback by slot
      if (slot === 'weapon') return 'ÂàÉ';
      if (slot === 'armor') return 'Ë°£';
      if (slot === 'accessory') return 'Áè†';
      return name ? name[0] : '„Éª';
    }

    function itemKey(it){
      if (!it) return 'none';
      if (it.rarity === 'unique') return 'unique';
      if (it.slot === 'weapon'){
        const b = baseFromName(it.name, 'weapon');
        const map = { 'ÈáëÂâõÂâ£':'w_sword','Â§ßÈáëÂâõÂâ£':'w_greatsword','ËìÆËèØÂâ£':'w_rapier','Á†¥ÁÖ©ÊÇ©Êñß':'w_axe','ÈáëÂâõÊßç':'w_spear','ÈáëÂâõËñôÂàÄ':'w_glaive','Êñ≠Ê•≠Èéå':'w_scythe','ÈáëÂâõÁè†Èéö':'w_flail','Áü≠ÈáëÂâõÂâ£':'w_dagger','ËìÆÂºì':'w_bow','Á†¥È≠îÂº©':'w_crossbow','Èå´Êùñ':'w_staff','Âä†ÊåÅÈå´Êùñ':'w_wand','ÈôÄÁæÖÂ∞ºÁµåÂ∑ª':'w_grimoire','ÈáëÂâõÊßå':'w_hammer','ÈáëÂâõÊ£ç':'w_mace','ÈáëÂâõÈÄ£Áè†Á†≤':'w_gun','‰∏çÂãïÂàÄ':'w_katana' };
        return (map[b] || 'w_sword');
      }
      if (it.slot === 'armor') return 'a_armor';
      if (it.slot === 'accessory'){
        const b = baseFromName(it.name, 'accessory');
        const map = { 'ÊàíÁí∞':'acc_ring','Ë≠∑Á¨¶':'acc_amulet','ÂøµÁ¨¶':'acc_charm','ÈúäÁ¨¶':'acc_talisman','ÂøµÁè†Ë≠∑ËÖïËº™':'acc_bracelet','‰Ω©Á¨¶':'acc_pendant','ËÄ≥Ëº™':'acc_earring','Ë≠∑Ë≠∑ËÖïËº™':'acc_bracelet','Âç∞Â•ëÁ´†':'acc_sigil','Â¶ÇÊÑèÂÆùÁè†':'acc_gem','Á•àÁ•∑Áè†':'acc_beads','ÊôÇËº™':'acc_watch' };
        return (map[b] || 'acc_ring');
      }
      return 'none';
    }

    

const ENEMY_SPRITE_MAP = {
    "‰∏çÊµÑË≤™":"i_chain",
    "‰∫îËòä":"i_skull",
    "ÂàÜÂà•":"enemy_generic",
    "ÂâõÂº∑ÊàëÊÖ¢":"enemy_generic",
    "Âõ†Êûú„ÅÆÊ≥ï":"i_scales",
    "Âõ†ÊûúÈ°õÂÄí":"i_scales",
    "Âü∑Âèñ":"i_chain",
    "Â¢ó‰∏äÊÖ¢":"i_crown",
    "Â§©‰∫∫‰∫îË°∞":"i_skull",
    "Â¶ÑÊÉ≥":"i_cloud",
    "Â´â":"enemy_generic",
    "ÂÆ≥":"i_flame",
    "Â∏∏È°õÂÄí":"i_cloud",
    "ÂπªÂåñ":"i_cloud",
    "Âøø":"i_flame",
    "ÊÄ®ÊÅ®":"i_flame",
    "ÊÑöÁó¥":"i_eye",
    "ÊÖ¢":"i_crown",
    "ÊÜç":"i_crown",
    "ÊàëÂü∑":"enemy_generic",
    "ÊàëË™ûÂèñ":"i_chain",
    "ÊàëÈ°õÂÄí":"i_cloud",
    "ÊàíÁ¶ÅÂèñ":"i_chain",
    "ÊéâÊåô":"enemy_generic",
    "ÊîæÈÄ∏":"enemy_generic",
    "Êï£‰π±":"i_cloud",
    "ÊúâÊÑõ":"i_chain",
    "ÊúâË∫´Ë¶ã":"i_eye",
    "ÊúâÈ†Ç":"i_crown",
    "ÊúâÈ†ÇÊÖ¢":"i_crown",
    "ÊüìÊÑõ":"i_chain",
    "Ê†πÊú¨ÁÑ°Êòé":"i_eye",
    "Ê•≠Êûú":"i_scales",
    "Ê•≠Êûú„ÉªÁï∞ÁÜü":"i_scales",
    "Ê•≠ÁÅ´":"i_flame",
    "Ê•≠Èöú":"i_scales",
    "Ê•ΩÈ°õÂÄí":"i_cloud",
    "Ê¨≤Âèñ":"i_chain",
    "Ê¨≤ÊÑõ":"i_chain",
    "Ê¨≤Ë≤™Ëìã":"i_chain",
    "Ê≠ªÁïè":"i_skull",
    "ÊµÑÈ°õÂÄí":"i_cloud",
    "Ê∏áÊÑõ":"i_chain",
    "ÁÑ°Â∏∏":"i_skull",
    "ÁÑ°Êòé":"i_eye",
    "ÁÑ°ÊòéÁ∏ÅË≠ò":"i_cloud",
    "ÁÑ°Ëâ≤ÁïåÊÑõ":"i_chain",
    "ÁÖ©ÊÇ©":"i_flame",
    "ÁÖ©ÁÜ±":"i_flame",
    "Áñë":"i_question",
    "Áó¥":"i_eye",
    "ÁûãÊÅö":"i_flame",
    "ÁûãÊÅöÈöèÁú†":"enemy_generic",
    "ÁûãÁÅ´":"i_flame",
    "Ëâ≤ÁïåÊÑõ":"i_chain",
    "Ëã¶Ëã¶":"i_skull",
    "Ë¶ãÂèñ":"i_chain",
    "Ë≤™Ê¨≤":"i_chain",
    "Ë≤™Áó¥":"i_chain",
    "Ëº™Âªª":"i_wheel",
    "ÈÇ™Ë¶ã":"i_cloud",
    "ÈóòË´ç":"i_flame",
    "ÈóòË´çÈöèÁú†":"i_flame",
    "ÈöèÁú†":"i_eye",
    "È°õÂÄí":"i_cloud"
  };

function enemyKey(enemy){
      if (!enemy) return 'none';
      const n = String(enemy.name||'');
      const mapped = (typeof ENEMY_SPRITE_MAP !== 'undefined') ? ENEMY_SPRITE_MAP[n] : null;
      if (mapped) return mapped;
      if (enemy.isBoss) return 'boss';
      return 'enemy_generic';
    }

    function has(k){ return !!SPRITES[k]; }

    return { draw, itemKey, enemyKey, has, itemGlyph };
  })();

  function renderSpriteCanvases(root){
    try{
      if (!root) return;
      root.querySelectorAll('canvas[data-spr]').forEach(c => {
        const key = c.getAttribute('data-spr') || 'none';
        SPR.draw(c, key);
      });
    } catch(_){ }
  }
  // --------------------
  // Enemy "kanji icon" (single-character) rendering
  // --------------------
  function enemyKanji1(name){
    const s = String(name||'');
    for (const ch of s){
      if (/[‰∏Ä-ÈæØ„ÄÖ]/.test(ch)) return ch;
    }
    return s ? s[0] : 'È≠î';
  }

  function roundRectPath(ctx, x, y, w, h, r){
    r = Math.max(0, Math.min(r, Math.min(w,h)/2));
    ctx.beginPath();
    ctx.moveTo(x+r, y);
    ctx.arcTo(x+w, y, x+w, y+h, r);
    ctx.arcTo(x+w, y+h, x, y+h, r);
    ctx.arcTo(x, y+h, x, y, r);
    ctx.arcTo(x, y, x+w, y, r);
    ctx.closePath();
  }

  function drawEnemyKanji(canvas, enemy){
    if (!canvas) return;
    const ctx = canvas.getContext('2d');
    if (!ctx) return;
    const w = canvas.width|0, h = canvas.height|0;
    ctx.clearRect(0,0,w,h);

    // subtle plate
    ctx.save();
    ctx.imageSmoothingEnabled = true;
    const pad = Math.round(Math.min(w,h) * 0.06);
    const rr = Math.round(Math.min(w,h) * 0.22);
    roundRectPath(ctx, pad, pad, w-pad*2, h-pad*2, rr);
    ctx.fillStyle = 'rgba(9,14,22,0.45)';
    ctx.fill();
    ctx.lineWidth = Math.max(1, Math.round(Math.min(w,h)*0.06));
    ctx.strokeStyle = 'rgba(226,237,243,0.08)';
    ctx.stroke();

    // glyph
    const g = enemyKanji1(enemy && enemy.name);
    let fg = '#e6edf3';
    if (enemy && enemy.isBoss) fg = '#fb7185';
    else if (enemy && enemy.isElite) fg = '#fbbf24';

    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    const fs = Math.round(Math.min(w,h)*0.76);
    ctx.font = `900 ${fs}px "Noto Serif JP","Hiragino Mincho ProN","Yu Mincho",serif`;
    ctx.lineWidth = Math.max(2, Math.round(fs*0.10));
    ctx.strokeStyle = 'rgba(0,0,0,0.55)';
    ctx.strokeText(g, w/2, h/2 + 1);
    ctx.fillStyle = fg;
    ctx.fillText(g, w/2, h/2 + 1);
    ctx.restore();
  }

  function drawHeroKanji(canvas, hero, mode){
    if (!canvas) return;
    const ctx = canvas.getContext('2d');
    if (!ctx) return;
    const w = canvas.width|0, h = canvas.height|0;
    ctx.clearRect(0,0,w,h);

    // subtle plate (same as enemy/icons)
    ctx.save();
    ctx.imageSmoothingEnabled = true;
    const pad = Math.round(Math.min(w,h) * 0.06);
    const rr = Math.round(Math.min(w,h) * 0.22);
    roundRectPath(ctx, pad, pad, w-pad*2, h-pad*2, rr);
    ctx.fillStyle = 'rgba(9,14,22,0.45)';
    ctx.fill();
    ctx.lineWidth = Math.max(1, Math.round(Math.min(w,h)*0.06));
    ctx.strokeStyle = 'rgba(226,237,243,0.08)';
    ctx.stroke();

    // glyph
    const g = (hero && hero.dead) ? '‰∫°' : (mode==='atk' ? 'ÊíÉ' : 'Ë°å');
    let fg = (hero && hero.dead) ? '#fb7185' : (mode==='atk' ? '#fbbf24' : '#e6edf3');
    try{
      const md = document.documentElement.getAttribute('data-mandala');
      if (!(hero && hero.dead)){
        if (md === 'kongo') fg = '#93c5fd';
        else if (md === 'taizo') fg = '#86efac';
      }
    }catch(_){}

    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    const fs = Math.round(Math.min(w,h)*0.76);
    ctx.font = `900 ${fs}px "Noto Serif JP","Hiragino Mincho ProN","Yu Mincho",serif`;
    ctx.lineWidth = Math.max(2, Math.round(fs*0.10));
    ctx.strokeStyle = 'rgba(0,0,0,0.55)';
    ctx.strokeText(g, w/2, h/2 + 1);
    ctx.fillStyle = fg;
    ctx.fillText(g, w/2, h/2 + 1);
    ctx.restore();
  }





  function updateHUDSprites(){
    try{
      // hero
      if (els.heroSprite){
        drawHeroKanji(els.heroSprite, S.hero);
      }
      if (els.heroStageSprite){
        drawHeroKanji(els.heroStageSprite, S.hero);
      }
      // enemy
      if (els.enemySprite){
        drawEnemyKanji(els.enemySprite, S.run && S.run.enemy);
      }
      if (els.enemyStageSprite){
        drawEnemyKanji(els.enemyStageSprite, S.run && S.run.enemy);
      }
      // gear
      if (els.eqWeaponIcon){
        const it = S.gear && S.gear.weapon;
        els.eqWeaponIcon.classList.toggle('rar-common', !!it && it.rarity==='common');
        els.eqWeaponIcon.classList.toggle('rar-uncommon', !!it && it.rarity==='uncommon');
        els.eqWeaponIcon.classList.toggle('rar-rare', !!it && it.rarity==='rare');
        els.eqWeaponIcon.classList.toggle('rar-epic', !!it && it.rarity==='epic');
        els.eqWeaponIcon.classList.toggle('rar-legendary', !!it && it.rarity==='legendary');
        els.eqWeaponIcon.classList.toggle('rar-unique', !!it && it.rarity==='unique');
        if (it) els.eqWeaponIcon.setAttribute('data-glyph', SPR.itemGlyph(it)); else els.eqWeaponIcon.removeAttribute('data-glyph');
        SPR.draw(els.eqWeaponIcon, it ? SPR.itemKey(it) : 'none');
      }
      if (els.eqArmorIcon){
        const it = S.gear && S.gear.armor;
        els.eqArmorIcon.classList.toggle('rar-common', !!it && it.rarity==='common');
        els.eqArmorIcon.classList.toggle('rar-uncommon', !!it && it.rarity==='uncommon');
        els.eqArmorIcon.classList.toggle('rar-rare', !!it && it.rarity==='rare');
        els.eqArmorIcon.classList.toggle('rar-epic', !!it && it.rarity==='epic');
        els.eqArmorIcon.classList.toggle('rar-legendary', !!it && it.rarity==='legendary');
        els.eqArmorIcon.classList.toggle('rar-unique', !!it && it.rarity==='unique');
        if (it) els.eqArmorIcon.setAttribute('data-glyph', SPR.itemGlyph(it)); else els.eqArmorIcon.removeAttribute('data-glyph');
        SPR.draw(els.eqArmorIcon, it ? SPR.itemKey(it) : 'none');
      }
      if (els.eqAccIcon){
        const it = S.gear && S.gear.accessory;
        els.eqAccIcon.classList.toggle('rar-common', !!it && it.rarity==='common');
        els.eqAccIcon.classList.toggle('rar-uncommon', !!it && it.rarity==='uncommon');
        els.eqAccIcon.classList.toggle('rar-rare', !!it && it.rarity==='rare');
        els.eqAccIcon.classList.toggle('rar-epic', !!it && it.rarity==='epic');
        els.eqAccIcon.classList.toggle('rar-legendary', !!it && it.rarity==='legendary');
        els.eqAccIcon.classList.toggle('rar-unique', !!it && it.rarity==='unique');
        if (it) els.eqAccIcon.setAttribute('data-glyph', SPR.itemGlyph(it)); else els.eqAccIcon.removeAttribute('data-glyph');
        SPR.draw(els.eqAccIcon, it ? SPR.itemKey(it) : 'none');
      }
    } catch(_){ }
  }


  function updateHUDSpritesLite(){
    try{
      // Kanji icons only (cheap): keeps MAX speed UI from looking frozen.
      if (els.heroSprite) drawHeroKanji(els.heroSprite, S.hero);
      if (els.enemySprite) drawEnemyKanji(els.enemySprite, S.run && S.run.enemy);
      if (els.heroStageSprite) drawHeroKanji(els.heroStageSprite, S.hero);
      if (els.enemyStageSprite) drawEnemyKanji(els.enemyStageSprite, S.run && S.run.enemy);
    } catch(_){ }
  }


  // --------------------
  // Battle stage animation (CSS + optional sprite swap)
  // --------------------
  // --------------------
  // Battle FX (v30: full-canvas particles + camera punch)
  // --------------------
  const BFX = (() => {
    const st = { running:false, lastT:0, acc:0, dpr:1, vw:1, vh:1, maxP:140, fps:40, stageSize:64 };
    const fx = { particles:[], rings:[], slashes:[], haze:0, hazeHue:190 };
    const cam = { x:0, y:0, z:1, vx:0, vy:0, vz:0 };
    let enabled = true;

    function ok(){ return !!(els.battleFxFull && els.battleStage); }
    function rect(){ return els.battleStage.getBoundingClientRect(); }

    function resetAll(clearCanvas=true){
      fx.particles.length = 0; fx.rings.length = 0; fx.slashes.length = 0;
      fx.haze = 0;
      cam.x = cam.y = 0; cam.z = 1; cam.vx = cam.vy = 0; cam.vz = 0;
      if (els.battleStage){
        els.battleStage.style.setProperty('--camX','0px');
        els.battleStage.style.setProperty('--camY','0px');
        els.battleStage.style.setProperty('--camZ','1');
        try{ els.battleStage.classList.remove('hitstop'); }catch(_){ }
      }
      if (clearCanvas && els.battleFxFull){
        try{
          resize();
          const ctx = els.battleFxFull.getContext('2d');
          if (ctx){
            ctx.setTransform(st.dpr,0,0,st.dpr,0,0);
            ctx.clearRect(0,0,st.vw,st.vh);
          }
        }catch(_){ }
      }
    }

    function setEnabled(v){
      enabled = !!v;
      if (!enabled){
        st.running = false;
        resetAll(true);
      }
    }

    function resize(force=false){
      if (!ok()) return;
      const r = rect();
      if (!(r.width>0 && r.height>0)) return;
      st.dpr = Math.min(1.5, window.devicePixelRatio || 1);
      const cw = Math.max(1, Math.round(r.width * st.dpr));
      const ch = Math.max(1, Math.round(r.height * st.dpr));
      const c = els.battleFxFull;
      if (force || c.width !== cw || c.height !== ch){
        c.width = cw; c.height = ch;
      }
      st.vw = r.width; st.vh = r.height;
      // stage sprite display size (hero height) for scaling slash thickness
      try{
        const v = getComputedStyle(document.documentElement).getPropertyValue("--stageSize");
        const n = parseFloat(v);
        st.stageSize = (Number.isFinite(n) && n>0) ? n : 64;
      } catch(_){ st.stageSize = 64; }
      // dash distance for CSS keyframes
      const dash = clamp(r.width * 0.22, 90, 220);
      els.battleStage.style.setProperty('--dash', `${Math.round(dash)}px`);
    }

    function posFromEl(el, yBias=0.58, xBias=0.55){
      const sr = rect();
      if (!(sr.width>0 && sr.height>0)) return { x: sr.width*0.5, y: sr.height*0.6 };
      if (!el) return { x: sr.width*0.5, y: sr.height*0.6 };
      const r = el.getBoundingClientRect();
      const x = (r.left + r.width * xBias) - sr.left;
      const y = (r.top  + r.height * yBias) - sr.top;
      return { x, y };
    }

    function flash(hue=190){
      if (!enabled) return;
      if (!els.battleFlash) return;
      els.battleFlash.style.setProperty('--flashHue', String(hue));
      els.battleFlash.classList.remove('on');
      void els.battleFlash.offsetWidth;
      els.battleFlash.classList.add('on');
    }

    function hitStop(ms=60){
      if (!enabled) return;
      if (!els.battleStage) return;
      els.battleStage.classList.add('hitstop');
      window.setTimeout(() => {
        try { els.battleStage && els.battleStage.classList.remove('hitstop'); } catch(_){ }
      }, ms);
    }

    function punch(power=1, dir=1){
      if (!enabled) return;
      if (!ok()) return;
      resize();
      // Clamp impulses so ultra-high game speed (e.g., 16x) doesn't shove the stage out of view
      const maxVx = Math.max(26, st.vw * 0.09);
      const maxVy = Math.max(18, st.vh * 0.16);
      const maxVz = 0.10;
      cam.vx = clamp(cam.vx + dir * 22 * power, -maxVx, maxVx);
      cam.vy = clamp(cam.vy + (-12 * power), -maxVy, maxVy);
      cam.vz = clamp(cam.vz + 0.045 * power, -maxVz, maxVz);
      fx.haze = Math.min(1, fx.haze + 0.20 * power);
      start();
    }

    function impact(x, y, power=1, hue=190){
      if (!enabled) return;
      if (!ok()) return;
      resize();
      fx.hazeHue = hue;
      // ring
      fx.rings.push({ x, y, r: 8, dr: 520 * power, w: 10 + 10*power, a: 0.9, t:0, life: 0.22 + 0.12*power, hue });
      // particles
      const n = Math.floor(12 + 16 * power);
      for (let i=0;i<n;i++){
        const ang = rand(0, Math.PI*2);
        const spd = rand(140, 420) * power;
        fx.particles.push({ x, y, vx: Math.cos(ang)*spd, vy: Math.sin(ang)*spd - rand(30,140)*power, s: rand(2, 4)*power, t:0, life: rand(0.18, 0.38), hue, a: rand(0.55, 0.95) });
      }
      if (fx.particles.length > st.maxP) fx.particles.splice(0, fx.particles.length - st.maxP);
      fx.haze = Math.min(1, fx.haze + 0.30 * power);
      start();
    }

    function slash(x1, y1, x2, y2, power=1, hue=190, lv=1){
      if (!enabled) return;
      if (!ok()) return;
      resize();
      fx.hazeHue = hue;
      const p = clamp(power, 0.60, 2.35);
      const LMAX = (typeof LV_VIS_MAX !== "undefined") ? LV_VIS_MAX : 99999;
      const lvN = clamp(Math.floor((lv ?? 1) || 1), 1, LMAX);
      // Êñ¨ÊíÉ„ÅÆÁ∑öÂπÖ„ÅØ "‰Ωç" „ÅßÊ±∫„ÇÅ„Çã: ‰Ωç1=Á≥∏ / ‰ΩçMAX=Ë°åËÄÖ„ÅÆË∫´Èï∑Ôºà--stageSizeÔºâ
      const t‰Ωç = (lvN <= 1) ? 0 : (Math.log10(lvN) / Math.log10(LMAX));
      const maxW = (Number.isFinite(st.stageSize) && st.stageSize>0) ? st.stageSize : 64;
      const wMin = 0.45;
      const w0 = wMin + (maxW - wMin) * Math.pow(clamp(t‰Ωç, 0, 1), 3.2);
      const curve = rand(-1,1) * (50 + 60*p);
      fx.slashes.push({ x1, y1, x2, y2, curve, t:0, life: 0.18 + 0.08*p, hue, w0 });
      // lightweight after-image: only sometimes (mostly on crit / high power)
      if (p > 1.15 && rand(0,1) < 0.55){
        const w1 = Math.max(0.35, w0 * rand(0.42, 0.62));
        fx.slashes.push({ x1: x1 + rand(-8,8), y1: y1 + rand(-8,8), x2: x2 + rand(-8,8), y2: y2 + rand(-8,8), curve: curve*0.75, t:0, life: 0.14 + 0.06*p, hue: hue+rand(-8,8), w0: w1 });
      }
      fx.haze = Math.min(1, fx.haze + 0.20 * power);
      start();
    }

    function start(){
      if (!enabled) return;
      if (st.running) return;
      st.running = true;
      st.lastT = performance.now();
      st.acc = 0;
      requestAnimationFrame(tick);
    }

    function tick(t){
      if (!enabled){ st.running = false; resetAll(true); return; }
      if (!ok()) { st.running = false; return; }
      const raw = (t - st.lastT) / 1000;
      st.lastT = t;
      st.acc += raw;
      const step = 1 / st.fps;
      if (st.acc < step){
        requestAnimationFrame(tick);
        return;
      }
      const dt = Math.min(0.05, st.acc);
      st.acc = 0;
      resize();

      // camera spring
      cam.x += cam.vx; cam.y += cam.vy;
      cam.z += cam.vz;
      cam.vx *= 0.72; cam.vy *= 0.72; cam.vz *= 0.68;
      cam.x *= 0.72; cam.y *= 0.72;
      cam.z = 1 + (cam.z - 1) * 0.72;

      // Clamp camera offset to viewport so it never drifts off-screen
      const maxX = Math.max(22, st.vw * 0.06);
      const maxY = Math.max(14, st.vh * 0.18);
      cam.x = clamp(cam.x, -maxX, maxX);
      cam.y = clamp(cam.y, -maxY, maxY);

      // apply camera vars
      els.battleStage.style.setProperty('--camX', `${cam.x.toFixed(1)}px`);
      els.battleStage.style.setProperty('--camY', `${cam.y.toFixed(1)}px`);
      els.battleStage.style.setProperty('--camZ', `${cam.z.toFixed(3)}`);

      // step FX
      for (const p of fx.particles){
        p.t += dt;
        p.vy += 900 * dt; // gravity
        p.x += p.vx * dt;
        p.y += p.vy * dt;
        p.vx *= Math.pow(0.18, dt);
        p.vy *= Math.pow(0.40, dt);
      }
      for (const r of fx.rings){
        r.t += dt;
        r.r += r.dr * dt;
        r.a = Math.max(0, 1 - (r.t / r.life));
      }
      for (const s of fx.slashes){ s.t += dt; }
      fx.haze = Math.max(0, fx.haze - 1.8 * dt);

      // prune
      fx.particles = fx.particles.filter(p => p.t < p.life);
      fx.rings = fx.rings.filter(r => r.t < r.life);
      fx.slashes = fx.slashes.filter(s => s.t < s.life);

      // draw
      const c = els.battleFxFull;
      const ctx = c.getContext('2d');
      if (ctx){
        ctx.setTransform(st.dpr,0,0,st.dpr,0,0);
        ctx.clearRect(0,0,st.vw,st.vh);

        // subtle haze flash (lightweight)
        if (fx.haze > 0.001){
          ctx.globalCompositeOperation = 'screen';
          ctx.fillStyle = `hsla(${fx.hazeHue}, 100%, 70%, ${0.10*fx.haze})`;
          ctx.fillRect(0,0,st.vw,st.vh);
        }

        ctx.globalCompositeOperation = 'lighter';

        // rings
        for (const r of fx.rings){
          const t0 = r.t / r.life;
          const lw = r.w * (1 - t0);
          ctx.save();
          ctx.lineCap = 'round';
          ctx.lineWidth = lw;
          ctx.strokeStyle = `hsla(${r.hue}, 100%, 70%, ${0.55*r.a})`;
          ctx.beginPath();
          ctx.arc(r.x, r.y, r.r, 0, Math.PI*2);
          ctx.stroke();
          ctx.restore();
        }

        // slashes
        for (const s of fx.slashes){
          const tt = clamp(s.t / s.life, 0, 1);
          const a = 1 - tt;
          const w = s.w0 * (1 - tt*0.55);
          const mx = (s.x1 + s.x2) / 2 + s.curve;
          const my = (s.y1 + s.y2) / 2 - s.curve;
          ctx.save();
          ctx.lineCap = 'round';
          ctx.lineJoin = 'round';
          ctx.lineWidth = w;
          ctx.strokeStyle = `hsla(${s.hue}, 100%, 72%, ${0.85*a})`;
          ctx.beginPath();
          ctx.moveTo(s.x1, s.y1);
          ctx.quadraticCurveTo(mx, my, s.x2, s.y2);
          ctx.stroke();
          ctx.restore();
        }

        // particles
        for (const p of fx.particles){
          const a = (1 - p.t/p.life) * p.a;
          ctx.fillStyle = `hsla(${p.hue}, 100%, 70%, ${a})`;
          ctx.fillRect(p.x - p.s*0.5, p.y - p.s*0.5, p.s, p.s);
        }
      }

      // stop condition
      const camEnergy = Math.abs(cam.vx)+Math.abs(cam.vy)+Math.abs(cam.vz) + Math.abs(cam.x)+Math.abs(cam.y) + Math.abs(cam.z-1);
      const alive = fx.particles.length + fx.rings.length + fx.slashes.length;
      if (alive === 0 && camEnergy < 0.35 && fx.haze < 0.01){
          // reset
        els.battleStage.style.setProperty('--camX','0px');
        els.battleStage.style.setProperty('--camY','0px');
        els.battleStage.style.setProperty('--camZ','1');
        st.running = false;
        return;
      }

      requestAnimationFrame(tick);
    }

    // python-like boolean fix (we'll rewrite above in python to JS)
    return { resize, posFromEl, flash, hitStop, punch, impact, slash, setEnabled };
  })();

  const BATTLE = (() => {
    const st = { lastText: 0, lastFx: 0 };

    function fxEnabled(){ return !((S.ui && Number(S.ui.fx) === 0)); }

    function toggleSound(){
      ensureMikkyoFields();
      S.ui.sound = (Number(S.ui.sound)===1) ? 0 : 1;
      if (S.ui.sound){ try{ SOUND.start(); }catch(_){ } } else { try{ SOUND.stop(); }catch(_){ } }
      try{ updateRealmFx(); }catch(_){ }
      save();
      dirtyHUD = true;
    }

    function fxPowFromDmg(dmg, isCrit=false){
      const d = Math.max(0, Number(dmg) || 0);
      // ‰º∏„Å≥„ÅØÈÄìÊ∏õÔºàÈ´òË™ø‰ºèÂäõ„Åß„ÇÇÊèèÁîªË≤†Ëç∑„ÅåÁàÜÁô∫„Åó„Å™„ÅÑ„Çà„ÅÜ„Å´ log Â∞∫Â∫¶Ôºâ
      let pow = 0.78 + 0.22 * Math.log10(d + 10);
      if (isCrit) pow *= 1.18;
      // È´òÈÄüÊôÇ„ÅØÂ∞ë„ÅóÊäë„Åà„ÇãÔºà16x „Åß„ÇÇÁ†¥Á∂ª„Åó„Å´„Åè„ÅÑÔºâ
      const spd = Number(S.run && S.run.speed) || 4;
      if (spd >= 12) pow *= 0.85;
      else if (spd >= 8) pow *= 0.92;
      return clamp(pow, 0.70, 2.15);
    }

    function pulse(el, cls, ms){
      if (!el) return;
      if (!fxEnabled()) return;
      el.classList.remove(cls);
      // restart animation
      void el.offsetWidth;
      el.classList.add(cls);
      window.setTimeout(() => el.classList.remove(cls), ms);
    }

    function floatDmg(side, text, kind){
      const layer = els.battleFx;
      if (!layer) return;
      if (!fxEnabled()) return;
      const t = Date.now();
      if (t - st.lastText < 60) return; // throttle
      st.lastText = t;

      const d = document.createElement('div');
      d.className = 'floatDmg' + (kind ? (' ' + kind) : '');
      d.textContent = text;
      if (!fxEnabled()){
        d.style.animation = "none";
        d.style.opacity = "1";
      }

      // place near actor (falls back to old fixed positions)
      try{
        const sr = els.battleStage ? els.battleStage.getBoundingClientRect() : null;
        const el = (side === 'hero') ? els.heroActor : els.enemyActor;
        const r = (sr && el) ? el.getBoundingClientRect() : null;
        if (sr && r && sr.width>0 && sr.height>0){
          const x0 = (r.left + r.width*0.55 - sr.left) / sr.width;
          const y0 = (r.top  + r.height*0.32 - sr.top)  / sr.height;
          d.style.left = (clamp(x0, 0.05, 0.95) * 100).toFixed(1) + '%';
          d.style.top  = (clamp(y0, 0.10, 0.92) * 100).toFixed(1) + '%';
        } else {
          d.style.left = (side === 'hero') ? '28%' : '72%';
          d.style.top  = (side === 'hero') ? '62%' : '52%';
        }
      } catch(_){
        d.style.left = (side === 'hero') ? '28%' : '72%';
        d.style.top  = (side === 'hero') ? '62%' : '52%';
      }

      layer.appendChild(d);
      window.setTimeout(() => d.remove(), 720);
    }
    function fxSprite(side, key, cls, ms, x, y, scale){
      const layer = els.battleFx;
      if (!layer) return;
      const t = Date.now();
      if (t - st.lastFx < 28) return;
      st.lastFx = t;
      const c = document.createElement('canvas');
      c.width = 16; c.height = 16;
      c.className = 'fxSprite ' + cls;

      // default position: near actor
      try{
        const sr = els.battleStage ? els.battleStage.getBoundingClientRect() : null;
        const el = (side === 'hero') ? els.heroActor : els.enemyActor;
        const r = (sr && el) ? el.getBoundingClientRect() : null;
        if (sr && r && sr.width>0 && sr.height>0){
          const x0 = (r.left + r.width*0.55 - sr.left) / sr.width;
          const y0 = (r.top  + r.height*0.55 - sr.top)  / sr.height;
          c.style.left = ((clamp(x0, 0.05, 0.95) * 100).toFixed(1) + '%');
          c.style.top  = ((clamp(y0, 0.05, 0.95) * 100).toFixed(1) + '%');
        } else {
          c.style.left = (side === 'hero') ? '30%' : '70%';
          c.style.top  = (side === 'hero') ? '56%' : '46%';
        }
      } catch(_){
        c.style.left = (side === 'hero') ? '30%' : '70%';
        c.style.top  = (side === 'hero') ? '56%' : '46%';
      }

      if (x != null) c.style.left = String(x);
      if (y != null) c.style.top  = String(y);

        if (scale != null){
        const base = 84;
        const sc = clamp(Number(scale) || 1, 0.65, 1.75);
        c.style.width = Math.round(base*sc) + 'px';
        c.style.height = Math.round(base*sc) + 'px';
      }

      SPR.draw(c, key);
      layer.appendChild(c);
      window.setTimeout(() => c.remove(), ms ?? 300);
    }


    function drawBase(){
      if (els.heroStageSprite) drawHeroKanji(els.heroStageSprite, S.hero);
      if (els.enemyStageSprite) drawEnemyKanji(els.enemyStageSprite, S.run && S.run.enemy);
    }

    function heroAttack(isCrit, dmg){
      const pow = fxPowFromDmg(dmg, !!isCrit);
      const fxOn = fxEnabled();
      const lite = isSpeedMax();
      if (fxOn) pulse(els.heroActor, 'atk', 240);
      if (lite){
        // MAX speed: keep only the minimal stage icon feedback.
        if (els.heroStageSprite){
          drawHeroKanji(els.heroStageSprite, S.hero, 'atk');
          window.setTimeout(drawBase, 240);
        }
        return;
      }
      // Big FX
      if (fxOn){
        try{
          const pH = BFX.posFromEl(els.heroActor, 0.62, 0.70);
          const pE = BFX.posFromEl(els.enemyActor, 0.58, 0.35);
          const hue = isCrit ? 45 : 190;
          BFX.hitStop(clamp(45 + 18*pow, 40, 110));
          BFX.punch(clamp(0.82*pow, 0.55, 1.95), +1);
          BFX.flash(hue);
          BFX.slash(pH.x + 18, pH.y - 18, pE.x - 22, pE.y - 26, clamp(0.95*pow, 0.70, 2.25), hue, (S.hero && S.hero.lv) ? S.hero.lv : 1);
          BFX.impact(pE.x - 4, pE.y - 10, clamp(0.98*pow, 0.70, 2.25), hue);
        } catch(_){ }
      }

      // Sprite FX (front layer)
      if (fxOn){
        const sc = 1 + (pow-1)*0.70;
        fxSprite('enemy', 'fx_slash', 'fxSlash', 300, null, null, sc);
        window.setTimeout(() => fxSprite('enemy', 'fx_spark', 'fxSpark', 240, null, null, sc*0.95), 60);
      }

      if (els.heroStageSprite){
        drawHeroKanji(els.heroStageSprite, S.hero, 'atk');
        window.setTimeout(drawBase, 240);
      }
      if (isCrit) floatDmg('enemy', 'Á†¥È≠î!!', 'crit');
    }

    function enemyAttack(dmg){
      const pow = fxPowFromDmg(dmg, false);
      const fxOn = fxEnabled();
      const lite = isSpeedMax();
      if (fxOn) pulse(els.enemyActor, 'atk', 240);
      if (lite){
        // MAX speed: skip heavy FX.
        return;
      }
      if (fxOn){
        try{
          const pE = BFX.posFromEl(els.enemyActor, 0.60, 0.30);
          const pH = BFX.posFromEl(els.heroActor, 0.60, 0.70);
          const hue = 10;
          BFX.hitStop(clamp(40 + 15*pow, 35, 95));
          BFX.punch(clamp(0.72*pow, 0.50, 1.60), -1);
          BFX.flash(hue);
          BFX.slash(pE.x - 24, pE.y - 26, pH.x + 18, pH.y - 10, clamp(0.90*pow, 0.65, 2.0), hue, (S.run && S.run.enemy && S.run.enemy.ilv) ? S.run.enemy.ilv : 1);
          BFX.impact(pH.x + 6, pH.y - 8, clamp(0.92*pow, 0.65, 2.0), hue);
        } catch(_){ }
      }

      if (fxOn){
        const sc = 1 + (pow-1)*0.65;
        fxSprite('hero', 'fx_claw', 'fxClaw', 300, null, null, sc);
        window.setTimeout(() => fxSprite('hero', 'fx_spark', 'fxSpark', 240, null, null, sc*0.95), 60);
      }
    }

    function enemyHit(dmg, isCrit){
      const pow = fxPowFromDmg(dmg, !!isCrit);
      const fxOn = fxEnabled();
      const lite = isSpeedMax();
      if (fxOn) pulse(els.enemyActor, 'hit', 260);
      if (lite){
        // MAX speed: skip heavy FX/text.
        return;
      }
      if (fxOn){
        try{
          const pE = BFX.posFromEl(els.enemyActor, 0.60, 0.35);
          const hue = isCrit ? 45 : 210;
          BFX.hitStop(clamp(38 + 17*pow, 35, 105));
          BFX.punch(clamp(0.75*pow, 0.50, 1.85), +1);
          BFX.flash(hue);
          BFX.impact(pE.x, pE.y - 10, clamp(1.02*pow, 0.70, 2.3), hue);
        } catch(_){ }
      }

      if (fxOn){
        const sc = 1 + (pow-1)*0.65;
        fxSprite('enemy', 'fx_spark', 'fxSpark', 240, null, null, sc);
        if (isCrit) fxSprite('enemy', 'fx_crit', 'fxCrit', 420, null, null, sc*1.05);
      }
      if (dmg > 0) floatDmg('enemy', '-' + Math.max(1, Math.round(dmg)), isCrit ? 'crit' : '');
    }

    function heroHit(dmg){
      const pow = fxPowFromDmg(dmg, false);
      const fxOn = fxEnabled();
      const lite = isSpeedMax();
      if (fxOn) pulse(els.heroActor, 'hit', 260);
      if (lite){
        // MAX speed: skip heavy FX/text.
        return;
      }
      if (fxOn){
        try{
          const pH = BFX.posFromEl(els.heroActor, 0.60, 0.70);
          const hue = 0;
          BFX.hitStop(clamp(38 + 16*pow, 35, 100));
          BFX.punch(clamp(0.70*pow, 0.50, 1.70), -1);
          BFX.flash(hue);
          BFX.impact(pH.x, pH.y - 8, clamp(0.95*pow, 0.65, 2.0), hue);
        } catch(_){ }
      }

      if (fxOn){
        const sc = 1 + (pow-1)*0.60;
        fxSprite('hero', 'fx_spark', 'fxSpark', 240, null, null, sc);
      }
      if (dmg > 0) floatDmg('hero', '-' + Math.max(1, Math.round(dmg)), '');
    }

    function sync(){
      const fxOn = fxEnabled();
      try{ if (typeof BFX !== 'undefined' && BFX && BFX.setEnabled) BFX.setEnabled(fxOn); }catch(_){ }
      try{ if (typeof BFX !== 'undefined' && BFX) BFX.resize(); }catch(_){ }
      if (els.battleStage){
        const running = !!(S.run && S.run.active && !(S.hero && S.hero.dead));
        els.battleStage.classList.toggle('running', running && fxOn);
        els.battleStage.classList.toggle('noAnim', !fxOn);
        if (!fxOn) els.battleStage.classList.remove('hitstop');
      }
      if (els.heroActor) els.heroActor.classList.toggle('dead', !!(S.hero && S.hero.dead));
      if (els.enemyActor) els.enemyActor.classList.toggle('dead', !!(S.run && S.run.enemyHp <= 0));
      drawBase();
    }
    function syncLite(){
      // Lightweight sync for MAX speed: no resize/particles, only state + stage icons.
      const fxOn = fxEnabled();
      if (els.battleStage){
        const running = !!(S.run && S.run.active && !(S.hero && S.hero.dead));
        els.battleStage.classList.toggle('running', running && fxOn);
        els.battleStage.classList.toggle('noAnim', !fxOn);
        if (!fxOn) els.battleStage.classList.remove('hitstop');
      }
      if (els.heroActor) els.heroActor.classList.toggle('dead', !!(S.hero && S.hero.dead));
      if (els.enemyActor) els.enemyActor.classList.toggle('dead', !!(S.run && S.run.enemyHp <= 0));
      try{
        if (els.heroStageSprite) drawHeroKanji(els.heroStageSprite, S.hero);
        if (els.enemyStageSprite) drawEnemyKanji(els.enemyStageSprite, S.run && S.run.enemy);
      }catch(_){ }
    }

    return { heroAttack, enemyAttack, enemyHit, heroHit, sync, syncLite };
  })();

  let dirtyHUD = true, dirtyInv = true, dirtyLog = true;
  let lastSimFrame = now();
  let lastRenderFrame = now();
  let lastInvSig = "";
  let lastQuery = "";
  let lastSort = "";

  function renderRunLocMini(){
    try{
      const h = S.hero;
      const r = S.run;
      if (!r) return;
      const loc = "F" + r.floor + " R" + r.room + "/" + r.roomsPerFloor;
      const spv = (Number.isFinite(r.speed) ? r.speed : 1);
      const sp = "√ó" + (spv >= SPEED_MAX_LABEL ? "MAX" : spv);
      if (els.runInfo) els.runInfo.textContent = (r.active ? "Â∑°Á§º‰∏≠" : (h && h.dead ? "Ë™ø‰ºè‰∏çËÉΩ" : "ÂæÖÊ©ü")) + " ‚Ä¢ " + loc + " " + sp;
      if (els.biomeText) els.biomeText.textContent = biomeForFloor(r.floor).name;
      try{ document.documentElement.dataset.realm = biomeForFloor(r.floor).key || ''; }catch(_){ }
    } catch(_){ }
  }

  function renderHUD(){
    try{ ensureMikkyoFields(); }catch(_){ }
    const st = calcStats();
    const h = S.hero;
    const r = S.run;

    els.speedSel.value = String(r.speed ?? 1);
    syncSpeedSelUnlock();
    els.autoSel.value = r.auto ? "1" : "0";
    if (els.fxSel){ els.fxSel.value = (S.ui && Number(S.ui.fx) === 0) ? "0" : "1"; }

    if (els.upgBulkSel){ els.upgBulkSel.value = String((S.ui && S.ui.upgBulk) || 1); }
    if (els.gupgBulkSel){ els.gupgBulkSel.value = String((S.ui && S.ui.gupgBulk) || 1); }

    // Auto-sell UI
    if (els.autoSellOn){ els.autoSellOn.checked = !!(S.ui && Number(S.ui.autoSellOn) === 1); }
    if (els.autoSellRarMax){ els.autoSellRarMax.value = (S.ui && S.ui.autoSellRarMax) ? String(S.ui.autoSellRarMax) : "common"; }
    if (els.autoSellUseEq){ els.autoSellUseEq.checked = !!(S.ui && Number(S.ui.autoSellUseEq) === 1); }
    if (els.autoSellEqPct){ els.autoSellEqPct.value = String((S.ui && S.ui.autoSellEqPct) ? S.ui.autoSellEqPct : 90); }
    if (els.autoSellProtectUnique){ els.autoSellProtectUnique.checked = !(S.ui && Number(S.ui.autoSellProtectUnique) === 0); }

    // disable states
    try{
      const _on = els.autoSellOn && els.autoSellOn.checked;
      if (els.autoSellRarMax) els.autoSellRarMax.disabled = !_on;
      if (els.autoSellUseEq) els.autoSellUseEq.disabled = !_on;
      if (els.autoSellEqPct) els.autoSellEqPct.disabled = (!_on) || !(els.autoSellUseEq && els.autoSellUseEq.checked);
      if (els.autoSellProtectUnique) els.autoSellProtectUnique.disabled = !_on;
    }catch(_){ }

    const loc = "F" + r.floor + " R" + r.room + "/" + r.roomsPerFloor;
    const spv = (Number.isFinite(r.speed) ? r.speed : 1);
    const sp = "√ó" + (spv >= SPEED_MAX_LABEL ? "MAX" : spv);
    els.runInfo.textContent = (r.active ? "Â∑°Á§º‰∏≠" : (h.dead ? "Ë™ø‰ºè‰∏çËÉΩ" : "ÂæÖÊ©ü")) + " ‚Ä¢ " + loc + " " + sp;
    if (els.locText) els.locText.textContent = loc + " " + sp;
    try{ document.documentElement.dataset.realm = biomeForFloor(r.floor).key || ''; }catch(_){ }
    els.btnExplore.textContent = r.active ? "‚ñ∂ Â∑°Á§º‰∏≠" : "‚ñ∂ Â∑°Á§ºÈñãÂßã";
    els.deathNote.style.display = h.dead ? "" : "none";
    if (els.deathOverlay) els.deathOverlay.style.display = h.dead ? "flex" : "none";

    const need = expNeed(h.lv);
    els.lvExp.textContent = `‰Ωç ${fmt(h.lv)}`;
    const needDisp = Number.isFinite(need) ? fmt(need) : "‚àû";
    els.expText.textContent = `Ë°å ${fmt(h.exp)}/${needDisp}`;
    els.goldText.textContent = "ÂäüÂæ≥ " + fmt(h.gold);
    if (els.karmaText) els.karmaText.textContent = "Ê•≠ " + ((h.karma>=0)?("+"+fmt(h.karma)):fmt(h.karma)) + karmaPullTag(h.karma);
    if (els.satoriText) els.satoriText.textContent = "Ëè©Êèê " + fmt(h.satori);
    els.expBar.style.width = Number.isFinite(need) ? `${clamp(h.exp/need, 0, 1)*100}%` : "0%";

    if (els.heroName) els.heroName.textContent = (h.name && String(h.name).trim()) ? String(h.name).trim() : 'Ë°åËÄÖ';

    els.hpText.textContent = `${fmt(h.hp)}/${fmt(h.hpMax)}`;
    els.hpBar.style.width = `${clamp(safeDiv(h.hp, h.hpMax, 0),0,1)*100}%`;


    const dps = st.atk * st.spd * (1 + st.crit*0.6) * st.dmgFactor;
    els.dpsText.textContent = `Ë™ø‰ºè/Áßí ${fmt(dps)}`;
    els.luckText.textContent = "Á∏Å√ó" + st.luckFactor.toFixed(2) + " ÂäüÂæ≥√ó" + st.goldMult.toFixed(2) + " Ë°å√ó" + st.xpMult.toFixed(2) + (st.mantraOn?" / ÁúüË®Ä:È°ïÁèæ":"");

    if (els.atkVal) els.atkVal.textContent = fmt(st.atk);
    if (els.defVal) els.defVal.textContent = fmt(st.def);
    const _critCap = 0.65, _spdCap = 2.75, _drCap = 0.60, _eps = 1e-9;
    const critDisp = (st.crit >= _critCap - _eps) ? "MAX" : pct(st.crit);
    const spdDisp  = (st.spd  >= _spdCap  - _eps) ? "MAX" : st.spd.toFixed(2);
    const drDisp   = (st.dr   >= _drCap   - _eps) ? "MAX" : pct(st.dr);
    if (els.critText) els.critText.textContent = `ÊÖßÁúº ${critDisp}`;
    if (els.spdText)  els.spdText.textContent  = `ËøÖË°å ${spdDisp}√ó / Ëã¶Ê∏õ ${drDisp}`;



// Ë≠∑Êë©ÔºàÊµÑÂåñÔºâ/ ÁúüË®Ä UI
try{
  if (els.purifyText) els.purifyText.textContent = purifyPreview();
  // Chant button state
  if (els.btnChant){
    const t = now();
    const cd = (S.run && S.run.mantraCdUntil) ? S.run.mantraCdUntil : 0;
    const ready = t >= cd;
    els.btnChant.classList.toggle('ready', ready);
    els.btnChant.classList.toggle('cooldown', !ready);
    if (!ready){
      const left = Math.max(0, cd - t);
      const leftS = left / 1000;
      els.btnChant.textContent = `üïâ ÁúüË®Ä (${leftS.toFixed(0)}s)`;
    } else {
      els.btnChant.textContent = 'üïâ ÁúüË®Ä';
    }
  }
}catch(_){ }

const g = S.gear;
    const locks = (h.lock || {});
    if (els.lockWeapon){ const on=!!locks.weapon; els.lockWeapon.textContent = on ? 'üîí' : 'üîì'; els.lockWeapon.classList.toggle('locked', on); els.lockWeapon.title = on ? 'Ëá™ÂãïÂä†ÊåÅ: Ê≠¢ÔºàÂ∞ÅÂç∞‰∏≠Ôºâ' : 'Ëá™ÂãïÂä†ÊåÅ: È°ï'; }
    if (els.lockArmor){ const on=!!locks.armor; els.lockArmor.textContent = on ? 'üîí' : 'üîì'; els.lockArmor.classList.toggle('locked', on); els.lockArmor.title = on ? 'Ëá™ÂãïÂä†ÊåÅ: Ê≠¢ÔºàÂ∞ÅÂç∞‰∏≠Ôºâ' : 'Ëá™ÂãïÂä†ÊåÅ: È°ï'; }
    if (els.lockAcc){ const on=!!locks.accessory; els.lockAcc.textContent = on ? 'üîí' : 'üîì'; els.lockAcc.classList.toggle('locked', on); els.lockAcc.title = on ? 'Ëá™ÂãïÂä†ÊåÅ: Ê≠¢ÔºàÂ∞ÅÂç∞‰∏≠Ôºâ' : 'Ëá™ÂãïÂä†ÊåÅ: È°ï'; }

    if (g.weapon){
      if (els.eqWeapon) els.eqWeapon.textContent = dispItemName(g.weapon);
      if (els.eqWeaponRar){ els.eqWeaponRar.className = `rar ${g.weapon.rarity}`; els.eqWeaponRar.textContent = rarLabel(g.weapon.rarity); }
      if (els.eqWeapon‰Ωç) els.eqWeapon‰Ωç.textContent = `‰Ωç ${fmt(g.weapon.ilv)}`;
      if (els.eqWeaponPerf){ els.eqWeaponPerf.textContent = equipSummary(g.weapon); els.eqWeaponPerf.title = equipPerfTitle(g.weapon); }
    } else {
      if (els.eqWeapon) els.eqWeapon.textContent = "‚Äî";
      if (els.eqWeaponRar){ els.eqWeaponRar.className = "rar common"; els.eqWeaponRar.textContent = "‚Äî"; }
      if (els.eqWeapon‰Ωç) els.eqWeapon‰Ωç.textContent = "‚Äî";
      if (els.eqWeaponPerf){ els.eqWeaponPerf.textContent = '‚Äî'; els.eqWeaponPerf.title = ''; }
    }

    if (g.armor){
      if (els.eqArmor) els.eqArmor.textContent = dispItemName(g.armor);
      if (els.eqArmorRar){ els.eqArmorRar.className = `rar ${g.armor.rarity}`; els.eqArmorRar.textContent = rarLabel(g.armor.rarity); }
      if (els.eqArmor‰Ωç) els.eqArmor‰Ωç.textContent = `‰Ωç ${fmt(g.armor.ilv)}`;
      if (els.eqArmorPerf){ els.eqArmorPerf.textContent = equipSummary(g.armor); els.eqArmorPerf.title = equipPerfTitle(g.armor); }
    } else {
      if (els.eqArmor) els.eqArmor.textContent = "‚Äî";
      if (els.eqArmorRar){ els.eqArmorRar.className = "rar common"; els.eqArmorRar.textContent = "‚Äî"; }
      if (els.eqArmor‰Ωç) els.eqArmor‰Ωç.textContent = "‚Äî";
      if (els.eqArmorPerf){ els.eqArmorPerf.textContent = '‚Äî'; els.eqArmorPerf.title = ''; }
    }

    if (g.accessory){
      if (els.eqAcc) els.eqAcc.textContent = dispItemName(g.accessory);
      if (els.eqAccRar){ els.eqAccRar.className = `rar ${g.accessory.rarity}`; els.eqAccRar.textContent = rarLabel(g.accessory.rarity); }
      if (els.eqAcc‰Ωç) els.eqAcc‰Ωç.textContent = `‰Ωç ${fmt(g.accessory.ilv)}`;
      if (els.eqAccPerf){ els.eqAccPerf.textContent = equipSummary(g.accessory); els.eqAccPerf.title = equipPerfTitle(g.accessory); }
    } else {
      if (els.eqAcc) els.eqAcc.textContent = "‚Äî";
      if (els.eqAccRar){ els.eqAccRar.className = "rar common"; els.eqAccRar.textContent = "‚Äî"; }
      if (els.eqAcc‰Ωç) els.eqAcc‰Ωç.textContent = "‚Äî";
      if (els.eqAccPerf){ els.eqAccPerf.textContent = '‚Äî'; els.eqAccPerf.title = ''; }
    }

    const e = r.enemy;
    els.biomeText.textContent = biomeForFloor(r.floor).name;
    if (els.floorText) els.floorText.textContent = r.floor;
    if (els.roomText) els.roomText.textContent = `${r.room}/${r.roomsPerFloor}`;
    if (els.safeTag && els.safeText){
      const sec = (r.entryShield || 0);
      els.safeTag.style.display = sec > 0 ? "" : "none";
      els.safeText.textContent = sec > 0 ? `${sec.toFixed(1)}s` : "‚Äî";
    }

    els.eliteTag.style.display = e && e.isElite ? "" : "none";
    els.bossTag.style.display = e && e.isBoss ? "" : "none";

    if (e){
      els.enemyName.textContent = dispEnemyName(e.name);
      els.enemyHpBar.style.width = `${clamp(safeDiv(r.enemyHp, r.enemyHpMax, 0), 0, 1) * 100}%`;

      els.enemyHpText.textContent = `${fmt(r.enemyHp)}/${fmt(r.enemyHpMax)}`;
      const modHtml = (r.mods && r.mods.length) ? ` <span class="warn">[${modsHtml(r.mods)}]</span>` : "";
      els.enemyStatsText.innerHTML = `ÈôçÈ≠î ${fmt(e.atk)} / ÊåÅÊàí ${fmt(e.def)} / Êà¶Âà©ÂìÅ‰Ωç ${fmt(e.ilv)}${modHtml}`;
      // Tooltip: include per-affix explanation
      els.enemyStatsText.title = `ÈôçÈ≠î ${fmt(e.atk)} / ÊåÅÊàí ${fmt(e.def)} / Êà¶Âà©ÂìÅ‰Ωç ${fmt(e.ilv)}` + (r.mods && r.mods.length ? `\n${modsTitle(r.mods)}` : "");
    } else {
      els.enemyName.textContent = "‚Äî";
      els.enemyHpBar.style.width = "0%";
      els.enemyHpText.textContent = "‚Äî";
      els.enemyStatsText.textContent = "‚Äî";
      els.enemyStatsText.title = "";
    }

    const u = h.base;
    els.upgText.textContent = `Á≤æÈÄ≤ ${u.str} / ÂøçËæ± ${u.vit} / ÊåÅÊàí ${u.def} / Á∏Å ${u.luck}`;
    els.upgCostText.textContent = `Ê¨°„ÅÆ‰ª£‰æ°: ${fmt(upgradeCost())}ÂäüÂæ≥Ôºà√ó${(S.ui&&S.ui.upgBulk)||1}Ôºâ`;

        if (els.gupgText && els.gupgCostText){
const gg = h.guild;
    const capForge = guildCap("forge"), capBounty = guildCap("bounty"), capLib = guildCap("library"), capShr = guildCap("shrine");
    const nextForge  = (gg.forge  >= capForge) ? "MAX" : `${fmt(guildCost("forge"))}Âæ≥`;
    const nextBounty = (gg.bounty >= capBounty)? "MAX" : `${fmt(guildCost("bounty"))}Âæ≥`;
    const nextLib    = (gg.library>= capLib)   ? "MAX" : `${fmt(guildCost("library"))}Âæ≥`;
    const nextShr    = (gg.shrine >= capShr)   ? "MAX" : `${fmt(guildCost("shrine"))}Âæ≥`;

    els.gupgText.textContent = `ÈçõÂÜ∂ ${gg.forge}/${capForge} / Ë≥ûÈáë ${gg.bounty}/${capBounty} / Âõ≥Êõ∏ ${gg.library}/${capLib} / Á•à„Çä ${gg.shrine}/${capShr}`;
    els.gupgCostText.textContent = `Ê¨°: ÈçõÂÜ∂ ${nextForge} | Ë≥ûÈáë ${nextBounty} | Âõ≥Êõ∏ ${nextLib} | Á•à„Çä ${nextShr}`;

    // ‰∏äÈôê„Å´ÈÅî„Åó„ÅüË®≠ÂÇô„ÅØÊäº„Åõ„Å™„ÅÑ„Çà„ÅÜ„Å´„Åô„Çã
    document.querySelectorAll("button[data-gupg]").forEach(btn=>{
      const which = btn.getAttribute("data-gupg");
      const cap = guildCap(which);
      const cur = Math.max(0, Math.floor(num(S.hero.guild[which], 0)));
      const atCap = cur >= cap;
      btn.disabled = atCap;
      btn.classList.toggle("disabled", atCap);
    });    }

try{
      if (typeof syncBulkLabels === "function") syncBulkLabels(false);
    }catch(_){ }


    if (r.offlineChest){
      els.offlineNote.textContent = `Êú™Êé•Á∂öÂÆùÂáΩ: ${r.offlineChest.count}ÂÄãÔºàilv ${r.offlineChest.ilv}Ôºâ`;
      els.btnOpenChest.style.display = "";
    } else {
      els.offlineNote.textContent = `Ë®òÈå≤: Ëá™ÂãïÔºà10Áßí„Åî„Å®Ôºâ+ ÊâãÂãï | ÁïåÁõ∏: 20ÈöéÂ±§„Åî„Å®„Å´ÂàáÊõø`;
      els.btnOpenChest.style.display = "none";
    }

    els.btnRevive.style.display = h.dead ? "" : "none";

    if (!isSpeedMax()){
      updateHUDSprites();
      try{ BATTLE.sync(); }catch(_){ }
    }
  }

  function inventorySignature(){
    // At MAX sim speed, inventory changes can be extremely frequent; avoid heavy signatures.
    if (isSpeedMax()) return String(S.inv.length);
    const ids = S.inv.slice(0, 12).map(x=>x.id).join("|");
    const tail = S.inv.slice(-6).map(x=>x.id).join("|");
    return `${S.inv.length}:${ids}:${tail}`;
  }

  
  function compareRow(it){
    try{
      const d = compareDeltaForItem(it);
      const s = summarizeDelta(d, it.slot);
      const good = d.dpsPct >= 0;
      const cls = good ? "goodTxt" : "badTxt";
      return `<span class="${cls}">Âä†ÊåÅ‰∏≠„Çà„Çä</span>: <span class="${cls}">${escapeHtml(s)}</span>`;
    } catch(e){
      return `<span class="mutedTxt">ÊØîËºÉÊÉÖÂ†±„ÇíË®àÁÆó„Åß„Åç„Åæ„Åõ„Çì</span>`;
    }
  }

function renderInventory(){
    els.invCount.textContent = `${S.inv.length} ÂÄã`;
    const tab = (S.ui && S.ui.tab) ? S.ui.tab : "all";
    if (els.tabs){
      els.tabs.querySelectorAll(".tabBtn").forEach(btn => btn.classList.toggle("active", (btn.dataset.tab||"all") === tab));
    }

    const q = (els.search.value || "").trim().toLowerCase();
    const sortKey = els.sortSel.value;

    let items = S.inv.slice();
    if (tab !== "all") items = items.filter(it => it.slot === tab);
    if (q){
      items = items.filter(it => {
        const blob = `${dispItemName(it)} ${it.slot} ${it.rarity} ${statLines(it.stats)} ${dispDesc(it.desc||"")}`.toLowerCase();
        return blob.includes(q);
      });
    }

    if (sortKey === "ilv"){
      items.sort((a,b)=> (b.ilv - a.ilv) || (itemPower(b)-itemPower(a)));
    } else if (sortKey === "rar"){
      items.sort((a,b)=> (rarScore(b.rarity)-rarScore(a.rarity)) || (b.ilv-a.ilv));
    } else if (sortKey === "slot"){
      const sidx = (s)=> SLOT_ORDER.indexOf(s);
      items.sort((a,b)=> (sidx(a.slot)-sidx(b.slot)) || (b.ilv-a.ilv));
    } else if (sortKey === "power"){
      items.sort((a,b)=> itemPower(b)-itemPower(a));
    }

    const SHOW_LIMIT = 220;
    const overflow = Math.max(0, items.length - SHOW_LIMIT);
    const show = overflow ? items.slice(0, SHOW_LIMIT) : items;

    els.invList.innerHTML = show.map(it => {
      const rname = rarLabel(it.rarity);
      const spr = SPR.itemKey(it);
      const glyph = SPR.itemGlyph(it);
      const stats = statLinesWithCaps(it) || statLines(it.stats);
      const statPills = statPillsHTML(it.stats, it);
      const descHtml = it.desc ? `<div class=\"idesc\">${escapeHtml(it.desc)}</div>` : ``;
      const pill = `${SLOT_NAME[it.slot]} / Âä†ÊåÅ‰Ωç ${fmt(it.ilv)}`;
      return `
        <div class="item rar-${it.rarity} ${((S.ui&&S.ui.preview)===it.id) ? "selected" : ""}" data-item="${it.id}">
          <div class="left">
            <canvas class="pxSprite pxMini itemIcon rar-${it.rarity}" width="64" height="64" data-spr="${spr}" data-glyph="${glyph}" aria-hidden="true"></canvas>
            <div class="itText">
              <div class="iname">
              <span class="rar ${it.rarity}">${rname}</span>
              <span class="inameName">${escapeHtml(dispItemName(it))}</span>
              <span class="pill">${pill}</span>
              <span class="pill">Âº∑„Åï ${fmt(itemPower(it))}</span>
            </div>
            <div class="istat">${statPills || `<span class="sp">‚Äî</span>`}</div>
            ${descHtml}
            <div class="cmpBox">${compareRow(it)}</div>
            </div>
          </div>
          <div class="actions">
            <button class="small accent" data-eq="${it.id}">Âä†ÊåÅ</button>
            <button class="small" data-sell="${it.id}">Â∏ÉÊñΩ</button>
          </div>
        </div>
      `;
    }).join("");
    renderSpriteCanvases(els.invList);
  }

  
  function stripTags(s){
    return String(s||"").replace(/<[^>]*>/g, " ");
  }

  function toneLogMsg(msg){
    // Apply a slightly more polite / ritual-like tone without changing the meaning.
    // Works on stored logs too (render-time), so old saves also benefit.
    let s = String(msg ?? "");

    // --- label words inside spans ---
    s = s.replace(/>‰∏çË∂≥</g, ">‰∏çË∂≥„Åó„Å¶„Åä„Çä„Åæ„Åô<");
    s = s.replace(/>‰∏äÈôê</g, ">‰∏äÈôê„Åß„Åô<");
    s = s.replace(/>Êàª„Çå„Åæ„Åõ„Çì</g, ">Êàª„Çã„Åì„Å®„ÅØ„Åß„Åç„Åæ„Åõ„Çì<");
    s = s.replace(/>Ë™ø‰ºè„Å´Ëá≥„Çâ„Åö</g, ">Ë™ø‰ºè„Å´Ëá≥„Çä„Åæ„Åõ„Çì„Åß„Åó„Åü<");

    // --- common phrasing ---
    s = s.replace(/„Å´Âà∞ÈÅî„ÄÇ/g, "„Å´Âà∞ÈÅî„Åó„Åæ„Åó„Åü„ÄÇ");
    s = s.replace(/Êàª„Çå„Åæ„Åõ„Çì/g, "Êàª„Çã„Åì„Å®„ÅØ„Åß„Åç„Åæ„Åõ„Çì");
    s = s.replace(/ÊâãÂãïË®òÈå≤„Åó„Åæ„Åó„Åü„ÄÇ/g, "Ë®òÈå≤„ÇíÊÆã„Åó„Åæ„Åó„Åü„ÄÇ");
    s = s.replace(/Ë™ø‰ºè„Å´Ëá≥„Çâ„Åö/g, "Ë™ø‰ºè„Å´Ëá≥„Çä„Åæ„Åõ„Çì„Åß„Åó„Åü");
    s = s.replace(/Ê≤°Âèé/g, "Ê≤°Âèé„Åï„Çå„Åæ„Åó„Åü");

    // "ÂøÖË¶Å" ‚Üí "ÂøÖË¶Å„Åß„Åô" (avoid double)
    s = s.replace(/ÂøÖË¶Å(?!„Åß„Åô)/g, "ÂøÖË¶Å„Åß„Åô");

    // Verb endings for short phrases commonly used at the end of lines
    s = s.replace(/„ÇíÊõ¥Êñ∞(?!„Åó„Åæ„Åó„Åü)/g, "„ÇíÊõ¥Êñ∞„Åó„Åæ„Åó„Åü");
    s = s.replace(/„ÇíÁÑ°ÂäπÂåñ(?!„Åó„Åæ„Åó„Åü)/g, "„ÇíÁÑ°ÂäπÂåñ„Åó„Åæ„Åó„Åü");
    s = s.replace(/„ÇíÂ∏ÉÊñΩ(?!„Åó„Åæ„Åó„Åü)/g, "„ÇíÂ∏ÉÊñΩ„Åó„Åæ„Åó„Åü");

    // A touch of atmosphere for plain movement logs
    s = s.replace(/^Ê≠©„ÇíÈÄ≤„ÇÅ„Åæ„Åó„Åü„ÄÇ$/g, "Èùô„Åã„Å´Ê≠©„ÇíÈÄ≤„ÇÅ„Åæ„Åó„Åü„ÄÇ");
    s = s.replace(/^Ê≠©„ÇíÈÄ≤„ÇÅ„Åæ„Åó„Åü$/g, "Èùô„Åã„Å´Ê≠©„ÇíÈÄ≤„ÇÅ„Åæ„Åó„Åü");
    return s;
  }

function dqifyLogMsg(msg){
  let s = String(msg ?? "");

  // Avoid double-processing: already formatted (multi-line) battle logs.
  if (s.includes("„ÅÆÊîªÊíÉÔºÅ") || (s.includes("HP:") && s.includes("<br>"))) return s;

  // Enemy appears
  s = s.replace(/^ÁèæÂâç:\s*(<span[^>]*>[^<]*<\/span>)(.*)$/s, (m, nameSpan, tail)=>{
    const t = (tail||"").trim();
    return `${nameSpan}„Åå „ÅÇ„Çâ„Çè„Çå„ÅüÔºÅ` + (t ? `<br><span class="mutedTxt">${t}</span>` : "");
  });

  // Floor reach
  s = s.replace(/^<span class="good">Â±§\s*([^<]+)<\/span>\s*„Å´Âà∞ÈÅî(?:„Åó„Åæ„Åó„Åü)?„ÄÇÂÖ≠ÈÅì:\s*(.+)$/s, (m, floor, biome)=>{
    return `<span class="good">Â±§ ${floor}</span>„Å∏ ÈÄ≤„Çì„Å†ÔºÅ<br><span class="mutedTxt">ÂÖ≠ÈÅì: ${biome}</span>`;
  });

  // Chest open
  s = s.replace(/^ÂÆùÂáΩ:\s*(.+)$/s, (m, rest)=>{
    const r = (rest||"").trim();
    return `ÂÆùÁÆ±„ÇíÈñã„Åë„ÅüÔºÅ` + (r ? `<br>„ÄÄ${r}„ÇíÊâã„Å´ÂÖ•„Çå„ÅüÔºÅ` : "");
  });

  // Equip (HP upgrade)
  s = s.replace(/^Âä†ÊåÅ:\s*\+([0-9,]+)ÂëΩ\s*(.*)$/s, (m, amt, tail)=>{
    const t = (tail||"").trim();
    return `Ë°åËÄÖ„ÅÆÂëΩ„Åå <span class="good">+${amt}</span> ‰∏ä„Åå„Å£„ÅüÔºÅ` + (t ? `<br><span class="mutedTxt">${t}</span>` : "");
  });

  // Equip (item)
  s = s.replace(/^Âä†ÊåÅ:\s*(.+)$/s, (m, rest)=>{
    const r = (rest||"").trim();
    if (!r) return m;
    // If it already looks like a DQ sentence, keep it.
    if (/„ÇíÂä†ÊåÅ„Åó„ÅüÔºÅ$/.test(stripTags(r))) return m;
    return `Ë°åËÄÖ„ÅØ ${r}„ÇíÂä†ÊåÅ„Åó„ÅüÔºÅ`;
  });

  // Sell (single)
  s = s.replace(/^Â∏ÉÊñΩ:\s*(.+?)\s*<span class="gold">\(\+([^<]+)ÂäüÂæ≥\)<\/span>\s*$/s, (m, item, g)=>{
    return `Ë°åËÄÖ„ÅØ ${item}„ÇíÂ∏ÉÊñΩ„Åó„ÅüÔºÅ<br><span class="gold">ÂäüÂæ≥„Åå+${g}Â¢ó„Åà„ÅüÔºÅ</span>`;
  });

  // Sell (bulk)
  s = s.replace(/^‰∏ÄÊã¨Â∏ÉÊñΩ:\s*([0-9,]+)ÂÄã\s*<span class="gold">\(\+([^<]+)ÂäüÂæ≥\)<\/span>\s*$/s, (m, n, g)=>{
    return `Ë°åËÄÖ„ÅØ ‰∏çË¶Å„Å™Ê≥ïÂÖ∑„Çí„Åæ„Å®„ÇÅ„Å¶Â∏ÉÊñΩ„Åó„ÅüÔºÅ <span class="mutedTxt">(${n}ÂÄã)</span><br><span class="gold">ÂäüÂæ≥„Åå+${g}Â¢ó„Åà„ÅüÔºÅ</span>`;
  });

  // Auto-sell from chest / inventory
  s = s.replace(/^<span class="warn">Ëá™ÂãïÂ∏ÉÊñΩ(?:\(ÂÆùÂáΩ\))?<\/span>:\s*([0-9,]+)ÂÄã\s*<span class="gold">\(\+([^<]+)ÂäüÂæ≥\)<\/span>\s*$/s, (m, n, g)=>{
    return `<span class="warn">Ëá™ÂãïÊï¥ÁêÜ</span>: Ë°åËÄÖ„ÅØÊ≥ïÂÖ∑Â∫´„ÇíÊï¥„Åà„Åü„ÄÇ <span class="mutedTxt">(${n}ÂÄã„ÇíÂ∏ÉÊñΩ)</span><br><span class="gold">ÂäüÂæ≥„Åå+${g}Â¢ó„Åà„ÅüÔºÅ</span>`;
  });
  s = s.replace(/^<span class="warn">Ëá™ÂãïÊï¥ÁêÜ<\/span>:\s*(.+?)„ÇíÂ∏ÉÊñΩ\s*<span class="gold">\(\+([^<]+)ÂäüÂæ≥\)<\/span>\s*$/s, (m, tail, g)=>{
    return `<span class="warn">Ëá™ÂãïÊï¥ÁêÜ</span>: Ë°åËÄÖ„ÅØÊ≥ïÂÖ∑Â∫´„ÇíÊï¥„Åà„Åü„ÄÇ<br><span class="mutedTxt">${tail}„ÇíÂ∏ÉÊñΩ</span> / <span class="gold">ÂäüÂæ≥+${g}</span>`;
  });

  // Level up
  s = s.replace(/^<span class="good">Êòá‰ΩçÔºÅ<\/span>\s*‰Ωç\s*([0-9,]+)\s*$/s, (m, lv)=>{
    return `Ë°åËÄÖ„ÅÆ‰Ωç„Åå‰∏ä„Åå„Å£„ÅüÔºÅ<br><span class="good">‰Ωç ${lv}</span>`;
  });

  // Enemy defeated (DQ-style)
  s = s.replace(/^<span class="good">ÊíÉÁ†¥<\/span>:\s*([^Ôºà]+)Ôºà([^)]*)\)\s*<span class="gold">\(\+([^<]+)ÂäüÂæ≥\)<\/span>\s*\(\+([^)]+)ÁµåÈ®ì\)\s*$/s, (m, enemy, last, g, xp)=>{
    let lastTxt = stripTags(String(last||"")).trim();
    const hasHama = lastTxt.includes("Á†¥È≠î");
    lastTxt = lastTxt.replace(/^ÊúÄÂæå„ÅÆÈôçÈ≠î:\s*/,"„Å®„Å©„ÇÅ„ÅÆ‰∏ÄÊíÉ: ");
    lastTxt = lastTxt.replace(/\s*Ëã¶\s*$/," „ÉÄ„É°„Éº„Ç∏");
    const lastLines = lastTxt ? (hasHama ? `‰ºöÂøÉ„ÅÆ‰∏ÄÊíÉÔºÅ<br><span class="mutedTxt">${lastTxt}</span>` : `<span class="mutedTxt">${lastTxt}</span>`) : "";
    return `Ë°åËÄÖ„ÅÆÊîªÊíÉÔºÅ<br><span class="good">${enemy}</span>„Çí „Åü„Åä„Åó„ÅüÔºÅ`
      + (lastLines ? `<br>${lastLines}` : ``)
      + `<br><span class="gold">ÂäüÂæ≥„Çí +${g} „Å¶„Å´„ÅÑ„Çå„ÅüÔºÅ</span>`
      + `<br><span class="good">ÁµåÈ®ì„Çí +${xp} „Åã„Åè„Å®„ÅèÔºÅ</span>`;
  });

  // Barrier (entry shield)
  s = s.replace(/^<span class="good">ÁµêÁïå<\/span>:\s*Ê¨°„ÅÆÂÖ•ÂÆ§Áõæ„ÇíÂº∑Âåñ\s*<span class="gold">\(-([^<]+)ÂäüÂæ≥\)<\/span>\s*$/s, (m, g)=>{
    return `Ë°åËÄÖ„ÅØ ÁµêÁïå„ÇíÂºµ„Å£„ÅüÔºÅ<br>Ê¨°„ÅÆÂÖ•ÂÆ§Áõæ„Åå Âéö„Åè„Å™„Å£„ÅüÔºÅ<br><span class="gold">ÂäüÂæ≥ -${g}</span>`;
  });

  // Ritual (auto)
  s = s.replace(/^<span class="good">ÂÑÄÁ§º<\/span>:\s*(.+?)ÔºàËá™ÂãïÂá¶ÁêÜÔºâ\s*$/s, (m, title)=>{
    const t = stripTags(String(title||"")).trim();
    const nice = t.replace(/^ÁµêÁïå\s*[‚Äî\-‚Äì]\s*/,"");
    return `Ë°åËÄÖ„ÅØ ÂÑÄÁ§º„Çí„Åä„Åì„Å™„Å£„ÅüÔºÅ <span class="mutedTxt">ÔºàËá™ÂãïÔºâ</span><br><span class="mutedTxt">${nice || t}</span>`;
  });

  // Pride recoil
  s = s.replace(/^<span class="warn">ÊÖ¢<\/span>:\s*ËøîÊ•≠\s*([0-9.,]+(?:[KMBT])?)\s*Ëã¶\s*$/s, (m, amt)=>{
    return `ÊÖ¢„ÅÆËøîÊ•≠ÔºÅ<br>Ë°åËÄÖ„ÅØ <span class="warn">${amt}</span>„ÅÆ„ÉÄ„É°„Éº„Ç∏„Çí „ÅÜ„Åë„ÅüÔºÅ <span class="mutedTxt">(Ëã¶)</span>`;
  });

  // Death
  s = s.replace(/^<span class="bad">Ë™ø‰ºè„Å´Ëá≥„Çâ„Åö<\/span>‚Ä¶ÔºàÊ≠ªÂõ†:\s*(.+)\)\s*$/s, (m, detail)=>{
    return `<span class="bad">Ë°åËÄÖ„ÅØ „Å°„Åã„Çâ„Å§„Åç„Åü‚Ä¶</span><br><span class="mutedTxt">Ê≠ªÂõ†: ${detail}</span>`;
  });

  // Reborn
  s = s.replace(/^<span class="good">Âæ©Ê¥ª<\/span>:\s*<span class="gold">-([^<]+)ÂäüÂæ≥<\/span>\s*$/s, (m, g)=>{
    return `<span class="good">Ë°åËÄÖ„ÅØÂæ©Ê¥ª„Åó„ÅüÔºÅ</span><br><span class="gold">ÂäüÂæ≥ -${g}</span>`;
  });

  // Upgrades / training (light touch)
  s = s.replace(/^<span class="good">Êã†ÁÇπÂº∑Âåñ<\/span>:\s*(.+)$/s, (m, tail)=>{
    return `Êã†ÁÇπ„ÅåÂº∑Âåñ„Åï„Çå„ÅüÔºÅ<br><span class="mutedTxt">${tail}</span>`;
  });
  s = s.replace(/^<span class="rare">Ë®≠ÂÇôÂº∑Âåñ<\/span>:\s*(.+)$/s, (m, tail)=>{
    return `Ë®≠ÂÇô„ÅåÂº∑Âåñ„Åï„Çå„ÅüÔºÅ<br><span class="mutedTxt">${tail}</span>`;
  });
  s = s.replace(/^<span class="good">‰øÆË°å<\/span>:\s*(.+)$/s, (m, tail)=>{
    return `Ë°åËÄÖ„ÅØ‰øÆË°å„ÇíÁ©ç„Çì„Å†ÔºÅ<br><span class="mutedTxt">${tail}</span>`;
  });

  // Seals
  s = s.replace(/^<span class="rare">ÂÖ≠Âç∞<\/span>:\s*(.+)„ÅÆÊ¨†ÁâáÔºà(.+)Ôºâ\s*$/s, (m, sealPart, inside)=>{
    return `ÂÖ≠Âç∞„ÅÆÊ¨†Áâá„ÇíÊâã„Å´ÂÖ•„Çå„ÅüÔºÅ<br><span class="mutedTxt">${sealPart}Ôºà${inside}Ôºâ</span>`;
  });
  s = s.replace(/^<span class="rare">Âç∞<\/span>:\s*(.+)Ôºà(.+)Ôºâ\s*$/s, (m, seal, inside)=>{
    return `Âç∞„Åå „Åã„Åå„ÇÑ„ÅÑ„ÅüÔºÅ<br><span class="mutedTxt">${seal}Ôºà${inside}Ôºâ</span>`;
  });

  // Not enough / cap / no-return
  s = s.replace(/^<span class="bad">‰∏çË∂≥<\/span>:\s*(.+)$/s, (m, tail)=>{
    return `<span class="bad">„Åó„Åã„Åó „Åü„Çä„Å™„ÅÑÔºÅ</span><br><span class="mutedTxt">${tail}</span>`;
  });
  s = s.replace(/^<span class="warn">‰∏äÈôê<\/span>:\s*(.+)$/s, (m, tail)=>{
    return `<span class="warn">„Åó„Åã„Åó „Åì„Çå‰ª•‰∏ä„ÅØ „Åß„Åç„Å™„ÅÑÔºÅ</span><br><span class="mutedTxt">${tail}</span>`;
  });
  s = s.replace(/^<span class="warn">Êàª„Çå„Åæ„Åõ„Çì<\/span>:\s*(.+)$/s, (m, tail)=>{
    return `<span class="warn">„Åó„Åã„Åó „ÇÇ„Å©„Çå„Å™„ÅÑÔºÅ</span><br><span class="mutedTxt">${tail}</span>`;
  });

  return s;
}

  function isMaxSpeedUnlocked(){
    try{ return !!hasAllSixFragments(); }catch(_){ return false; }
  }
  function maxSpeedLockNote(){
    try{
      const n = Math.min(6, Math.max(0, fragmentCount()));
      return `${n}/6`;
    }catch(_){
      return "0/6";
    }
  }
  function syncSpeedSelUnlock(){
    try{
      if (typeof els === "undefined" || !els || !els.speedSel) return;
      const sel = els.speedSel;
      const optMax = sel.querySelector(`option[value="${SPEED_MAX_LABEL}"]`);
      if (!optMax) return;

      const ok = isMaxSpeedUnlocked();
      if (!ok){
        optMax.disabled = true;
        optMax.textContent = `MAXÔºàÂÖ≠Âç∞ ${maxSpeedLockNote()}Ôºâ`;
        optMax.title = "ÊõºËçºÁæÖÂ∏≥„ÅÆÂÖ≠Âç∞„ÅÆÊ¨†Áâá„Çí6„Å§ÊèÉ„Åà„Çã„Å®Ëß£Êîæ";

        // If current speed is MAX but not unlocked (e.g., old saves), fall back.
        if (S && S.run && Number(S.run.speed) >= SPEED_MAX_LABEL){
          const fallback = Math.max(...SPEED_ALLOWED.filter(v => v < SPEED_MAX_LABEL));
          S.run.speed = fallback;
          sel.value = String(fallback);
        }
      } else {
        optMax.disabled = false;
        optMax.textContent = "MAX";
        optMax.title = "ÊúÄÈ´òÈÄüÂ∫¶";
      }
    }catch(_){}
  }


  function detectSeverity(msg){
    const m = String(msg||"");
    if (/\bclass="[^"]*\bbad\b/.test(m) || /\bclass='[^']*\bbad\b/.test(m)) return "bad";
    if (/\bclass="[^"]*\bwarn\b/.test(m) || /\bclass='[^']*\bwarn\b/.test(m)) return "warn";
    if (/\bclass="[^"]*\brare\b/.test(m) || /\bclass='[^']*\brare\b/.test(m)) return "rare";
    if (/\bclass="[^"]*\bgood\b/.test(m) || /\bclass='[^']*\bgood\b/.test(m)) return "good";
    return "";
  }
  function detectKind(msg){
    const s = stripTags(msg).replace(/\s+/g," ").trim();
    const has = (w)=> s.indexOf(w) >= 0;
    // Order matters: specific ‚Üí general
    if (has("ÂÖ≠Âç∞") || has("Ê¨†Áâá") || has("ÁµêÈ°ò") || has("Âç∞Êàê") || has("Âç∞„Çí")) return {key:"seal",  label:"ÂÖ≠Âç∞", ico:"ü™∑"};
    if (has("ÁïåÈñÄ") || has("ÊõºËçºÁæÖÂ∏≥") || has("Ëã¶Ë´¶Áïå") || has("ÈõÜË´¶Áïå") || has("ÁÑ°ÊòéÁïå") || has("ÁûãÊÖ¢Áïå") || has("ÂàÜÂà•Áïå") || has("ÊúâÈ†ÇÁïå") || has("ÂÖ≠ÈÅì")) return {key:"realm", label:"ÂÖ≠ÈÅì", ico:"üó∫"};
    if (has("Ë≠∑Êë©") || has("ÊµÑÂåñ") || has("Ê∏Ö„ÇÅ") || has("purify")) return {key:"purify", label:"Ë≠∑Êë©", ico:"üî•"};
    if (has("ÁúüË®Ä") || has("mantra")) return {key:"mantra", label:"ÁúüË®Ä", ico:"üìø"};
    if (has("Âä†ÊåÅ") || has("empower") || has("‰ªò‰∏é")) return {key:"empower", label:"Âä†ÊåÅ", ico:"‚ú®"};
    if (has("ÂÆùÂáΩ") || has("Êú™Êé•Á∂ö") || has("chest")) return {key:"chest", label:"ÂÆùÂáΩ", ico:"üì¶"};
    if (has("Ëá™ÂãïÂ∏ÉÊñΩ") || has("Â∏ÉÊñΩ") || has("Â£≤Âç¥")) return {key:"sell", label:"Â∏ÉÊñΩ", ico:"üßπ"};
    if (has("ÊíÉÁ†¥") || has("Ë®é‰ºê") || has("Ë¢´Âºæ") || has("‰ºöÂøÉ") || has("HP") || has("„ÉÄ„É°") || has("Êïµ") || has("Êà¶Èóò")) return {key:"combat", label:"Êà¶Èóò", ico:"‚öî"};
    if (has("ÂäüÂæ≥") || has("Ë°å") || has("ÊÇü„Çä") || has("Ê•≠")) return {key:"reward", label:"ÂèéÊîØ", ico:"Ôºã"};
    return {key:"system", label:"„É≠„Ç∞", ico:"‚Ñπ"};
  }

  function renderLog(){
    ensureLogIds();
    const wasPinned = isLogPinned(els.log);
    logPinned = wasPinned;

    const want = S.log.slice(-logCap());
    if (!want.length){
      els.log.innerHTML = "";
      logPending = [];
      logQueuedUpTo = 0;
      logPumpOn = false;
      return;
    }

    const firstId = Number(want[0].id || 0);
    const lastId  = Number(want[want.length-1].id || 0);

    const curFirst = els.log.firstElementChild ? Number(els.log.firstElementChild.dataset.id || 0) : 0;
    const curLast  = els.log.lastElementChild  ? Number(els.log.lastElementChild.dataset.id  || 0) : 0;

    // NOTE: Allow incremental updates when the log window slides forward.
    // If curFirst < firstId, we can trim instead of full re-render (prevents burst display).
    const needsFull = (!els.log.firstElementChild) || (curLast < firstId) || (curFirst > firstId) || (curLast > lastId);

    function makeEntry(x, isNew){
      const msg2 = dqifyLogMsg(toneLogMsg(x.msg));
      const k = detectKind(msg2);
      const sev = detectSeverity(msg2);
      const sevCls = sev ? ` sev-${sev}` : "";
      const d = document.createElement("div");
      d.className = `entry kind-${k.key}${sevCls}`;
      d.dataset.id = String(x.id || 0);
      d.innerHTML = `
        <span class="time">${x.t}</span>
        <span class="badge"><span class="ico">${k.ico}</span>${k.label}</span>
        <span class="msg">${msg2}</span>
      `;
      if (isNew && !isLogLite()){
        d.classList.add("new");
        if (reduceMotion){
          d.classList.remove("new");
        }else{
          requestAnimationFrame(()=>setTimeout(()=>d.classList.remove("new"), 50));
        }
      }
      return d;
    }

    if (needsFull){
      els.log.innerHTML = "";
      const frag = document.createDocumentFragment();
      for (const x of want) frag.appendChild(makeEntry(x, false));
      els.log.appendChild(frag);

      // Reset pacing queue
      logPending = [];
      logQueuedUpTo = lastId;
      logPumpOn = false;

      if (wasPinned){
        pinLogToBottom(els.log, 0);
      }
      return;
    }
const baseLast = Math.max(curLast, logQueuedUpTo);

    if (wasPinned){
      let maxQueued = baseLast;

      // Queue new rows (one-by-one display)
      for (const x of want){
        const id = Number(x.id || 0);
        if (id > baseLast){
          logPending.push({ id, node: makeEntry(x, true) });
          if (id > maxQueued) maxQueued = id;
        }
      }
      logQueuedUpTo = maxQueued;

      // Drop any rows that rotated out while queued
      dropPendingBefore(firstId);
      trimLogDomToRange(firstId);

      // Start paced append
      if (logPending.length) startLogPump();

    }else{
      // User is reading older logs: keep the view stable.
      // Queue new rows, but DO NOT insert them into DOM now (prevents bursts).
      let maxQueued = baseLast;
      for (const x of want){
        const id = Number(x.id || 0);
        if (id > baseLast){
          logPending.push({ id, node: makeEntry(x, true) });
          if (id > maxQueued) maxQueued = id;
        }
      }
      logQueuedUpTo = maxQueued;

      // Drop any rows that rotated out while queued
      dropPendingBefore(firstId);
      trimLogDomToRange(firstId);

      // (No auto-scroll / no flush here)
    }

    // Safety: if log rotated or pending flush made us longer than desired
    while (els.log.children.length > want.length){
      els.log.removeChild(els.log.firstElementChild);
    }
  }

  // --------------------
  // ÂØÜÊïôÊã°ÂºµÔºöË°åÁÇ∫
  // --------------------


  // --------------------
  // ‰∫åÊõºËçºÁæÖÔºàÂàÜÂ≤êÔºâ
  // --------------------
  function mandalaName(k){
    return k==="kongo" ? "ÈáëÂâõÁïå" : k==="taizo" ? "ËÉéËîµÁïå" : "Êú™ÁÅåÈ†Ç";
  }
  function mandalaSeal‰Ωç(kind){
    ensureMikkyoFields();
    const s = S.hero.mandalaSeal || {kongo:0, taizo:0};
    return clamp(Math.floor(num(s[kind],0)), 0, 108);
  }
  function mandalaChoose(kind){
    ensureMikkyoFields();
    const cur = S.hero.mandala || "";
    if (cur && cur !== kind){
      return mandalaReattune(kind);
    }
    if (!cur){
      S.hero.mandala = kind;
      try{ document.documentElement.dataset.mandala = kind; }catch(_){ }
      addKarma(kind==="taizo" ? 2 : 1);
      log(`<span class="rare">ÁÅåÈ†Ç</span>: ‰∫åÊõºËçºÁæÖ„Äå${mandalaName(kind)}„Äç„ÇíÈÅ∏„Å≥„Åæ„Åó„Åü„ÄÇ`);
      try{ if (typeof BFX !== 'undefined' && BFX && BFX.pulse) BFX.pulse(kind==="kongo"?1:2); }catch(_){ }
      save(); dirtyHUD = true; dirtyLog = true;
      try{ updateRealmFx(); }catch(_){ }
    }
  }
  function mandalaReattune(to){
    ensureMikkyoFields();
    const cur = S.hero.mandala || "";
    if (!cur || cur === to){
      log(`<span class="warn">ÂÜçÁÅåÈ†Ç</span>: „Åæ„ÅöÁâáÊñπ„ÇíÈÅ∏„Çì„Åß„Åè„Å†„Åï„ÅÑ„ÄÇ`);
      return;
    }
    const sealSum = mandalaSeal‰Ωç('kongo') + mandalaSeal‰Ωç('taizo');
    const costSat = Math.round(14 + sealSum*0.06 + totalPath‰Ωç()*0.05);
    const costGold = Math.round(1800 + sealSum*22 + S.run.floor*40);
    if (S.hero.satori < costSat || S.hero.gold < costGold){
      log(`<span class="bad">‰∏çË∂≥</span>: ÂÜçÁÅåÈ†Ç„Å´ ÊÇü„Çä${fmt(costSat)} / ÂäüÂæ≥${fmt(costGold)} „ÅåÂøÖË¶Å`);
      return;
    }
    S.hero.satori -= costSat;
    S.hero.gold -= costGold;
    S.hero.mandala = to;
    try{ document.documentElement.dataset.mandala = to; }catch(_){ }
    addKarma(-2);
    log(`<span class="rare">ÂÜçÁÅåÈ†Ç</span>: „Äå${mandalaName(to)}„Äç„Å∏ÂàáÊõø <span class="gold">(-${fmt(costGold)}ÂäüÂæ≥)</span> / (-${fmt(costSat)}ÊÇü„Çä)`);
    save(); dirtyHUD = true; dirtyLog = true;
    try{ updateRealmFx(); }catch(_){ }
  }

  function mandalaSealCost(kind, bulk){
    const lv0 = mandalaSeal‰Ωç(kind);
    const n = clampBulk(bulk);
    let g=0, s=0, got=0;
    for (let i=0;i<n;i++){
      const lv = lv0 + i;
      if (lv >= 108) break;
      g += Math.round(420 + Math.pow(lv+1, 1.42)*55);
      s += Math.round(2 + (lv+1)/18);
      got++;
    }
    return { costGold:g, costSat:s, got };
  }
  function buyMandalaSeal(kind, bulk){
    ensureMikkyoFields();
    const cur = S.hero.mandala || "";
    if (!cur){
      log(`<span class="warn">Êú™ÁÅåÈ†Ç</span>: „Åæ„Åö„ÄåÈáëÂâõÁïå„Äç„Åã„ÄåËÉéËîµÁïå„Äç„ÇíÈÅ∏„Çì„Åß„Åè„Å†„Åï„ÅÑ„ÄÇ`);
      return;
    }
    if (cur !== kind){
      log(`<span class="warn">ÂàÜÂ≤ê</span>: ‰ªä„ÅØ„Äå${mandalaName(cur)}„Äç„ÅÆÁ≥ªÁµ±„Åß„Åô„ÄÇÂç∞„ÅÆÂº∑Âåñ„ÅØÂêåÁ≥ªÁµ±„ÅÆ„Åø„ÄÇ`);
      return;
    }
    const c = mandalaSealCost(kind, bulk);
    if (c.got <= 0){ log(`<span class="warn">‰∏äÈôê</span>: „Åì„Çå‰ª•‰∏äÂº∑Âåñ„Åß„Åç„Åæ„Åõ„Çì„ÄÇ`); return; }
    if (S.hero.gold < c.costGold || S.hero.satori < c.costSat){
      log(`<span class="bad">‰∏çË∂≥</span>: Âç∞„ÅÆÂº∑Âåñ„Å´ ÊÇü„Çä${fmt(c.costSat)} / ÂäüÂæ≥${fmt(c.costGold)} „ÅåÂøÖË¶Å`);
      return;
    }
    S.hero.gold -= c.costGold;
    S.hero.satori -= c.costSat;
    S.hero.mandalaSeal = S.hero.mandalaSeal || {kongo:0, taizo:0};
    S.hero.mandalaSeal[kind] = clamp(mandalaSeal‰Ωç(kind) + c.got, 0, 108);
    log(`<span class="good">Âç∞„ÅÆÂº∑Âåñ</span>: ${mandalaName(kind)}„ÅÆÂç∞ +${c.got} <span class="gold">(-${fmt(c.costGold)}ÂäüÂæ≥)</span> / (-${fmt(c.costSat)}ÊÇü„Çä)`);
    save(); dirtyHUD = true; dirtyLog = true;
  }
  function totalPath‰Ωç(){
    const p = (S.hero && S.hero.path) ? S.hero.path : {};
    let t = 0;
    for (const k of ['view','thought','speech','action','livelihood','effort','mindfulness','concentration']) t += Math.floor(num(p[k],0));
    return t;
  }

  function pathCostFor(key, n){
    ensureMikkyoFields();
    const cur = clamp(Math.floor(num(S.hero.path[key],0)), 0, 108);
    n = clamp(Math.floor(num(n,1)), 1, 10000);
    let cost = 0;
    for (let i=0;i<n;i++){
      const lv = cur + i;
      if (lv >= 108) break;
      const base = 160 + (lv*22) + Math.pow(lv, 1.35)*8;
      const scale = 1 + Math.min(2.0, totalPath‰Ωç()*0.0022);
      cost += Math.round(base * scale);
    }
    return Math.round(cost);
  }

  function buyPath(key, bulk){
    ensureMikkyoFields();
    const b = clamp(Math.floor(num(bulk,1)), 1, 10000);
    const cur = clamp(Math.floor(num(S.hero.path[key],0)), 0, 108);
    if (cur >= 108){ log('„Åù„ÅÆ‰øÆË°å„ÅØÊó¢„Å´Ê•µ„Åæ„Å£„Å¶„Åä„Çä„Åæ„ÅôÔºà‰Ωç108Ôºâ„ÄÇ'); dirtyLog=true; return; }
    const cost = pathCostFor(key, b);
    if (S.hero.gold < cost){ log(`<span class="warn">ÂäüÂæ≥„ÅåË∂≥„Çä„Åæ„Åõ„Çì</span>: ${fmt(cost)} ÂøÖË¶Å`); dirtyLog=true; return; }
    const before = cur;
    const canAdd = Math.min(b, 108 - cur);
    S.hero.gold -= cost;
    S.hero.path[key] = cur + canAdd;
    // ÂæÆÈáè„ÅÆÂñÑÊ•≠ÔºàÂä™Âäõ„ÅÆÁ©çÁ´ãÔºâ
    addKarma(Math.max(1, Math.floor(canAdd/10)));
    log(`<span class="good">‰øÆË°å</span>: ${PATH_KEYS.find(x=>x.key===key)?.name||key} +${canAdd} <span class="gold">(-${fmt(cost)}ÂäüÂæ≥)</span>`);
    save();
    dirtyHUD=true;
  }

  function dedicationPreview(){ return "ÂõûÂêë„ÅØÂâäÈô§„Åï„Çå„Åæ„Åó„Åü"; }
  function doDedicate(){ log("<span class=\"warn\">ÂõûÂêë</span>: „Åì„ÅÆË¶ÅÁ¥†„ÅØÂâäÈô§„Åï„Çå„Åæ„Åó„Åü„ÄÇ"); dirtyLog=true; }

  function purifyPreview(){
    ensureMikkyoFields();
    const k = clampKarma(S.hero.karma||0);
    const p = Math.max(0, Math.floor(num(S.hero.codex.purifies,0)));
    const cost = Math.round(260 + p*45 + Math.abs(k)*6);

    if (k === 0) return `Ë≠∑Êë©ÔºàÊ•≠‰∏≠ÂíåÔºâ: ${fmt(cost)}ÂäüÂæ≥ÔºàÊ•≠„ÅØÈùôÁ©èÔºâ`;

    const step = Math.max(1, Math.floor(2 + p/10));
    const move = Math.min(step, Math.abs(k));
    const note = (k > 0) ? `Ê•≠ -${move}Ôºà0„Å∏Ôºâ` : `Ê•≠ +${move}Ôºà0„Å∏Ôºâ`;
    return `Ë≠∑Êë©ÔºàÊ•≠‰∏≠ÂíåÔºâ: ${fmt(cost)}ÂäüÂæ≥„Åß ${note}ÔºàÂÅè„Çä„ÅåÂ§ß„Åç„ÅÑ„Åª„Å©È´ò‰ª£‰æ°Ôºâ`;
  }

  function doPurify(){
    ensureMikkyoFields();
    const k = clampKarma(S.hero.karma||0);
    const p = Math.max(0, Math.floor(num(S.hero.codex.purifies,0)));
    const cost = Math.round(260 + p*45 + Math.abs(k)*6);

    if (k === 0){
      log(`<span class="good">Ë≠∑Êë©</span>: Ê•≠„ÅØÈùôÁ©èÔºàÊµÑÂåñ‰∏çË¶ÅÔºâ`);
      dirtyLog = true;
      return;
    }
    if (S.hero.gold < cost){ log(`<span class="warn">ÂäüÂæ≥„ÅåË∂≥„Çä„Åæ„Åõ„Çì</span>: ${fmt(cost)} ÂøÖË¶Å`); dirtyLog=true; return; }

    const step = Math.max(1, Math.floor(2 + p/10));
    const move = Math.min(step, Math.abs(k));
    const delta = (k > 0) ? -move : +move;

    S.hero.gold -= cost;
    addKarma(delta);
    try{ S.hero.codex.purifies = (S.hero.codex.purifies||0) + 1; S.hero.codex.events = S.hero.codex.events || {}; S.hero.codex.events.goma = 1; }catch(_){ }
    log(`<span class="good">Ë≠∑Êë©</span>: ÁÅ´Â§©„Å´‰æõ„Åó„Å¶ÊµÑÂåñ <span class="gold">(-${fmt(cost)}ÂäüÂæ≥)</span> / Ê•≠ ${(delta>=0?'+':'')}${fmt(delta)}Ôºà0„Å∏Ôºâ`);
    spawnMantraFx('‡§π‡•Ç‡§Ç');
    save();
    dirtyHUD=true;
  }


  function castMantra(){
    ensureMikkyoFields();
    const t = now();
    const cd = num(S.run.mantraCdUntil, 0);
    if (t < cd){ log(`<span class="warn">ÁúüË®Ä</span>: ÂÜ∑Âç¥‰∏≠Ôºà${(Math.max(0, cd-t)/1000).toFixed(0)}sÔºâ`); dirtyLog=true; return; }
    const need = 5;
    if (S.hero.satori < need){ log(`<span class="warn">ÁúüË®Ä</span>: ÊÇü„Çä„ÅåË∂≥„Çä„Åæ„Åõ„ÇìÔºà${need}ÂøÖË¶ÅÔºâ`); dirtyLog=true; return; }

    S.hero.satori -= need;

    // ÂÖ´Ê≠£ÈÅìÔºàÊ∞∏Á∂öÔºâ„ÇíÂâäÈô§„Åó„Åü„Åü„ÇÅ„ÄÅÊåÅÁ∂ö/ÂÜ∑Âç¥„ÅØÂõ∫ÂÆö
    const dur = 12; // Áßí
    const cd2 = 30; // Áßí

    S.run.mantraUntil = t + dur * 1000;
    S.run.mantraCdUntil = t + cd2 * 1000;
    S.hero.codex.mantras = (S.hero.codex.mantras||0) + 1;
    addKarma(1);
    log(`<span class="rare">ÁúüË®Ä</span>: ÈáëÂâõÁïå„ÅÆÂä†Ë≠∑Ôºà${dur.toFixed(0)}sÔºâ`);
    spawnMantraFx('‡•ê');
    save();
    dirtyHUD=true;
  }


  function spawnMantraFx(glyph){
    if (!els.battleStage) return;
    if (!fxEnabled()) return;
    const ring = document.createElement('div');
    ring.className = 'mantraPulse';
    els.battleStage.appendChild(ring);
    const g = document.createElement('div');
    g.className = 'seedGlyph';
    g.textContent = glyph || '‡•ê';
    g.style.fontSize = '42px';
    els.battleStage.appendChild(g);
    window.setTimeout(()=>{ try{ ring.remove(); g.remove(); }catch(_){ } }, 1200);
    try{ if (typeof BFX !== 'undefined' && BFX && BFX.flash) BFX.flash(45); }catch(_){ }
  }

  function touchRealm(realmKey){
    ensureMikkyoFields();
    if (!realmKey) return;
    S.hero.codex.realms[realmKey] = 1;
  }

  function onEnemyDefeated(e, gold, xp){
    ensureMikkyoFields();
    S.hero.codex.kills = (S.hero.codex.kills||0) + 1;
    if (e.isBoss) S.hero.codex.bosses = (S.hero.codex.bosses||0) + 1;
    if (e.isElite) S.hero.codex.elites = (S.hero.codex.elites||0) + 1;
    if (S.run && S.run.floor) S.hero.codex.maxFloor = Math.max(S.hero.codex.maxFloor||1, Math.floor(S.run.floor));
    if (e && e.realmKey) touchRealm(e.realmKey);

    // ÊÆ∫Áîü„ÅÆ‚ÄúË≤†Ëç∑‚Äù„ÇíÂ∞è„Åï„ÅèÂÖ•„Çå„ÇãÔºàÁúüË®Ä‰∏≠„ÅØËã¶Ê∏õÔºâ
    const base = -(e.isBoss ? 3 : (e.isElite ? 2 : 1));
    const mantraEase = (S.run && S.run.mantraUntil && now() < S.run.mantraUntil) ? 20 : 0;
    const modK = Math.floor(num(e.karmaKill||0, 0));
    const delta = base + mantraEase + modK;
    const r = addKarma(delta);
    if (Math.random() < 0.18){
      const sign = delta>=0?'+':'';
      log(`<span class="muted">Ê•≠</span>: ${sign}${delta}Ôºà${r.before}‚Üí${r.after}Ôºâ`);
      dirtyLog = true;
    }
    // Á´†„ÅÆÂç∞ÔºàÊ†πÊú¨„ÅÆ„Åª„Å©„ÅëÔºâ
    if (e && e.isBoss && e.realmKey){ try{ storyBossSeal(e.realmKey); }catch(_){ } }
  }

  // ---- ÂÑÄÁ§ºÔºàÂÑÄÁ§ºÔºâ ----
  function chance(p){ return Math.random() < p; }
  function openEvent(ev){
    if (!els.eventOverlay) return;
    ensureMikkyoFields();

    const r = S.run;

    // ‚úÖ Ëá™ÂãïÂ∑°Á§º‰∏≠„ÅØ„ÄåÊ≠¢„ÇÅ„Å™„ÅÑ„ÄçÔºöÂÑÄÁ§º„ÅØËá™Âãï„ÅßÂá¶ÁêÜ„Åó„Å¶Â∑°Á§º„ÇíÁ∂ôÁ∂ö
    if (r && r.auto){
      const choices = (ev && Array.isArray(ev.choices)) ? ev.choices : [];
      let pickIdx = 0;

      if (choices.length){
        const isSafe = (lab) => /Ë¶ãÈÄÅ|ÁÑ°Ë¶ñ|Èñâ„Åò|Êàª„Çã|Á´ã„Å°Âéª|„ÇÑ„ÇÅ„Çã|ÁúÅÁï•|‰Ωï„ÇÇ„Åó„Å™„ÅÑ|Ë¶ã„Å™„Åã„Å£„Åü/.test(String(lab||""));
        const safeIdx = choices.findIndex(c => isSafe(c && c.label));
        if (safeIdx >= 0){
          pickIdx = safeIdx;
        } else {
          // ÁÅåÈ†Ç„Å™„Å©2Êäû„ÅØ„ÄåËÉéËîµÔºàÊÖàÊÇ≤Ôºâ„Äç„ÇíÂÑ™ÂÖà„Åó„Å¶‰∏ÄÊó¶Ê±∫„ÇÅ„ÇãÔºàÂÑÄÁ§º„ÅåÁπ∞„ÇäËøî„ÅóÂá∫„Çã„ÅÆ„ÇíÈò≤„ÅêÔºâ
          const taizoIdx = choices.findIndex(c => /ËÉéËîµ/.test(String(c && c.label || "")));
          pickIdx = (taizoIdx >= 0) ? taizoIdx : 0;
        }
      }

      const c = choices[pickIdx];
      try{
        if (c){
          if (typeof c.apply === "function") c.apply();
          else if (typeof c.effect === "function") c.effect();
        }
      }catch(_){}

      if (ev && ev.key){
        try{
          ensureMikkyoFields();
          S.hero.codex.events[ev.key] = 1;
        }catch(_){}
      }

      // ÁîªÈù¢„ÅØÊ≠¢„ÇÅ„Åö„ÄÅË®ò„Å´„Å†„ÅëÊÆã„Åô
      log(`<span class="good">ÂÑÄÁ§º</span>: ${ev && ev.title ? ev.title : 'ÂÑÄÁ§º'}ÔºàËá™ÂãïÂá¶ÁêÜÔºâ`);
      dirtyLog = true;

      // Ê¨°„ÅÆÈ≠î„Åå„ÅÑ„Å™„ÅÑÁä∂ÊÖã„Å´„Å™„Çâ„Å™„ÅÑ„Çà„ÅÜ„Å´‰øùÈô∫
      try{ ensureEnemy(); }catch(_){}
      save();
      dirtyHUD = true;
      return;
    }

    S.run._eventLock = now() + 200; // ÈÄ£ÊâìÂ∞ÅÂç∞ÔºàmsÔºâ
    if (S.run.active){
      S.run.active = false;
      S.run._resumeAfterEvent = 1;
    } else {
      S.run._resumeAfterEvent = 0;
    }
    els.eventTitle.textContent = ev.title || '‚Äî';
    els.eventBody.textContent = ev.body || '';
    els.eventFoot.textContent = ev.foot || '';
    els.eventChoices.innerHTML = '';
    (ev.choices||[]).forEach((c,idx)=>{
      const b = document.createElement('button');
      b.className = c.accent ? 'small accent' : 'small';
      b.textContent = c.label;
      b.onclick = ()=>{ chooseEvent(ev, idx); };
      els.eventChoices.appendChild(b);
    });
    els.eventOverlay.style.display = 'flex';
    dirtyHUD = true;
  }
  function closeEvent(){
    if (!els.eventOverlay) return;
    els.eventOverlay.style.display = 'none';
    // resume if needed
    if (S.run._resumeAfterEvent === 1 && !S.hero.dead){
      S.run.active = true;
      S.run.lastTick = now();
      ensureEnemy();
    }
    S.run._resumeAfterEvent = 0;
    save();
    dirtyHUD = true;
  }
  function chooseEvent(ev, idx){
    if (now() < num(S.run._eventLock,0)) return;
    const c = (ev.choices||[])[idx];
    try{ if (c){ if (c.apply) c.apply(); else if (c.effect) c.effect(); } }catch(_){ }
    if (ev && ev.key){
      ensureMikkyoFields();
      S.hero.codex.events[ev.key] = 1;
    }
    closeEvent();
  }

  function maybeTriggerEvent(){
    // ÈÉ®Â±ãÈÄ≤Ë°å„ÅßÁ®Ä„Å´Áô∫Áîü„ÄÇÂ§©È≠îÈÉ®Â±ãÁõ¥Ââç„ÅØÈÅø„Åë„Çã„ÄÇ
    const r = S.run;
    if (!r || S.hero.dead) return false;
    if (r.room % 10 === 0) return false;
    // 6„Äú9ÈÉ®Â±ã„Å´1Âõû„Åè„Çâ„ÅÑÔºàÊ•≠„ÅÆÂØÑ„Çä„ÅåÂº∑„ÅÑ„Åª„Å©„ÄÅÂÑÄÁ§º„Åå‚ÄúÊøÉ„Åè‚Äù„Å™„ÇãÔºâ
    const karmaNow = clampKarma(S.hero.karma||0);
    const kNorm = clamp(karmaNow/108, -1, 1);
    const shift = Math.round(kNorm*2); // -2..2
    const biasStrength = Math.abs(shift)/2; // 0 / 0.5 / 1
    const pBase = clamp(0.06 + ((r.room % 9)===0 ? 0.08 : 0), 0, 0.20);
    const p = clamp(pBase + biasStrength*0.05, 0, 0.24);
    if (!chance(p)) return false;

    const biome = biomeForFloor(r.floor);
    const realmKey = biome.key;
    const goodBias = clamp((karmaNow + 108) / 216, 0, 1);

    const events = [];

    // ÂàùÂõûÁÅåÈ†ÇÂÑÄÁ§ºÔºàÊú™ÁÅåÈ†Ç„Å™„ÇâÂÑ™ÂÖàÁöÑ„Å´Âá∫„ÅôÔºâ
    try{
      ensureMikkyoFields();
      if (!(S.hero.mandala||"") && !(S.hero.codex.events && S.hero.codex.events.kanjo) && ((S.hero.satori||0) >= 12 || (S.run.floor||1) >= 12)){
        events.push({
          key:"kanjo",
          title:"ÁÅåÈ†ÇÔºö‰∫åÊõºËçºÁæÖ",
          body:"Â∏´ÂÉß„ÅåÁ†ÇÊõºËçºÁæÖ„ÇíÁµê„Å∂„ÄÇ„ÅÇ„Å™„Åü„ÅØ" + (biomeForFloor(S.run.floor).name) + "„Åß„Äé„Å©„Å°„Çâ„ÅÆÊõºËçºÁæÖ„ÇíÁîü„Åç„Çã„Åã„Äè„ÇíÂïè„Çè„Çå„Åü„ÄÇ",
          goodBias: 0.0,
          choices:[
            { label:"üî± ÈáëÂâõÁïåÔºàË™ø‰ºèÔºâ", apply: () => { mandalaChoose("kongo"); S.hero.codex.events.kanjo = 1; } },
            { label:"üå∏ ËÉéËîµÁïåÔºàÊÖàÊÇ≤Ôºâ", apply: () => { mandalaChoose("taizo"); S.hero.codex.events.kanjo = 1; } },
          ]
        });
      }
    }catch(_){ }

    // events list
    events.push({
      key:'ajikan',
      title:'ÈòøÂ≠óË¶≥Ôºà„ÅÇ„Åò„Åã„ÇìÔºâ ‚Äî „ÄåÈòø„Äç„ÅÆË¶≥ÊÉ≥',
      body:'‰∏≠ÂøÉ„Å´„ÄåÈòøÂ≠ó„Äç„ÇíË¶≥„Åò„ÄÅÁîüÊàê„Å®Ê∂àÊªÖ„ÇíÂêå‰∏ÄË¶ñ„Åô„ÇãË¶≥Ê≥ï„ÄÇ',
      foot:'',
      choices:[
        { label:'ÈùôÂùê„Åó„Å¶Ë¶≥ÊÉ≥„Åô„ÇãÔºàÂÆâÂÖ®Ôºâ', accent:true, apply:()=>{ S.hero.satori += 6; addKarma(1); log('<span class="good">ÈòøÂ≠óË¶≥</span>: ÊÇü„Çä„ÅåÂ∞ë„ÅóÊæÑ„Åø„Åæ„Åó„Åü'); spawnMantraFx('‡§Ö'); } },
        { label:'ÊÄ•„ÅÑ„ÅßÈÄöÈÅé„Åô„Çã', apply:()=>{ log('Èùô„Åã„Å´ÈÄö„ÇäÈÅé„Åé„Åæ„Åó„Åü„ÄÇ'); } },
      ]
    });

    events.push({
      key:'goma',
      title:'Ë≠∑Êë©Â£á ‚Äî ÁÅ´Â§©‰æõ„ÅÆÊ∞óÈÖç',
      body:'Ë≠∑Êë©Êú®„ÅåÁ©ç„Åæ„Çå„ÄÅÁÇé„ÅÆÊ∫ñÂÇô„ÅåÊï¥„Å£„Å¶„ÅÑ„Çã„ÄÇ\n‰æõÁâ©ÔºàÂäüÂæ≥Ôºâ„ÇíÊäï„Åò„Çã„Å®„ÄÅÊÇ™Ê•≠„Åå„Çè„Åö„Åã„Å´ÁÑº„Åã„Çå„Çã„ÄÇ',
      foot:'',
      choices:[
        { label:'Ë≠∑Êë©„ÇíÁÑö„ÅèÔºàÂæ≥‚ÜíÊ•≠Ôºâ', accent:true, apply:()=>doPurify() },
        { label:'‰æõÁâ©„ÇíÂ∞ë„Åó„Å†„ÅëÔºàËªΩ„ÅÑÔºâ', apply:()=>{ const c=180; if (S.hero.gold>=c){ S.hero.gold-=c; addKarma(1); log(`<span class="good">‰æõÁâ©</span>: -${fmt(c)}ÂäüÂæ≥ / Ê•≠ +1`); spawnMantraFx('‡§π'); } else { log('<span class="warn">ÂäüÂæ≥„ÅåË∂≥„Çä„Åæ„Åõ„Çì</span>'); } } },
        { label:'„ÇÑ„ÇÅ„Å¶„Åä„Åè', apply:()=>log('‰ªäÂõû„ÅØË¶ãÈÄÅ„Çä„Åæ„Åó„Åü„ÄÇ') },
      ]
    });

    events.push({
      key:'shakyo',
      title:'ÂÜôÁµå„ÅÆÈñì ‚Äî ÂèçÂæ©„Åô„ÇãÁ∑ö',
      body:'ÊñáÂ≠ó„ÅÆÂèçÂæ©„ÅØ„Äå‰π±„Çå„ÇíÂõ∫ÂÆöÂåñ„Äç„Åô„Çã„ÄÇ\nÊôÇÈñì„ÇíË≤ª„ÇÑ„Åõ„Å∞„ÄÅÊÇü„ÇäÔºàÁêÜËß£Ôºâ„ÇíÂæó„Çã„ÅåÈÄ≤Ë°å„ÅØÈÅÖ„Çå„Çã„ÄÇ',
      foot:'',
      choices:[
        { label:'‰∏ÅÂØß„Å´ÂÜô„ÅôÔºàÊÇü„Çä+Ôºâ', accent:true, apply:()=>{ const gain=10; S.hero.satori += gain; addKarma(2); log(`<span class="good">ÂÜôÁµå</span>: ÊÇü„Çä +${fmt(gain)} / Ê•≠ +2`); spawnMantraFx('‡•ê'); } },
        { label:'ÊÄ•„ÅÑ„ÅßÂÜô„ÅôÔºàÂ∞èÔºâ', apply:()=>{ S.hero.satori += 4; addKarma(1); log('<span class="good">ÂÜôÁµå</span>: ÊÇü„Çä +4'); } },
        { label:'Êâã„ÇíÂêà„Çè„Åõ„Å¶Âá∫„Çã', apply:()=>{ addKarma(1); log('ÂêàÊéå„Åó„ÄÅÈùô„Åã„Å´Â†¥„ÇíÈõ¢„Çå„Åæ„Åó„Åü„ÄÇ'); } },
      ]
    });

    events.push({
      key:'kekkai',
      title:'ÁµêÁïå ‚Äî Â¢ÉÁïåÁ∑ö„ÅÆÁîüÊàê',
      body:'„Åì„Åì„ÅßÁµêÁïå„ÇíÂºµ„Çå„Å∞„ÄÅÊ¨°„ÅÆÂÖ•ÂÆ§Áõæ„ÅåÂéö„Åè„Å™„Çã„ÄÇ',
      foot:'',
      choices:[
        { label:'ÁµêÁïå„ÇíÂºµ„ÇãÔºàÂæ≥Ê∂àË≤ªÔºâ', accent:true, apply:()=>{ const c=240; if (S.hero.gold<c){ log('<span class="warn">ÂäüÂæ≥„ÅåË∂≥„Çä„Åæ„Åõ„Çì</span>'); return; } S.hero.gold-=c; S.run.entryShield = 2.4; S.run.entryShieldDR = 0.65; addKarma(1); log(`<span class="good">ÁµêÁïå</span>: Ê¨°„ÅÆÂÖ•ÂÆ§Áõæ„ÇíÂº∑Âåñ <span class="gold">(-${fmt(c)}ÂäüÂæ≥)</span>`); spawnMantraFx('‡•ê'); } },
        { label:'Ë¶≥ÂØü„Å†„Åë„Åó„Å¶ÈÄ≤„ÇÄ', apply:()=>{ S.hero.satori += 2; log('„Å≤„Å®ÊÅØË¶≥ÂØü„Åó„ÄÅ„Åù„ÅÆ„Åæ„ÅæÊ≠©„ÇíÈÄ≤„ÇÅ„Åæ„Åó„Åü„ÄÇ'); } },
      ]
    });

    // È†òÂüüÔºàÂÖ≠ÈÅìÔºâ„Å´Âøú„Åò„ÅüÂÑÄÁ§º„ÇíÂ∞ë„ÅóÊ∑∑„Åú„Çã
    if (realmKey === 'hungry'){
      events.push({
        key:'segaki',
        realmKey:'hungry',
        goodBias:0.66,
        title:'ÊñΩÈ§ìÈ¨º ‚Äî Ê¨†‰πè„Å∏„ÅÆÂøúÁ≠î',
        body:'È§ìÈ¨º„ÅÆÊ¨†‰πè„ÅØ„ÄåÂüã„ÇÅ„Å¶„ÇÇÂüã„Åæ„Çâ„Å™„ÅÑ„ÄçÊßãÈÄ†„Å®„Åó„Å¶Ë°®Ë±°„Åï„Çå„Çã„ÄÇ\nÊñΩ„Åó„ÅØÊ•≠„ÇíÊï¥„Åà„Çã„Åå„ÄÅË≥áÊ∫ê„ÇíÂ§±„ÅÜ„ÄÇ',
        foot:'Ôºà„ÄêÊ∏á„ÄëÊ∏áÊÑõÂç∞„ÅÆÊ∞óÈÖç„ÅåÊøÉ„ÅÑÔºâ',
        choices:[
          { label:'Â∏ÉÊñΩ„Åô„ÇãÔºàÂæ≥‚ÜíÊ•≠/ÊÇü„ÇäÔºâ', accent:true, apply:()=>{ const c=Math.min(S.hero.gold, 380); if (c<=0){ log('<span class="warn">ÂäüÂæ≥„ÅåË∂≥„Çä„Åæ„Åõ„Çì</span>'); return; } S.hero.gold-=c; S.hero.satori += Math.max(1, Math.floor(Math.sqrt(c)*0.55)); addKarma(3); log(`<span class="good">Â∏ÉÊñΩ</span>: -${fmt(c)}ÂäüÂæ≥ / Ê•≠ +3 / ÊÇü„ÇäÂ¢ó`); spawnMantraFx('Ê∏á'); } },
          { label:'Ë¶ã„Å™„Åã„Å£„Åü„Åì„Å®„Å´„Åô„Çã', apply:()=>{ addKarma(-2); log('<span class="warn">ÁÑ°Ë¶ñ</span>: Ê•≠ -2'); } },
        ]
      });

      events.push({
        key:'hungry_mui',
        realmKey:'hungry',
        goodBias:0.62,
        title:'ÁÑ°ÁïèÊñΩ ‚Äî ÊÅê„Çå„ÇíÊ∏°„Åô',
        body:'È£¢„Åà„ÅØËÖπ„Å†„Åë„Å´ÂÆø„Çâ„Å™„ÅÑ„ÄÇ\nÊÅê„Çå„ÇÇ„Åæ„ÅüÊ¨†‰πè„ÅÆÁõ∏„Å†„ÄÇ\nÊÅê„Çå„ÇíÊ∏°„Åô„Åã„ÄÅËìÑ„Åà„Çã„Åã„ÄÇ',
        foot:'',
        choices:[
          { label:'ÁÑ°ÁïèÊñΩ„Åô„ÇãÔºàÂæ≥- / Áõæ+ / Ê•≠+Ôºâ', accent:true, apply:()=>{ const c=260; if (S.hero.gold<c){ log('<span class="warn">ÂäüÂæ≥„ÅåË∂≥„Çä„Åæ„Åõ„Çì</span>'); return; } S.hero.gold-=c; S.run.entryShield = Math.max(num(S.run.entryShield,0), 2.2); S.run.entryShieldDR = Math.max(num(S.run.entryShieldDR,0), 0.60); S.hero.satori += 5; addKarma(3); log(`<span class="good">ÁÑ°ÁïèÊñΩ</span>: -${fmt(c)}ÂäüÂæ≥ / ÁõæÂº∑Âåñ / Ê•≠ +3`); spawnMantraFx('ÊñΩ'); } },
          { label:'ËìÑ„Åà„ÇãÔºàÂäüÂæ≥+ / Ê•≠-Ôºâ', apply:()=>{ const g=Math.floor(200+Math.random()*260); S.hero.gold+=g; addKarma(-2); log(`<span class="gold">ÂäüÂæ≥</span> +${fmt(g)} / <span class="warn">Ê•≠</span> -2`); } },
        ]
      });

      events.push({
        key:'hungry_kagami',
        realmKey:'hungry',
        goodBias:0.60,
        title:'Á©∫ËÖπ„ÅÆÈè° ‚Äî Á©¥„ÇíÁÖß„Çâ„Åô',
        body:'Èè°„Å´„ÅØËÖπ„Åß„ÅØ„Å™„Åè„ÄÅÁ©¥„ÅåÊò†„Çã„ÄÇ\nÁ©¥„ÇíÂüã„ÇÅ„Çã„Åã„ÄÅÁ©¥„ÇíÁÖß„Çâ„Åó„Å¶Ê≠©„Åè„Åã„ÄÇ',
        foot:'',
        choices:[
          { label:'Á©¥„ÇíÁÖß„Çâ„ÅôÔºàÊÇü„Çä+ / Ê•≠+Ôºâ', accent:true, apply:()=>{ S.hero.satori += 12; addKarma(2); log('<span class="good">ÁÖß</span>: Ê¨†‰πè„ÇíË¶ãÂ§±„Çè„Åö„Å´Ê∏à„Åø„Åæ„Åó„Åü'); spawnMantraFx('Ê∏á'); } },
          { label:'Á©¥„ÇíÂüã„ÇÅ„ÇãÔºàÂäüÂæ≥++ / Ê•≠-Ôºâ', apply:()=>{ const g=Math.floor(360+Math.random()*520); S.hero.gold+=g; addKarma(-3); log(`<span class="gold">ÂäüÂæ≥</span> +${fmt(g)} / <span class="warn">Ê•≠</span> -3`); } },
        ]
      });
    }
    if (realmKey === 'hell'){
      events.push({
        key:'kasho',
        realmKey:'hell',
        goodBias:0.58,
        title:'ÁÑ¶ÁÜ±„ÅÆÊ≥ïÈñÄ ‚Äî Ëã¶„ÇíÂÜô„Åô',
        body:'ÁÜ±„ÅØÂ§ñ„Åã„ÇâÊù•„Çã„ÅÆ„Åß„ÅØ„Å™„ÅÑ„ÄÇ\nÂèçÂøú„Å®„Åó„Å¶Áîü„Åæ„Çå„ÄÅÊ•≠„Å®„Åó„Å¶ÊÆã„Çã„ÄÇ\nËã¶„ÇíÈÅø„Åë„Åö„ÄÅËã¶„ÅÆÂΩ¢„ÇíÂÜô„Åó„Å¶ÈÄ≤„ÇÅ„ÄÇ',
        foot:'Ôºà„ÄêÁÅ´„ÄëÁÑ¶ÁÜ±Âç∞„ÅÆÊ∞óÈÖç„ÅåÊøÉ„ÅÑÔºâ',
        choices:[
          { label:'ÊÅØ„ÇíÊï∞„Åà„ÇãÔºàÂøçËæ±Ôºâ', accent:true, apply:()=>{ S.run.entryShield = Math.max(num(S.run.entryShield,0), 1.8); S.run.entryShieldDR = Math.max(num(S.run.entryShieldDR,0), 0.55); S.hero.satori += 5; addKarma(2); log('<span class="good">ÂøçËæ±</span>: Ê¨°„ÅÆÂÖ•ÂÆ§Áõæ„ÅåÂéö„Åè„Å™„Çä„Åæ„Åó„Åü'); spawnMantraFx('ÁÅ´'); } },
          { label:'ÊÄí„Çä„Å´Âëë„Åæ„Çå„Å¶ÊÄ•„Åê', apply:()=>{ addKarma(-3); log('<span class="warn">Áûã</span>: Ê•≠ -3'); } },
        ]
      });

      events.push({
        key:'hell_ingou',
        realmKey:'hell',
        goodBias:0.54,
        title:'Âõ†Êûú„ÅÆÁÅ´Á∞° ‚Äî Âõ†„ÇíÂºï„ÅçÂèó„Åë„Çã',
        body:'ÁÑº„Åë„ÅüÊú®Êú≠„Å´„ÄÅ„ÅÇ„Å™„Åü„ÅÆ„ÄåÂõ†„Äç„ÅåÂàª„Åæ„Çå„Å¶„ÅÑ„Çã„ÄÇ\nÂèó„ÅëÂèñ„Çã„Åã„ÄÅÂ§ñ„Å´ÁΩÆ„Åè„Åã„ÄÇ',
        foot:'',
        choices:[
          { label:'Âõ†„ÇíÂèó„ÅëÂèñ„ÇãÔºàÂäüÂæ≥- / ÊÇü„Çä++ / Ê•≠+Ôºâ', accent:true, apply:()=>{ const c=Math.min(S.hero.gold, 220); if (c>0) S.hero.gold-=c; S.hero.satori+=10; addKarma(3); log(`<span class="good">Âõ†Êûú</span>: Âèó„ÅëÂèñ„Å£„Åü <span class="gold">(-${fmt(c)}ÂäüÂæ≥)</span>`); spawnMantraFx('Âõ†'); } },
          { label:'Ë≤¨„ÇíÂ§ñ„Å´ÁΩÆ„ÅèÔºàÂäüÂæ≥+ / Ê•≠-Ôºâ', apply:()=>{ const g=Math.floor(240+Math.random()*320); S.hero.gold+=g; addKarma(-3); log(`<span class="gold">ÂäüÂæ≥</span> +${fmt(g)} / <span class="warn">Ê•≠</span> -3`); } },
        ]
      });

      events.push({
        key:'hell_reisui',
        realmKey:'hell',
        goodBias:0.56,
        title:'ÂÜ∑Ê∞¥„ÅÆ‰∫ï ‚Äî ÁÜ±ÊÇ©„ÇíÂÜ∑„Åæ„Åô',
        body:'‰∫ï„ÅÆÂ∫ï„Åß„ÄÅÈªí„ÅÑÊ∞¥„ÅåÈùô„Åã„Å´ÂÖâ„Çã„ÄÇ\nÁÜ±ÊÇ©„ÇíÂÜ∑„Åæ„Åô„Åã„ÄÅÁÜ±„ÇíÊä±„Åà„Åü„Åæ„ÅæÊ≠©„Åè„Åã„ÄÇ',
        foot:'',
        choices:[
          { label:'ÂÜ∑„Åæ„ÅôÔºàÁõæ+ / Ê•≠+Ôºâ', accent:true, apply:()=>{ S.run.entryShield = Math.max(num(S.run.entryShield,0), 2.4); S.run.entryShieldDR = Math.max(num(S.run.entryShieldDR,0), 0.65); S.hero.satori += 6; addKarma(2); log('<span class="good">Ê∏ÖÊ∂º</span>: ÁµêÁïå„ÅåÊï¥„ÅÑ„Åæ„Åó„Åü'); spawnMantraFx('ÂÜ∑'); } },
          { label:'ÁÜ±„ÇíÊä±„ÅèÔºàÂäüÂæ≥+ / Ê•≠-Ôºâ', apply:()=>{ const g=Math.floor(260+Math.random()*360); S.hero.gold+=g; addKarma(-2); log(`<span class="gold">ÂäüÂæ≥</span> +${fmt(g)} / <span class="warn">Ê•≠</span> -2`); spawnMantraFx('ÁÅ´'); } },
        ]
      });
    }
    if (realmKey === 'animal'){
      events.push({
        key:'mondo',
        realmKey:'animal',
        goodBias:0.62,
        title:'ÂïèÁ≠î ‚Äî Èúß„ÅÆ‰∏≠„ÅÆ‰∏ÄÂïè',
        body:'Âïè„ÅÑ„ÅØÁ≠î„Åà„ÅÆ„Åü„ÇÅ„Å´„ÅÇ„Çã„ÅÆ„Åß„ÅØ„Å™„ÅÑ„ÄÇ\nÈúß„ÅÆ‰∏≠„Åß„ÄåÂïè„ÅÑ„Çí‰øù„Å§„Äç„Åì„Å®„Åå„ÄÅÊ¨°„ÅÆ‰∏ÄÊ≠©„Å´„Å™„Çã„ÄÇ',
        foot:'Ôºà„ÄêÈúß„ÄëÈúßÊòéÂç∞„ÅÆÊ∞óÈÖç„ÅåÊøÉ„ÅÑÔºâ',
        choices:[
          { label:'Âïè„ÅÑ„Çí‰∏Ä„Å§ÊÆã„ÅôÔºàÊÇü„Çä+Ôºâ', accent:true, apply:()=>{ S.hero.satori += 9; addKarma(2); log('<span class="good">Âïè</span>: ÊÇü„Çä„ÅåÂ¢ó„Åà„Åæ„Åó„Åü'); spawnMantraFx('Èúß'); } },
          { label:'ËÄÉ„Åà„Åö„Å´ÈÄ≤„ÇÄ', apply:()=>{ log('Ê≠©„ÇíÈÄ≤„ÇÅ„Åæ„Åó„Åü„ÄÇ'); } },
        ]
      });

      events.push({
        key:'animal_kansatsu',
        realmKey:'animal',
        goodBias:0.58,
        title:'Ë¶≥ÂØü ‚Äî Ê≠©ÂπÖ„ÇíÁü•„Çã',
        body:'Èúß„ÅØÊ∂à„Åà„Å™„ÅÑ„ÄÇ\n„Å†„Åå„ÄÅÊ≠©ÂπÖ„ÅØÂ§â„Åà„Çâ„Çå„Çã„ÄÇ\n„ÅÑ„Åæ„ÄÅË∂≥ÂÖÉ„ÇíÁ¢∫„Åã„ÇÅ„Çã„Åã„ÄÇ',
        foot:'',
        choices:[
          { label:'Ê≠©ÂπÖ„ÇíÊï¥„Åà„ÇãÔºàÁõæ+ / ÊÇü„Çä+ / Ê•≠+Ôºâ', accent:true, apply:()=>{ S.run.entryShield = Math.max(num(S.run.entryShield,0), 2.0); S.run.entryShieldDR = Math.max(num(S.run.entryShieldDR,0), 0.58); S.hero.satori += 7; addKarma(2); log('<span class="good">Ë¶≥</span>: Ë∫´„ÅåÊï¥„ÅÑ„Åæ„Åó„Åü'); spawnMantraFx('Ë¶≥'); } },
          { label:'Âã¢„ÅÑ„ÅßË∏è„ÅøËæº„ÇÄÔºàÂäüÂæ≥+ / Ê•≠-Ôºâ', apply:()=>{ const g=Math.floor(220+Math.random()*320); S.hero.gold+=g; addKarma(-2); log(`<span class="gold">ÂäüÂæ≥</span> +${fmt(g)} / <span class="warn">Ê•≠</span> -2`); } },
        ]
      });

      events.push({
        key:'animal_koukan',
        realmKey:'animal',
        goodBias:0.55,
        title:'‰∫§Êèõ ‚Äî Ë®ÄËëâ„Å™„ÅçÂèñÂºï',
        body:'Èúß„ÅÆÂ∏Ç„Åß„ÄÅË™∞„ÇÇË®ÄËëâ„Çí‰Ωø„Çè„Å™„ÅÑ„ÄÇ\nÂäüÂæ≥„Å®‰øÆË°å„ÅØ‰∫§Êèõ„Åß„Åç„Çã„ÅÆ„Åã„ÄÇ',
        foot:'',
        choices:[
          { label:'ÂäüÂæ≥„ÇíË°å„Å´Êèõ„Åà„ÇãÔºàÂæ≥- / Ë°å++ / Ê•≠+Ôºâ', accent:true, apply:()=>{ const c=260; if (S.hero.gold<c){ log('<span class="warn">ÂäüÂæ≥„ÅåË∂≥„Çä„Åæ„Åõ„Çì</span>'); return; } S.hero.gold-=c; const xp = Math.floor(240 + Math.random()*260); grantExp(xp); addKarma(2); log(`<span class="good">‰∫§Êèõ</span>: -${fmt(c)}ÂäüÂæ≥ / Ë°å +${fmt(xp)} / Ê•≠ +2`); spawnMantraFx('Èúß'); } },
          { label:'Êèõ„Åà„Å™„ÅÑÔºàÊÇü„Çä+Ôºâ', apply:()=>{ S.hero.satori += 6; addKarma(1); log('Êèõ„Åà„Åö„ÄÅÊ≠©„ÇíÈÄ≤„ÇÅ„Åæ„Åó„Åü„ÄÇ'); } },
        ]
      });
    }
    if (realmKey === 'asura'){
      events.push({
        key:'shikan',
        realmKey:'asura',
        goodBias:0.57,
        title:'Ê≠¢Ë¶≥ ‚Äî ÂàÉ„ÇíÂÜÖ„Å∏Êàª„Åô',
        body:'‰∫â„ÅÑ„ÅÆÂàÉ„ÅØ„ÄÅÂ§ñ„Å´Âêë„Åë„Çã„Åª„Å©Â¢ó„Åà„Çã„ÄÇ\n„ÅÑ„Åæ‰∏ÄÂ∫¶„ÄÅÂàÉ„ÇíÂÜÖ„Å∏Êàª„Åõ„ÄÇ',
        foot:'Ôºà„Äê‰∫â„Äë‰∫âÈè°Âç∞„ÅÆÊ∞óÈÖç„ÅåÊøÉ„ÅÑÔºâ',
        choices:[
          { label:'Ê≠¢Ë¶≥„Åô„ÇãÔºàÊ•≠+ / Áõæ+Ôºâ', accent:true, apply:()=>{ S.run.entryShield = Math.max(num(S.run.entryShield,0), 2.0); S.run.entryShieldDR = Math.max(num(S.run.entryShieldDR,0), 0.60); S.hero.satori += 6; addKarma(3); log('<span class="good">Ê≠¢Ë¶≥</span>: Ë∫´„ÅåÊï¥„ÅÑ„Åæ„Åó„Åü'); spawnMantraFx('‰∫â'); } },
          { label:'Âãù„Å°„ÇíÊ±Ç„ÇÅ„ÇãÔºàÂæ≥‚ÜëÔºâ', apply:()=>{ const g = Math.floor(180 + Math.random()*220); S.hero.gold += g; addKarma(-2); log(`<span class="gold">ÂäüÂæ≥</span> +${fmt(g)} / <span class="warn">Ê•≠</span> -2`); } },
        ]
      });

      events.push({
        key:'asura_katou',
        realmKey:'asura',
        goodBias:0.56,
        title:'ËëõËó§„ÅÆÊú≠ ‚Äî „Å©„Å°„Çâ„ÅÆÂàÉ„ÅßÊ≠©„Åè„Åã',
        body:'Âãù„Å§„Åü„ÇÅ„ÅÆÂàÉ„Å®„ÄÅË≤†„Åë„Å™„ÅÑ„Åü„ÇÅ„ÅÆÁõæ„ÄÇ\nËëõËó§„ÅØÊú≠„Å®„Å™„Å£„Å¶ËÉ∏„Å´Ë≤º„Çä‰ªò„Åè„ÄÇ',
        foot:'',
        choices:[
          { label:'Áõæ„ÇíÈÅ∏„Å∂ÔºàÁõæ+ / Ê•≠+Ôºâ', accent:true, apply:()=>{ S.run.entryShield = Math.max(num(S.run.entryShield,0), 2.6); S.run.entryShieldDR = Math.max(num(S.run.entryShieldDR,0), 0.66); S.hero.satori += 5; addKarma(2); log('<span class="good">Âøç</span>: Áõæ„ÅåÂéö„Åè„Å™„Çä„Åæ„Åó„Åü'); spawnMantraFx('Âøç'); } },
          { label:'ÂàÉ„ÇíÈÅ∏„Å∂ÔºàÂäüÂæ≥++ / Ê•≠-Ôºâ', apply:()=>{ const g=Math.floor(320+Math.random()*420); S.hero.gold += g; addKarma(-3); log(`<span class="gold">ÂäüÂæ≥</span> +${fmt(g)} / <span class="warn">Ê•≠</span> -3`); spawnMantraFx('‰∫â'); } },
        ]
      });

      events.push({
        key:'asura_hannya',
        realmKey:'asura',
        goodBias:0.60,
        title:'Ëà¨Ëã•„ÅÆÂΩ± ‚Äî ‰∫â„ÅÑ„ÇíÈÄè„Åã„Åô',
        body:'ÂΩ±„ÅåË®Ä„ÅÜ„ÄÇ„ÄåÁõ∏Êâã„ÅåÊïµ„Å™„ÅÆ„Åß„ÅØ„Å™„ÅÑ„ÄÇÊïµ„ÅÆÂÉè„ÅåÊïµ„Å†„ÄÇ„Äç\nÂΩ±„Å´Á§º„Çí„Åô„Çã„Åã„ÄÅÂè©„ÅçÂàá„Çã„Åã„ÄÇ',
        foot:'',
        choices:[
          { label:'Á§º„Çí„Åô„ÇãÔºàÊÇü„Çä++ / Ê•≠+Ôºâ', accent:true, apply:()=>{ S.hero.satori += 13; addKarma(3); log('<span class="good">Ëà¨Ëã•</span>: ÂÉè„ÅåËñÑ„Åè„Å™„Çä„Åæ„Åó„Åü'); spawnMantraFx('Ëà¨'); } },
          { label:'Âè©„ÅçÂàá„ÇãÔºàÂäüÂæ≥+ / Ê•≠-Ôºâ', apply:()=>{ const g=Math.floor(240+Math.random()*320); S.hero.gold += g; addKarma(-2); log(`<span class="gold">ÂäüÂæ≥</span> +${fmt(g)} / <span class="warn">Ê•≠</span> -2`); } },
        ]
      });
    }
    if (realmKey === 'human'){
      events.push({
        key:'seigan',
        realmKey:'human',
        goodBias:0.63,
        title:'Ë™ìÈ°ò ‚Äî ÁÑ°Âü∑ÁùÄ„ÅÆÁ®ΩÂè§',
        body:'ÊåÅ„Å§„Åì„Å®„ÅØÂÆà„Çä„Å´„Å™„Çã„ÄÇ\n„Å†„ÅåÊåÅ„Å°„Åô„Åé„Çå„Å∞Ë∂≥Êû∑„Å´„Å™„Çã„ÄÇ\n„ÄåÊÆã„ÅôÁêÜÁî±„Äç„Å®„ÄåÊâãÊîæ„ÅôÁêÜÁî±„Äç„ÇíÊõ∏„ÅçÂàÜ„Åë„Çà„ÄÇ',
        foot:'ÔºàËá™ÂãïÂ∏ÉÊñΩ„ÅØ„ÄåÊÆã„ÅôÈñæ„Äç„ÇíÊ±∫„ÇÅ„ÇãË™ì„ÅÑ„Å´Áõ∏ÂΩì„Åô„ÇãÔºâ',
        choices:[
          { label:'Êõ∏„ÅçÁïô„ÇÅ„ÇãÔºàÊÇü„Çä+Ôºâ', accent:true, apply:()=>{ S.hero.satori += 10; addKarma(3); log('<span class="good">Ë™ìÈ°ò</span>: Ëø∑„ÅÑ„ÅåÊ∏õ„Çä„Åæ„Åó„Åü'); spawnMantraFx('Êäû'); } },
          { label:'Ë™≠„ÅøÊç®„Å¶„Çã', apply:()=>{ addKarma(1); log('„Åù„Å£„Å®ÊâãÊîæ„Åó„Åæ„Åó„Åü„ÄÇ'); } },
        ]
      });

      events.push({
        key:'human_en',
        realmKey:'human',
        goodBias:0.60,
        title:'Á∏Å„ÅÆ‰øÆÂæ© ‚Äî ÂàáÊñ≠„ÅÆÂâç„Å´',
        body:'Á∏Å„ÅØË¶ã„Åà„Å™„ÅÑÁ≥∏„Å†„ÄÇ\nÂàá„Å£„Å¶„Åó„Åæ„Åà„Å∞ËªΩ„ÅÑ„ÄÇ\n„Å†„ÅåÁµê„Å≥Áõ¥„ÅôÊâã„ÅØ„ÄÅÈáç„ÅÑ„ÄÇ',
        foot:'',
        choices:[
          { label:'Áµê„Å≥Áõ¥„ÅôÔºàÂæ≥- / ÊÇü„Çä+ / Ê•≠+Ôºâ', accent:true, apply:()=>{ const c=240; if (S.hero.gold<c){ log('<span class="warn">ÂäüÂæ≥„ÅåË∂≥„Çä„Åæ„Åõ„Çì</span>'); return; } S.hero.gold-=c; S.hero.satori += 8; addKarma(3); log(`<span class="good">Á∏Å</span>: -${fmt(c)}ÂäüÂæ≥ / ÊÇü„Çä +8 / Ê•≠ +3`); spawnMantraFx('Á∏Å'); } },
          { label:'Êñ≠„Å§ÔºàÂäüÂæ≥+ / Ê•≠-Ôºâ', apply:()=>{ const g=Math.floor(280+Math.random()*360); S.hero.gold+=g; addKarma(-3); log(`<span class="gold">ÂäüÂæ≥</span> +${fmt(g)} / <span class="warn">Ê•≠</span> -3`); } },
        ]
      });

      events.push({
        key:'human_senkaku',
        realmKey:'human',
        goodBias:0.58,
        title:'ÈÅ∏Êäû„ÅÆÊ©ã ‚Äî ÁΩÆ„Åè/ÊåÅ„Å§',
        body:'Ê©ã„ÅÆ‰∏≠„Åª„Å©„Åß„ÄÅËç∑„ÅåÊÄ•„Å´Èáç„Åè„Å™„Çã„ÄÇ\n„ÅÑ„ÅæÁΩÆ„Åè„Åã„ÄÅÊåÅ„Å§„Åã„ÄÇ\nÈÅ∏„Å∂„Åì„Å®„Åå„ÄÅ‰∏ñÁïå„ÇíÂàá„ÇäÂàÜ„Åë„Çã„ÄÇ',
        foot:'',
        choices:[
          { label:'ÁΩÆ„ÅèÔºàÊÇü„Çä++ / Ê•≠+Ôºâ', accent:true, apply:()=>{ S.hero.satori += 14; addKarma(2); log('<span class="good">Êäû</span>: Ë∫´ËªΩ„Å´„Å™„Çä„Åæ„Åó„Åü'); spawnMantraFx('Êäû'); } },
          { label:'ÊåÅ„Å§ÔºàÂäüÂæ≥++ / Ê•≠-Ôºâ', apply:()=>{ const g=Math.floor(360+Math.random()*520); S.hero.gold+=g; addKarma(-4); log(`<span class="gold">ÂäüÂæ≥</span> +${fmt(g)} / <span class="warn">Ê•≠</span> -4`); } },
        ]
      });
    }
    if (realmKey === 'deva'){
      events.push({
        key:'gosui',
        realmKey:'deva',
        goodBias:0.52,
        title:'‰∫îË°∞„ÅÆÂÖÜ ‚Äî ÁÑ°Â∏∏„ÅÆÂΩ±',
        body:'Ê∫Ä„Å°„ÅüÁû¨Èñì„ÄÅÊ¨†„ÅëÂßã„ÇÅ„Çã„ÄÇ\nÂÖâ„ÅØÊ∞∏ÈÅ†„ÇíË£Ö„ÅÜ„Åå„ÄÅË°∞„Åà„ÅØÂøÖ„ÅöÊù•„Çã„ÄÇ\n„ÅÑ„Åæ„ÄåÁÑ°Â∏∏„Äç„ÇíË¶ã„Çã„Åã„ÄÇ',
        foot:'Ôºà„ÄêË°∞„Äë‰∫îË°∞Âç∞„ÅÆÊ∞óÈÖç„ÅåÊøÉ„ÅÑÔºâ',
        choices:[
          { label:'ÁÑ°Â∏∏Ë¶≥ÔºàÊÇü„Çä++ / Ê•≠++Ôºâ', accent:true, apply:()=>{ S.hero.satori += 14; addKarma(4); log('<span class="good">ÁÑ°Â∏∏</span>: ÂÖâ„ÅåÂΩ±„Å∏„Å®Áßª„Çä„Åæ„Åó„Åü'); spawnMantraFx('Ë°∞'); } },
          { label:'Ê†ÑÂÖâ„Å´Âü∑ÁùÄÔºàÂæ≥++ / Ê•≠-Ôºâ', apply:()=>{ const g = Math.floor(320 + Math.random()*420); S.hero.gold += g; addKarma(-4); log(`<span class="gold">ÂäüÂæ≥</span> +${fmt(g)} / <span class="warn">Ê•≠</span> -4`); } },
        ]
      });

      events.push({
        key:'deva_hossin',
        realmKey:'deva',
        goodBias:0.62,
        title:'Áô∫ÂøÉ ‚Äî ÂÖâ„ÇíÊç®„Å¶„Å¶ÁÅØ„Åô',
        body:'ÂÖâ„ÅØÂ§ñ„Å´„ÅÇ„Çã„Å®ÊÄù„ÅÜ„Åã„ÇâÁú©„Åó„ÅÑ„ÄÇ\nÂÜÖ„Å´ÁÅØ„Åõ„Å∞„ÄÅÁú©„Åó„Åï„ÅØË™ì„ÅÑ„Å´„Å™„Çã„ÄÇ\n„ÅÑ„ÅæÁô∫ÂøÉ„Åô„Çã„Åã„ÄÇ',
        foot:'',
        choices:[
          { label:'‰æõÁâ©„ÇíÊäï„Åò„ÇãÔºàÂæ≥- / ÊÇü„Çä++ / Ê•≠+Ôºâ', accent:true, apply:()=>{ const c=520; if (S.hero.gold<c){ log('<span class="warn">ÂäüÂæ≥„ÅåË∂≥„Çä„Åæ„Åõ„Çì</span>'); return; } S.hero.gold-=c; S.hero.satori += 20; addKarma(5); log(`<span class="good">Áô∫ÂøÉ</span>: -${fmt(c)}ÂäüÂæ≥ / ÊÇü„Çä +20 / Ê•≠ +5`); spawnMantraFx('Áô∫'); } },
          { label:'ÂÖâ„Å´ÂØÑ„ÇãÔºàÂäüÂæ≥+ / Ê•≠-Ôºâ', apply:()=>{ const g=Math.floor(260+Math.random()*360); S.hero.gold+=g; addKarma(-3); log(`<span class="gold">ÂäüÂæ≥</span> +${fmt(g)} / <span class="warn">Ê•≠</span> -3`); } },
        ]
      });

      events.push({
        key:'deva_en',
        realmKey:'deva',
        goodBias:0.48,
        title:'Â§©„ÅÆÂÆ¥ ‚Äî ÊîæÈÄ∏„ÅÆÈ¶ô',
        body:'Áîò„ÅÑÈ¶ô„ÅåÊºÇ„ÅÜ„ÄÇ\nÊîæÈÄ∏„ÅØÊØí„Åß„ÅØ„Å™„ÅÑ„ÄÇ\n„Åü„Å†„ÄÅÊ≠©„Åø„ÇíÈÅÖ„Åè„Åô„Çã„ÄÇ',
        foot:'',
        choices:[
          { label:'Â∏≠„ÇíÈõ¢„Çå„ÇãÔºàÊÇü„Çä+ / Ê•≠+Ôºâ', accent:true, apply:()=>{ S.hero.satori += 10; addKarma(3); log('<span class="good">Èõ¢</span>: È¶ô„Å´Âëë„Åæ„Çå„Åö„Å´Ê∏à„Åø„Åæ„Åó„Åü'); spawnMantraFx('Ë°∞'); } },
          { label:'ÊùØ„ÇíÂèñ„ÇãÔºàÂæ≥+++ / Ê•≠---Ôºâ', apply:()=>{ const g=Math.floor(520+Math.random()*760); S.hero.gold+=g; addKarma(-6); log(`<span class="gold">ÂäüÂæ≥</span> +${fmt(g)} / <span class="warn">Ê•≠</span> -6`); spawnMantraFx('ÂÆ¥'); } },
        ]
      });
    }


    // Ê•≠„ÅÆÂØÑ„ÇäÔºàÂÖ≠ÈÅìÔºâ√ó ÂÇæ„ÅçÔºàÂñÑÊÇ™Ôºâ„ÅßÈáç„Åø‰ªò„Åë„Åó„Å¶ÈÅ∏„Å∂
    const wOf = (ev)=>{
      let w = num(ev.w, 1);
      if (ev && ev.key === "kanjo") w *= 999; // ÁÅåÈ†Ç„ÅØË¶ãÈÄÉ„Åï„Å™„ÅÑ
      const gb = clamp((ev.goodBias==null ? 0.5 : ev.goodBias), 0, 1);
      const align = 1 - Math.abs(gb - goodBias); // 1=‰∏ÄËá¥, 0=ÁúüÈÄÜ
      w *= (0.55 + 1.25*align);
      if (ev.realmKey && ev.realmKey === realmKey) w *= (1 + biasStrength*2.4);
      return Math.max(0.01, w);
    };
    const pool = events.map(ev => ({...ev, _w:wOf(ev)}));
    const pick = pickWeighted(pool, "_w") || pool[0];

    openEvent(pick);
    return true;
  }

  function openCodex(){
    if (!els.codexOverlay) return;
    ensureStoryFields();
    const c = S.hero.codex;
    const realms = REALM_ORDER.filter(k => (c.realms||{})[k]);
    const realmTxt = realms.length ? realms.map(k=>REALM_LABEL[k]).join(' / ') : 'Êú™Ë®òÈå≤';

    const story = c.story || {};
    const intros = story.intros || {};
    const seals = story.seals || {};
    const storyRows = REALM_ORDER.map(k=>{
      const st = STORY[k] || {};
      const a = intros[k] ? 'Â∫è' : '‚Äî';
      const b = seals[k] ? 'Âç∞' : '‚Äî';
      const tag = st.tagline || '';
      return `<div style="display:flex; gap:10px; align-items:baseline; padding:4px 0; border-bottom:1px solid rgba(255,255,255,0.06);">
        <span class="pill">${a}</span>
        <span class="pill">${b}</span>
        <span style="min-width:64px">${escapeHtml(REALM_LABEL[k]||k)}</span>
        <span class="muted" style="font-size:11px">${escapeHtml(tag)}</span>
      </div>`;
    }).join('');

    const lastVerse = story.last || '';
    const lastRealmLabel = story.lastRealm ? (REALM_LABEL[story.lastRealm]||story.lastRealm) : '';

    els.codexBody.innerHTML = `
      <div class="codexGrid">
        <div class="codexCard"><div class="k">ÂÖ≠ÈÅì„ÅÆË®òÈå≤</div><div class="v">${escapeHtml(realmTxt)}</div><div class="p">ÈöéÂ±§„Å´„Çà„ÇäÂ∑°Âõû„ÄÇÊ•≠„Å´„Çà„ÇäÂá∫Áèæ‚ÄúÂØÑ„Çä‚Äù„ÅåÁîü„Åò„Åæ„Åô„ÄÇ</div></div>
        <div class="codexCard"><div class="k">Êà¶Êûú</div><div class="v">ÊíÉÁ†¥ ${fmt(c.kills||0)} / Ê†πÊú¨ ${fmt(c.bosses||0)} / ÈáçÁÖ© ${fmt(c.elites||0)} / ÂÖ≠Âç∞Ê¨†Áâá ${fmt(c.uniques||0)}</div><div class="p">ÊúÄÂ§ßÂà∞ÈÅîÂ±§: Á¨¨${fmt(c.maxFloor||1)}Â±§</div></div>
        <div class="codexCard"><div class="k">‰øÆË°å</div><div class="v">ÁúüË®Ä ${fmt(c.mantras||0)} / Ë≠∑Êë© ${fmt(c.purifies||0)} / ÊÇü„Çä ${fmt(S.hero.satori||0)}</div><div class="p">ÁúüË®Ä„ÅØÁü≠ÊôÇÈñìÂä†ÊåÅ„ÄÇË≠∑Êë©„ÅØÊ•≠„ÅÆÂÅè„Çä„Çí0„Å∏ÂØÑ„Åõ„Åæ„Åô„ÄÇ</div></div>
        <div class="codexCard"><div class="k">ÂÑÄÁ§ºË®òÈå≤</div><div class="v">${fmt(Object.keys(c.events||{}).length)} ‰ª∂</div><div class="p">ÈòøÂ≠óË¶≥„ÉªË≠∑Êë©„ÉªÂÜôÁµå„ÉªÁµêÁïå„Å™„Å©„ÄÇ</div></div>
        <div class="codexCard"><div class="k">ÂÖ≠Âç∞ÔºàÊ¨†ÁâáÔºâ</div>
          <div class="v">${fmt(fragmentCount())}/6</div>
          <div class="p">${escapeHtml((()=>{ const fr=(story.fragments||{}); return REALM_ORDER.map(k=>`„Äê${(STORY[k]||{}).glyph||"Âç∞"}„Äë${(fr[k]||0)>0?"‚úì":"‚Äî"}`).join(" "); })())}</div>
          <div class="p">${escapeHtml((()=>{ const ed=String(story.ending||""); if(ed==="kongo") return "ÁµêÈ°ò: ÈáëÂâõÁïåÔºàË™ø‰ºèÔºâ"; if(ed==="taizo") return "ÁµêÈ°ò: ËÉéËîµÁïåÔºàÊÖàÊÇ≤Ôºâ"; if(hasAllSixFragments()) return "ÁµêÈ°ò: Êú™ÔºàÈÅ∏ÊäûÂèØÔºâ"; return "ÁµêÈ°ò: ‚Äî"; })())}</div>
          ${hasAllSixFragments() && String(story.ending||"")!=="kongo" && String(story.ending||"")!=="taizo" ? `<button id="btnKetsugan" class="accent" style="margin-top:6px;">ÁµêÈ°ò„ÇíÁµê„Å∂</button>` : ``}
        </div>

      </div>

      <div class="codexGrid" style="margin-top:10px;">
        <div class="codexCard" style="grid-column:1/-1;">
          <div class="k">ÊõºËçºÁæÖÂ∏≥ÔºàÁ´†Ôºâ</div>
          <div class="p">Â∫è=ÁïåÈñÄ„ÅÆË®òÈå≤ / Âç∞=Áïå„ÅÆÊ†πÊú¨„Åå‰∏ÄÂ∫¶„Åª„Å©„Åë„ÅüË®º„ÄÇÁ´†„ÅØÂÖ≠ÈÅì„Åô„Åπ„Å¶„Å´Â≠òÂú®„Åó„Åæ„Åô„ÄÇ</div>
          <div style="margin-top:6px;">${storyRows || '<span class="muted">‚Äî</span>'}</div>
        </div>
        <div class="codexCard" style="grid-column:1/-1;">
          <div class="k">ÊúÄÁµÇÂÅà</div>
          <div class="v">${escapeHtml(lastVerse || '‚Äî')}</div>
          <div class="p">${escapeHtml(lastRealmLabel ? ('Ë®ò„Åï„Çå„ÅüÁïå: ' + lastRealmLabel) : '')}</div>
        </div>
      </div>
`;
    // ÂÖ≠Âç∞„ÅåÊèÉ„Å£„Å¶„ÅÑ„Çå„Å∞„ÄåÁµêÈ°ò„Äç„ÇíÈÅ∏„Åπ„Çã
    try{
      const btn = document.getElementById("btnKetsugan");
      if (btn){
        btn.onclick = ()=>{
          try{ closeCodex(); }catch(_){}
          try{ openEndingChoice(); }catch(_){}
          save(); dirtyHUD = true;
        };
      }
    }catch(_){}

    els.codexOverlay.style.display = 'flex';
  }
  function closeCodex(){

    if (!els.codexOverlay) return;
    els.codexOverlay.style.display = 'none';
    save();
    dirtyHUD = true;
  }

  // --------------------
  // Events
  // --------------------
  els.btnExplore.addEventListener("click", () => {
    if (S.hero.dead) { log("Ë™ø‰ºè„Å´Ëá≥„Çâ„Åö„ÄÇÂæ©Ê¥ª„ÅÆÂÑÄ„ÇíË°å„Å£„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ"); dirtyHUD=true; dirtyLog=true; return; }
    if (S.run.active) return;
    // v58: ÂàùÂõûÈñãÂßãÊôÇ„Å´ÂêçÂâç„ÇíË®≠ÂÆö„Åß„Åç„Çã
    ensureHeroName();
    startExplore();
  });
  els.btnPause.addEventListener("click", () => pauseExplore());

if (els.btnChant) els.btnChant.addEventListener('click', () => castMantra());
if (els.btnCodex) els.btnCodex.addEventListener('click', () => openCodex());
if (els.btnCodexClose) els.btnCodexClose.addEventListener('click', () => closeCodex());
if (els.codexOverlay) els.codexOverlay.addEventListener('click', (ev)=>{ if (ev.target === els.codexOverlay) closeCodex(); });

if (els.btnEventClose) els.btnEventClose.addEventListener('click', () => closeEvent());
if (els.eventOverlay) els.eventOverlay.addEventListener('click', (ev)=>{ if (ev.target === els.eventOverlay) closeEvent(); });

if (els.btnPurify) els.btnPurify.addEventListener('click', () => doPurify());


// ÈçµÊìç‰Ωú
window.addEventListener('keydown', (ev)=>{
  if (ev.key === 'm' || ev.key === 'M'){ if (els.btnChant) castMantra(); }
  if (ev.key === 'c' || ev.key === 'C'){ if (els.codexOverlay && els.codexOverlay.style.display==='flex') closeCodex(); else openCodex(); }
});

  // Log auto-scroll pinning: if user scrolls up, stop force-scrolling
  if (els.log){
    logPinned = true;
    els.log.addEventListener('scroll', ()=>{ logPinned = isLogPinned(els.log); }, {passive:true});
    els.log.addEventListener('wheel', ()=>{ logPinned = isLogPinned(els.log); }, {passive:true});
    els.log.addEventListener('touchstart', ()=>{ logPinned = isLogPinned(els.log); }, {passive:true});
  }


  if (els.btnBack) els.btnBack.addEventListener("click", () => prevRoom());
  if (els.btnNext) els.btnNext.addEventListener("click", () => nextRoom());
  if (els.tabs) els.tabs.addEventListener("click", (ev) => {
    const b = ev.target.closest("button[data-tab]");
    if (!b) return;
    S.ui = S.ui ?? { tab:"all" };
    S.ui.tab = b.dataset.tab || "all";
    save();
    dirtyInv = true;
    renderInventory();
  });

  els.btnSave.addEventListener("click", () => { save(); log("ÊâãÂãïË®òÈå≤„Åó„Åæ„Åó„Åü„ÄÇ"); dirtyLog=true; });
  els.btnReset.addEventListener("click", () => { if (confirm("ÂÖ®Ë®òÈå≤„ÇíËº™Âªª„Åó„Åæ„Åô„ÄÇ„Çà„Çç„Åó„ÅÑ„Åß„Åô„ÅãÔºü")) hardReset(); });

  if (els.lockWeapon) els.lockWeapon.addEventListener('click', () => toggleEquipLock('weapon'));
  if (els.lockArmor) els.lockArmor.addEventListener('click', () => toggleEquipLock('armor'));
  if (els.lockAcc) els.lockAcc.addEventListener('click', () => toggleEquipLock('accessory'));

    els.speedSel.addEventListener("change", () => {
    const v = Number(els.speedSel.value);
    const cur = Number.isFinite(S.run.speed) ? Number(S.run.speed) : 1;

    // Gate MAX until all six fragments are collected.
    if (v >= SPEED_MAX_LABEL && !isMaxSpeedUnlocked()){
      const fallback = Math.max(...SPEED_ALLOWED.filter(x => x < SPEED_MAX_LABEL));
      S.run.speed = fallback;
      els.speedSel.value = String(fallback);
      try{
        const n = Math.min(6, Math.max(0, fragmentCount()));
        log(`<span class="warn">ËøÖË°åMAX</span>: ÂÖ≠Âç∞„ÅÆÊ¨†Áâá„Çí6„Å§ÊèÉ„Åà„Çã„Å®Ëß£ÊîæÔºàÁèæÂú® ${n}/6Ôºâ`);
        dirtyLog = true;
      }catch(_){}
      // Keep the dropdown label in sync
      try{ syncSpeedSelUnlock(); }catch(_){}
    } else {
      S.run.speed = v;
    }

    if (!S.ui) S.ui = {};
    S.ui._userTouchedSpeed = 1;
    save();
    dirtyHUD = true;
  });
  els.autoSel.addEventListener("change", () => { S.run.auto = els.autoSel.value === "1"; save(); dirtyHUD=true; });
  if (els.fxSel){
    els.fxSel.addEventListener("change", () => {
      S.ui = S.ui ?? { tab:"all", preview:null, fx:1 };
      S.ui.fx = (els.fxSel.value === "0") ? 0 : 1;
      save();
      dirtyHUD = true;
      try { if (typeof BFX !== "undefined" && BFX && BFX.setEnabled) BFX.setEnabled(S.ui.fx !== 0); } catch(_){ }
      try { if (typeof BATTLE !== "undefined" && BATTLE && BATTLE.sync) BATTLE.sync(); } catch(_){ }
    });
  }

  function syncBulkLabels(force=false){
    const upN = clampBulk((els.upgBulkSel && els.upgBulkSel.value) ? els.upgBulkSel.value : (S.ui&&S.ui.upgBulk)||1);
    const gN  = clampBulk((els.gupgBulkSel && els.gupgBulkSel.value) ? els.gupgBulkSel.value : (S.ui&&S.ui.gupgBulk)||1);
    document.querySelectorAll("button[data-upg]").forEach(btn => {
      const key = btn.getAttribute("data-upg");
      btn.textContent = `${UPG_LABEL[key] || key} +${upN}`;
    });
    document.querySelectorAll("button[data-gupg]").forEach(btn => {
      if (!btn.dataset.baseText) btn.dataset.baseText = btn.textContent;
      btn.textContent = `${btn.dataset.baseText} √ó${gN}`;
    });
  }

  if (els.upgBulkSel){
    els.upgBulkSel.addEventListener("change", () => {
      S.ui = S.ui ?? { tab:"all", preview:null, fx:1, upgBulk:1, gupgBulk:1 };
      S.ui.upgBulk = clampBulk(els.upgBulkSel.value);
      save();
      syncBulkLabels(true);
      dirtyHUD = true;
    });
  }
  if (els.gupgBulkSel){
    els.gupgBulkSel.addEventListener("change", () => {
      S.ui = S.ui ?? { tab:"all", preview:null, fx:1, upgBulk:1, gupgBulk:1 };
      S.ui.gupgBulk = clampBulk(els.gupgBulkSel.value);
      save();
      syncBulkLabels(true);
      dirtyHUD = true;
    });
  }

  // init labels once
  syncBulkLabels(true);

  els.search.addEventListener("input", () => { dirtyInv=true; });
  els.sortSel.addEventListener("change", () => { dirtyInv=true; });

  
  if (els.btnClearSearch){
    els.btnClearSearch.addEventListener("click", () => {
      if (!els.search) return;
      els.search.value = "";
      dirtyInv = true;
      try{ els.search.focus(); }catch(_){}
    });
  }
function saveAutoSellUI(){
    S.ui = S.ui ?? { tab:"all", preview:null, fx:1, upgBulk:1, gupgBulk:1 };
    if (els.autoSellOn) S.ui.autoSellOn = els.autoSellOn.checked ? 1 : 0;
    if (els.autoSellRarMax) S.ui.autoSellRarMax = String(els.autoSellRarMax.value || "common");
    if (els.autoSellUseEq) S.ui.autoSellUseEq = (els.autoSellUseEq.checked ? 1 : 0);
    if (els.autoSellEqPct){
      const v = clamp(Math.floor(Number(els.autoSellEqPct.value)||90), 1, 100);
      S.ui.autoSellEqPct = v;
      els.autoSellEqPct.value = String(v);
    }
    if (els.autoSellProtectUnique) S.ui.autoSellProtectUnique = els.autoSellProtectUnique.checked ? 1 : 0;
    save();
  }

  if (els.autoSellOn) els.autoSellOn.addEventListener("change", () => { saveAutoSellUI(); dirtyHUD=true; });
  if (els.autoSellRarMax) els.autoSellRarMax.addEventListener("change", () => { saveAutoSellUI(); dirtyHUD=true; });
  if (els.autoSellUseEq) els.autoSellUseEq.addEventListener("change", () => { saveAutoSellUI(); dirtyHUD=true; });
  if (els.autoSellEqPct) els.autoSellEqPct.addEventListener("change", () => { saveAutoSellUI(); dirtyHUD=true; });
  if (els.autoSellProtectUnique) els.autoSellProtectUnique.addEventListener("change", () => { saveAutoSellUI(); dirtyHUD=true; });
  els.btnSellAll.addEventListener("click", () => {
    if (!S.inv.length) return;
    if (confirm("Ê≥ïÂÖ∑Â∫´„ÇíÂÖ®Â∏ÉÊñΩ„Åó„Åæ„Åô„ÄÇ„Çà„Çç„Åó„ÅÑ„Åß„Åô„ÅãÔºü")) sellWhere(_ => true);
  });

  document.querySelectorAll("button[data-upg]").forEach(btn=>{
    btn.addEventListener("click", () => buyUpgradeN(btn.getAttribute("data-upg"), (els.upgBulkSel ? els.upgBulkSel.value : 1)));
  });
  document.querySelectorAll("button[data-gupg]").forEach(btn=>{
    btn.addEventListener("click", () => buyGuildN(btn.getAttribute("data-gupg"), (els.gupgBulkSel ? els.gupgBulkSel.value : 1)));
  });
  els.btnRevive.addEventListener("click", () => revive());
  els.btnOpenChest.addEventListener("click", () => openOfflineChest());

  // ‚úÖ FIX: event delegation
  els.invList.addEventListener("click", (ev) => {
    const eqBtn = ev.target.closest("button[data-eq]");
    if (eqBtn){
      equip(eqBtn.getAttribute("data-eq"));
      return;
    }
    const sellBtn = ev.target.closest("button[data-sell]");
    if (sellBtn){
      sell(sellBtn.getAttribute("data-sell"));
      return;
    }
    const itemEl = ev.target.closest(".item[data-item]");
    if (itemEl){
      setPreview(itemEl.getAttribute("data-item"));
      return;
    }
  });

  window.addEventListener("beforeunload", () => save());

  // --------------------
  // Main loop: simulate fast, render slow (v4 fix)
  // --------------------
  function simLoop(){
    try{
      const t = now();
      lastSimFrame = t;
      const r = S.run;

      // v11: ÂÄ§„ÅåÂ£ä„Çå„Å¶Ë°®Á§∫/ÈÄ≤Ë°å„ÅåÊ≠¢„Åæ„Çã„ÅÆ„ÇíÈò≤„Åê
      sanitizeRuntime();
      const speed = Number.isFinite(r.speed) ? r.speed : 1;

      // ÂÆâÂÆöÂåñ: lastTick/_acc„ÅåÂ£ä„Çå„Å¶„ÇÇ„ÄÅdt„ÅåNaN„Å´„Å™„Å£„Å¶Ê≠¢„Åæ„Çâ„Å™„ÅÑ
      const last = Number.isFinite(r.lastTick) ? r.lastTick : t;
      let dt = (t - last) / 1000;
      if (!Number.isFinite(dt) || dt < 0) dt = 0;
      dt = Math.min(dt, 0.5); // È†ÅÂæ©Â∏∞„Å™„Å©„ÅÆÂ∑®Â§ßdt„ÇíÊäëÂà∂
      r.lastTick = t;

      const isMaxSpeed = (speed >= SPEED_MAX_LABEL);
      const simSpeed = effectiveSimSpeedScaled(speed);
      // --- iOS speed calibration ---
      // Some iPhone Safari environments throttle timers/RAF in a way that makes even 1√ó feel too slow.
      // We measure "actual sim progress vs expected" and apply a mild multiplier to keep speeds comparable to PC.
      if (IS_IOS && speed < SPEED_MAX_LABEL){
        r._iosSpeedScale = Number.isFinite(r._iosSpeedScale) ? r._iosSpeedScale : 1;
        r._iosCalT = Number.isFinite(r._iosCalT) ? r._iosCalT : t;
        r._iosCalSim = Number.isFinite(r._iosCalSim) ? r._iosCalSim : (Number.isFinite(r._roomTime) ? r._roomTime : 0);

        if ((t - r._iosCalT) >= 1800){
          const realS = (t - r._iosCalT) / 1000;
          const simNow = Number.isFinite(r._roomTime) ? r._roomTime : 0;
          const simDelta = simNow - r._iosCalSim;

          const expected = effectiveSimSpeed(speed) * realS; // base expectation (no scale)
          if (realS > 0.5 && expected > 0){
            const ratio = simDelta / expected; // <1 means we're slower than intended
            if (Number.isFinite(ratio) && ratio > 0){
              if (ratio < 0.85){
                const boost = clamp(1 / Math.max(0.10, ratio), 1, 6);
                r._iosSpeedScale = clamp(r._iosSpeedScale * boost, 1, 12);
              }else if (ratio > 1.20 && r._iosSpeedScale > 1.02){
                r._iosSpeedScale = clamp(r._iosSpeedScale * 0.92, 1, 12);
              }else{
                // gentle drift back to 1
                r._iosSpeedScale = r._iosSpeedScale + (1 - r._iosSpeedScale) * 0.05;
              }
            }
          }

          r._iosCalT = t;
          r._iosCalSim = simNow;
        }
      }


      // --- Adaptive step (especially for iPhone/iOS) ---
      // Slow devices may not be able to execute enough tick() calls per second at high speeds.
      // We enlarge the simulation step when backlog (acc) grows, so the selected speed feels consistent.
      const baseStep = isMaxSpeed ? (IS_IOS ? 0.60 : 0.20) : 0.05;
      let acc = (Number.isFinite(r._acc) ? r._acc : 0) + dt * simSpeed;

      // Á©çÈå≤„ÅåÊ∫ú„Åæ„Çä„Åô„Åé„Çã„Å®Âá¶ÁêÜ„ÅåÈáç„Åè„Å™„Å£„Å¶„ÄéÊ≠¢„Åæ„Å£„Åü„Äè„Çà„ÅÜ„Å´Ë¶ã„Åà„Çã„Åü„ÇÅ„ÄÅ‰∏ÄÂÆö‰ª•‰∏ä„ÅØÈñìÂºï„Åè
      const maxStepsPerFrame = isMaxSpeed ? (IS_IOS ? 36 : 60) : 220;

      // If backlog is high, increase step so we can catch up with fewer tick() calls.
      let step = baseStep;
      if (IS_IOS){
        const stepCap = isMaxSpeed ? 1.20 : 0.40; // keep non-MAX accuracy reasonable
        // Fewer desired steps at higher speeds to reduce CPU load on iPhone
        const desiredSteps =
          isMaxSpeed ? 18 :
          (speed >= 8 ? 18 : speed >= 4 ? 22 : 28);

        if (acc > baseStep * desiredSteps){
          step = clamp(acc / desiredSteps, baseStep, stepCap);
        }
      }

      const maxAcc = step * maxStepsPerFrame;
      if (acc > maxAcc){
        acc = maxAcc;
        if (!r._accDropLogged){
          try{ log(`<span class="warn">Ë≤†Ëç∑ÂØæÁ≠ñ</span>: Ë©¶ÁÆó„ÅåËøΩ„ÅÑ„Å§„Åã„Å™„ÅÑ„Åü„ÇÅ„ÄÅÂá¶ÁêÜ„ÇíÈñìÂºï„Åç„Åæ„Åó„ÅüÔºàËøÖË°å„Çí‰∏ã„Åí„Çã„Å®ÂÆâÂÆö„Åó„Åæ„ÅôÔºâ`); } catch{}
          r._accDropLogged = true;
          dirtyLog = true;
        }
      }

      let guard = 0;
      const t0 = (typeof performance !== 'undefined' && performance.now) ? performance.now() : now();
      const budgetMs = isMaxSpeed ? (IS_IOS ? 14 : 18) : 14;
      while (acc >= step && guard++ < maxStepsPerFrame){
        tick(step);
        acc -= step;
        const t1 = (typeof performance !== 'undefined' && performance.now) ? performance.now() : now();
        if ((t1 - t0) > budgetMs) break;
      }
      r._acc = acc;

      requestAnimationFrame(simLoop);
    } catch (e){
      try{ logImportant(`<span class="bad">‰æãÂ§ñ</span>: ${String(e).slice(0, 120)}`); } catch{}
      S.run.active = false;
      dirtyHUD = true; dirtyLog = true;
      requestAnimationFrame(simLoop);
    }
  }

  // Render throttle
  setInterval(() => {
    try{
      const tNow = now();
      lastRenderFrame = tNow;

      // Always update the lightweight run mini.
      renderRunLocMini();

      // MAX speed: keep UI alive but throttle heavier renders.
      if (isSpeedMax()){
        const r = (S && S.run) ? S.run : null;
        if (r){
          // Stage keepalive (icons/animation) even when HUD is throttled.
          try{ if (typeof BATTLE !== "undefined" && BATTLE && BATTLE.syncLite) BATTLE.syncLite(); }catch(_){}

          // HUD throttle (bars / numbers): ~4-5fps
          r._maxHudT = Number.isFinite(r._maxHudT) ? r._maxHudT : 0;
          if (dirtyHUD && (tNow - r._maxHudT) >= 220){
            r._maxHudT = tNow;
            renderHUD();
            dirtyHUD = false;
            try{ if (typeof updateHUDSpritesLite === "function") updateHUDSpritesLite(); }catch(_){}
          }

          // Full UI throttle (log / inventory / compare): ~2fps
          r._maxUiT = Number.isFinite(r._maxUiT) ? r._maxUiT : 0;
          if (tNow - r._maxUiT < 520) return;
          r._maxUiT = tNow;
        }
      }

      // Full pass (normal, or throttled MAX)
      if (dirtyHUD){ renderHUD(); dirtyHUD = false; }
      if (dirtyLog){ renderLog(); dirtyLog = false; }
      if (S.ui && S.ui.preview) renderCompare();

      const invSig = inventorySignature();
      const q = (els.search.value || "").trim().toLowerCase();
      const s = els.sortSel.value;
      const isMax = isSpeedMax();
      const needInv = dirtyInv || (!isMax && invSig !== lastInvSig) || q !== lastQuery || s !== lastSort;
      if (needInv){
        lastInvSig = invSig; lastQuery = q; lastSort = s;
        renderInventory();
        dirtyInv = false;
        if (S.ui && S.ui.preview) renderCompare();
      } else {
        els.invCount.textContent = `${S.inv.length} ÂÄã`;
      }
    } catch(e){
      try{ logImportant(`<span class="bad">ÊèèÁîª‰æãÂ§ñ</span>: ${String(e).slice(0, 120)}`); } catch{}
    }
  }, (IS_IOS ? 220 : 140));

  // Offline apply once
  (function boot(){
    applyOffline();
    // iOS: default FX off (can be turned back on from UI) to keep MAX speed usable.
    try{
      S.ui = S.ui ?? { tab:"all", preview:null, fx:1 };
      if (IS_IOS && (S.ui.fx === undefined || S.ui.fx === null)) S.ui.fx = 0;
      if (IS_IOS && Number(S.ui.fx) === 0){
        try{ if (typeof BFX!=="undefined" && BFX && BFX.setEnabled) BFX.setEnabled(false); }catch(_){}
      }
    }catch(_){}

    ensureEnemy();
    try{ AURA.init(); }catch(_){ }
    try{ updateRealmFx(); }catch(_){ }
    try{ if (typeof SOUND!=="undefined" && SOUND) SOUND.stop(); }catch(_){ }
    logImportant(`<span class="good">Ëµ∑Âãï</span>: Á¨¨ÂçÅ‰∏âÁâàÔºàÂØÜÊïôÊã°Âºµ: ‰∫åÊõºËçºÁæÖ/ÂÖ≠ÈÅì„ÅÆÈü≥„ÉªÁ≤íÂ≠ê/‰∫îÊØí‰ªïÊéõÔºâ`);
    save();
    dirtyHUD = true; dirtyInv = true; dirtyLog = true;
  })();


  // Watchdog: ‰Ωï„Çâ„Åã„ÅÆÁêÜÁî±„ÅßËº™Ëª¢/ÊèèÁîª„ÅåÊ≠¢„Åæ„Å£„ÅüÂ†¥Âêà„Å´Ëá™ÂãïÂæ©Êóß
  setInterval(() => {
    try{
      const t = now();
      // simLoop„ÅåÊ≠¢„Åæ„Å£„Å¶„ÅÑ„Çã„Å£„ÅΩ„ÅÑ
      if ((t - lastSimFrame) > 1500){
        requestAnimationFrame(simLoop);
      }
      // ÊèèÁîª„ÅåÊ≠¢„Åæ„Å£„Å¶„ÅÑ„Çã„Å£„ÅΩ„ÅÑ
      if ((t - lastRenderFrame) > 1500){
        dirtyHUD = true; dirtyInv = true; dirtyLog = true;
      }
    } catch(_){}
  }, 900);

  setInterval(save, 10000);
  requestAnimationFrame(simLoop);
})();
</script>


</body>
</html>
